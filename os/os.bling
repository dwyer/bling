package os

import "C"
import "paths"
import "runtime"
import "sys"

typ O enum {
    O_RDONLY = sys.O_RDONLY
    O_WRONLY = sys.O_WRONLY
    O_RDWR = sys.O_RDWR
    O_APPEND = sys.O_APPEND
    O_CREAT = sys.O_CREAT
    O_TRUNC = sys.O_TRUNC
    O_EXCL = sys.O_EXCL
}

typ Time u64

typ FileMode u32

typ File struct {
    fd uintptr
    name runtime.charptr
    _isDir bool
}

typ FileInfo struct {
    _name runtime.charptr
    _sys voidptr
}

var _stdin File = {
    fd: sys.STDIN_FILENO,
    name: "/dev/stdin",
}

var _stdout File = {
    fd: sys.STDOUT_FILENO,
    name: "/dev/stdout",
}

var _stderr File = {
    fd: sys.STDERR_FILENO,
    name: "/dev/stderr",
}

var stdin *File = &_stdin
var stdout *File = &_stdout
var stderr *File = &_stderr

fun _throwPathError(path runtime.charstr, err *runtime.Error, e **runtime.Error) {
    if err {
        var msg = err.error
        err.error = C.sprintf("PathError: %s: %s", path, msg)
        runtime.free(msg)
        runtime.Error_move(err, e)
    }
}

fun _throwFileError(file *File, err *runtime.Error, e **runtime.Error) {
    if err {
        if e == nil {
            file.close(nil) // close the file before we panic
        }
        _throwPathError(file.name, err, e)
    }
}

fun newFile(fd uintptr, name runtime.charstr) *File {
    var file File = {
        name: runtime.strdup(name),
        fd: fd,
    }
    return &&file
}

fun openFile(filename runtime.charstr, mode int, perm int, e **runtime.Error) *File {
    runtime.clearError()
    var err *runtime.Error = nil
    var fd = sys.open(filename, mode, perm, &err)
    if err {
        _throwPathError(filename, err, e)
        return nil
    }
    return newFile(fd, filename)
}

fun open(filename runtime.charstr, e **runtime.Error) *File {
    return openFile(filename, O_RDONLY, 0, e)
}

fun create(filename runtime.charstr, e **runtime.Error) *File {
    return openFile(filename, O_CREAT | O_TRUNC | O_RDWR, 0644, e)
}

fun (file *File) read(b []char, e **runtime.Error) int {
    var err *runtime.Error = nil
    var r = sys.read(file.fd, b, &err)
    _throwFileError(file, err, e)
    return r
}

fun (file *File) write(b []char, e **runtime.Error) int {
    var err *runtime.Error = nil
    var n = sys.write(file.fd, b, &err)
    _throwFileError(file, err, e)
    return n
}

fun (file *File) close(e **runtime.Error) {
    var err *runtime.Error = nil
    if file._isDir {
        sys.closedir(typ voidptr(file.fd), &err)
    } else {
        sys.close(file.fd, &err)
    }
    _throwPathError(file.name, err, e)
}

fun stat(name runtime.charstr, e **runtime.Error) *FileInfo {
    var st = sys.Stat{}
    var err *runtime.Error = nil
    sys.stat(name, &st, &err)
    if err {
        _throwPathError(name, err, e)
        return nil
    }
    var info = FileInfo{
        _name: runtime.strdup(name),
        _sys: &&st,
    }
    return &&info
}

fun (info *FileInfo) free() {
    if info != nil {
        runtime.free(info._name)
        runtime.free(info._sys)
        runtime.free(info)
    }
}

fun openDir(name runtime.charstr, e **runtime.Error) *File {
    var err *runtime.Error = nil
    var dp = sys.opendir(name, &err)
    if err {
        _throwPathError(name, err, e)
        return nil
    }
    var file = newFile(typ uintptr(dp), name)
    file._isDir = true
    return file
}

fun readdirnames(file *File, e **runtime.Error) []runtime.charptr {
    var arr = makearray(runtime.charptr)
    var dp sys.Dir = typ sys.Dir(file.fd)
    for ;; {
        var err *runtime.Error = nil
        var dirent = sys.readdir(dp, &err)
        if dirent == nil {
            break
        }
        var name = sys.Dirent_name(dirent)
        if name[0] == '.' {
            continue
        }
        append(arr, runtime.strdup(name))
    }
    return arr
}

fun readdir(file *File, e **runtime.Error) []*FileInfo {
    var err *runtime.Error = nil
    var names = readdirnames(file, &err)
    var arr = []*FileInfo{}
    if err != nil {
        _throwFileError(file, err, e)
        return arr
    }
    for var i = 0; i < len(names); i++ {
        var path = paths.join2(file.name, names[i])
        runtime.free(names[i])
        var info *FileInfo = stat(path, &err)
        if err != nil {
            _throwFileError(file, err, e)
            _throwPathError(file.name, err, e)
            return arr
        }
        append(arr, info)
    }
    runtime.Slice_unmake(&names)
    return arr
}

fun (info *FileInfo) name() runtime.charptr {
    return info._name
}

fun (info *FileInfo) size() u64 {
    var st = typ *sys.Stat(info.sys())
    return st.size
}

fun (info *FileInfo) mode() FileMode {
    var st = typ *sys.Stat(info.sys())
    return st.mode
}

fun (info *FileInfo) modTime() Time {
    var st = typ *sys.Stat(info.sys())
    return st.mtime
}

fun (info *FileInfo) isDir() bool {
    var st = typ *sys.Stat(info.sys())
    return ((st.mode & 0170000) == 0040000)
}

fun (info *FileInfo) sys() voidptr {
    return info._sys
}

fun tempDir() runtime.charstr {
    var tmpdir = sys.getenv("TMPDIR")
    if tmpdir {
        return tmpdir
    }
    return "/tmp"
}

fun mkdir(path runtime.charstr, mode u32, e **runtime.Error) {
    var err *runtime.Error = nil
    sys.mkdir(path, mode, &err)
    _throwPathError(path, err, e)
}

fun mkdirAll(path runtime.charstr, mode u32, e **runtime.Error) {
    // TODO check if exists first
    var dir = paths.dir(path)
    if !runtime.streq(dir, ".") {
        mkdirAll(dir, mode, e)
    }
    runtime.free(dir)
    var err *runtime.Error = nil
    mkdir(path, mode, &err)
    switch sys.errno() {
    case 0, sys.EEXIST:
        break
    default:
        runtime.Error_move(err, e)
        break
    }
}

fun exec(argv [?]const runtime.charptr, e **runtime.Error) int {
    var status = -1
    var err *runtime.Error = nil
    var pid = sys.fork(&err)
    if err == nil {
        if pid == 0 {
            sys.exec(argv[0], argv, sys.environ(), &err)
        } else {
            sys.waitpid(pid, &status, 0, &err)
        }
    }
    if err {
        runtime.Error_move(err, e)
    }
    return status
}
