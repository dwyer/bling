package os

import "C"
import "paths"
import "runtime"
import "sys"

typ O enum {
    O_RDONLY = sys.O_RDONLY
    O_WRONLY = sys.O_WRONLY
    O_RDWR = sys.O_RDWR
    O_APPEND = sys.O_APPEND
    O_CREAT = sys.O_CREAT
    O_TRUNC = sys.O_TRUNC
    O_EXCL = sys.O_EXCL
}

typ Time u64

typ FileMode u32

typ File struct {
    fd uintptr
    name *char
    is_dir bool
}

typ FileInfo struct {
    _name *char
    _sys *void
}

var _stdin File = {
    fd: sys.STDIN_FILENO,
    name: "/dev/stdin",
}

var _stdout File = {
    fd: sys.STDOUT_FILENO,
    name: "/dev/stdout",
}

var _stderr File = {
    fd: sys.STDERR_FILENO,
    name: "/dev/stderr",
}

var stdin *File = &_stdin

var stdout *File = &_stdout

var stderr *File = &_stderr

fun PathError_check(path *const char, error **runtime.Error) {
    var err *runtime.Error = NULL
    runtime.Error_check(&err)
    if err {
        var msg *char = err.error
        err.error = C.sprintf("PathError: %s: %s", path, msg)
        sys.free(msg)
        runtime.Error_move(err, error)
    }
}

fun newFile(fd uintptr, name *const char) *File {
    var file File = {
        name: sys.strdup(name),
        fd: fd,
    }
    return &&file
}

fun openFile(filename *const char, mode int, perm int, error **runtime.Error) *File {
    runtime.clearError()
    var fd int = sys.open(filename, mode, perm)
    if fd == -1 {
        PathError_check(filename, error)
        return NULL
    }
    return newFile(fd, filename)
}

fun open(filename *const char, error **runtime.Error) *File {
    return openFile(filename, O_RDONLY, 0, error)
}

fun create(filename *const char, error **runtime.Error) *File {
    return openFile(filename, O_CREAT | O_TRUNC | O_RDWR, 0644, error)
}

fun read(file *File, b *char, n int, error **runtime.Error) int {
    runtime.clearError()
    n = sys.read(file.fd, b, n)
    PathError_check(file.name, error)
    return n
}

fun write(file *File, b *const char, error **runtime.Error) int {
    runtime.clearError()
    var n int = sys.write(file.fd, b, sys.strlen(b))
    PathError_check(file.name, error)
    return n
}

fun close(file *File, error **runtime.Error) {
    runtime.clearError()
    if file.is_dir {
        sys.closedir(typ *void(file.fd))
    } else {
        sys.close(file.fd)
    }
    PathError_check(file.name, error)
}

fun stat(name *const char, error **runtime.Error) *FileInfo {
    var st sys.Stat = {}
    runtime.clearError()
    if sys.stat(name, &st) != 0 {
        PathError_check(name, error)
        return NULL
    }
    var info FileInfo = {
        _name: sys.strdup(name),
        _sys: &&st,
    }
    return &&info
}

fun FileInfo_free(info *FileInfo) {
    if info {
        sys.free(info._name)
        sys.free(info._sys)
        sys.free(info)
    }
}

fun openDir(name *const char, error **runtime.Error) *File {
    var dp *void = sys.opendir(name)
    if dp == NULL {
        PathError_check(name, error)
        return NULL
    }
    var file *File = newFile(typ uintptr(dp), name)
    file.is_dir = true
    return file
}

fun readdirnames(file *File, error **runtime.Error) [array]*char {
    var arr [array]*char = makearray(*char)
    var dp sys.Dir = typ sys.Dir(file.fd)
    for ;; {
        var dirent sys.Dirent = sys.readdir(dp)
        if dirent == NULL {
            break
        }
        var name *const char = sys.Dirent_name(dirent)
        if name[0] == '.' {
            continue
        }
        append(arr, sys.strdup(name))
    }
    return arr
}

fun readdir(file *File, error **runtime.Error) [array]*FileInfo {
    var err *runtime.Error = NULL
    var names [array]*char = readdirnames(file, &err)
    if err != NULL {
        close(file, NULL)
        runtime.Error_move(err, error)
        return names
    }
    var arr [array]*char = makearray(*char)
    for var i int = 0; i < len(names); i++ {
        var path *char = paths.join2(file.name, names[i])
        sys.free(names[i])
        var info *FileInfo = stat(path, &err)
        if err != NULL {
            close(file, NULL)
            runtime.Error_move(err, error)
            return names
        }
        append(arr, info)
    }
    runtime.Slice_unmake(&names)
    return arr
}

fun FileInfo_name(info *FileInfo) *char {
    return info._name
}

fun FileInfo_size(info *FileInfo) u64 {
    var st *sys.Stat = typ *sys.Stat(FileInfo_sys(info))
    return st.size
}

fun FileInfo_mode(info *FileInfo) FileMode {
    var st *sys.Stat = typ *sys.Stat(FileInfo_sys(info))
    return st.mode
}

fun FileInfo_modTime(info *FileInfo) Time {
    var st *sys.Stat = typ *sys.Stat(FileInfo_sys(info))
    return st.mtime
}

fun FileInfo_isDir(info *FileInfo) bool {
    var st *sys.Stat = typ *sys.Stat(FileInfo_sys(info))
    return ((st.mode & 0170000) == 0040000)
}

fun FileInfo_sys(info *FileInfo) *void {
    return info._sys
}

fun tempDir() *const char {
    var tmpdir *char = sys.getenv("TMPDIR")
    if tmpdir {
        return tmpdir
    }
    return "/tmp"
}

fun mkdir(path *const char, mode u32, error **runtime.Error) {
    runtime.clearError()
    sys.mkdir(path, mode)
    PathError_check(path, error)
}

fun mkdirAll(path *const char, mode u32, error **runtime.Error) {
    var dir *char = paths.dir(path)
    if !sys.streq(dir, ".") {
        mkdirAll(dir, mode, error)
    }
    sys.free(dir)
    var err *runtime.Error = NULL
    mkdir(path, mode, &err)
    switch sys.errno() {
    case 0, sys.EEXIST:
        break
    default:
        runtime.Error_move(err, error)
        break
    }
}

fun exec(argv []const *char, error **runtime.Error) int {
    var status int = -1
    var pid sys.Pid = sys.fork()
    switch pid {
    case -1:
        runtime.Error_check(error)
        return -1
    case 0:
        sys.execve(argv[0], argv, sys.environ())
        runtime.Error_check(error)
        return -1
    default:
        sys.waitpid(pid, &status, 0)
        return status
    }
}
