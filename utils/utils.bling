package utils

import "sys"

typ Error struct {
    error *char
}

typ Slice struct {
    size int
    len int
    cap int
    array *void
}

typ Map struct {
    _valSize int
    _len int
    _pairs Slice
}

typ MapStats struct {
    hits int
    misses int
    lookups int
    iters int
}

typ MapIter struct {
    _map *const Map
    _idx int
}

fun NewError(msg *const char) *Error {
    var err Error = {
        error: strdup(msg),
    }
    return &&err
}

fun Error_move(src *Error, dst **Error) {
    if dst != NULL {
        *dst = src
    } else {
        panic(sys.sprintf("Unhandled error: %s", src.error))
    }
}

fun Error_check(e **Error) {
    if sys.errno() {
        var err *Error = NewError(sys.errnoString())
        Error_move(err, e)
    }
}

fun clearError() {
    sys.errnoReset()
}

fun Error_free(e *Error) {
    free(e.error)
    free(e)
}

fun Slice_init(size int) Slice {
    var s Slice = {
        size: size,
        len: 0,
        cap: 0,
        array: NULL,
    }
    return s
}

fun Slice_deinit(s *Slice) {
    free(s.array)
}

fun Slice_len(s *const Slice) int {
    return s.len
}

fun Slice_cap(s *const Slice) int {
    return s.cap
}

fun Slice_ref(s *const Slice, i int) *void {
    return &(<*char> s.array)[i * s.size]
}

fun Slice_get(s *const Slice, i int, dst *void) {
    if i >= s.len {
        panic(sys.sprintf("out of range: index=%d, len=%d", i, s.len))
    }
    if s.size == 1 {
        *<*char> dst = (<*char> s.array)[i]
    } else {
        sys.memcpy(dst, Slice_ref(s, i), s.size)
    }
}

fun Slice_set_cap(s *Slice, cap int) {
    s.cap = cap
    s.array = sys.realloc(s.array, s.cap * s.size)
}

fun _set_len(s *Slice, len int) {
    var grow bool = false
    var cap int = s.cap
    if cap == 0 {
        cap = 1
        grow = true
    }
    while cap < len {
        cap *= 2
        grow = true
    }
    if s.array == NULL || grow {
        Slice_set_cap(s, cap)
    }
    s.len = len
}

fun Slice_setLen(s *Slice, len int) {
    var old int = s.len
    _set_len(s, len)
    var diff int = len - old
    if diff > 0 {
        sys.memset(Slice_ref(s, old), 0, diff * s.size)
    }
}

fun Slice_set(s *Slice, i int, x *const void) {
    if s.size == 1 {
        (<*char> s.array)[i] = *<*char> x
    } else {
        sys.memcpy(Slice_ref(s, i), x, s.size)
    }
}

fun Slice_append(s *Slice, x *const void) {
    _set_len(s, s.len + 1)
    Slice_set(s, s.len - 1, x)
}

fun Slice_to_nil_array(s Slice) *void {
    var nil *void = NULL
    Slice_append(&s, &nil)
    return s.array
}

var MAP_LOAD_FACTOR const float = 0.65

var DEFAULT_CAP const int = 8

var stats MapStats = {}

fun djb2(s *const char) uintptr_t {
    var hash uintptr_t = 5381
    var ch int = *s
    while ch {
        hash = ((hash << 5) + hash) + ch
        s++
        ch = *s
    }
    return hash
}

fun memdup(src *const void, size size_t) *void {
    return sys.memcpy(malloc(size), src, size)
}

typ MapPair struct {
    key *void
    val *void
}

fun Map_init(valSize int) Map {
    var m Map = {
        _valSize: valSize,
        _len: 0,
        _pairs: Slice_init(sizeof(MapPair)),
    }
    Slice_setLen(&m._pairs, DEFAULT_CAP)
    return m
}

fun Map_deinit(m *Map) {
    Slice_deinit(&m._pairs)
}

fun Map_len(m *const Map) int {
    return m._len
}

fun Map_cap(m *const Map) int {
    return Slice_len(&m._pairs)
}

fun pair_ref(m *const Map, key *const void) *MapPair {
    var hash uintptr_t = djb2(key) % Map_cap(m)
    stats.lookups++
    for var i int = 0; i < Slice_len(&m._pairs); i++ {
        stats.iters++
        var idx int = (hash + i) % Map_cap(m)
        var p *MapPair = <*MapPair> Slice_ref(&m._pairs, idx)
        if !p.key || streq(key, p.key) {
            if !i {
                stats.hits++
            } else {
                stats.misses++
            }
            return p
        }
    }
    return NULL
}

fun set_unsafe(m *Map, key *const char, val *const void) {
    var p *MapPair = pair_ref(m, key)
    if p.key == NULL {
        p.key = strdup(key)
        p.val = memdup(val, m._valSize)
        m._len++
    } else {
        sys.memcpy(p.val, val, m._valSize)
    }
}

fun Map_hasKey(m *Map, key *const char) bool {
    var p *MapPair = pair_ref(m, key)
    return p.key != NULL
}

fun Map_get(m *const Map, key *const char, val *void) int {
    var p *MapPair = pair_ref(m, key)
    if p.val {
        sys.memcpy(val, p.val, m._valSize)
        return 1
    }
    return 0
}

fun Map_set(m *Map, key *const char, val *const void) {
    set_unsafe(m, key, val)
    var load_factor float = <float> Map_len(m) / Map_cap(m)
    if load_factor >= MAP_LOAD_FACTOR {
        var newCap int = Map_cap(m) * 2
        var pairs Slice = m._pairs
        m._pairs = Slice_init(m._pairs.size)
        Slice_setLen(&m._pairs, newCap)
        m._len = 0
        for var i int = 0; i < Slice_len(&pairs); i++ {
            var p *MapPair = <*MapPair> Slice_ref(&pairs, i)
            if p.key {
                set_unsafe(m, p.key, p.val)
            }
        }
        Slice_deinit(&pairs)
    }
}

fun Map_isInitialized(m *Map) bool {
    return m._valSize > 0
}

fun NewMapIter(m *const Map) MapIter {
    var iter MapIter = {
        _map: m,
    }
    return iter
}

fun MapIter_next(m *MapIter, key **char, val *void) int {
    while m._idx < Slice_len(&m._map._pairs) {
        var p *MapPair = <*MapPair> Slice_ref(&m._map._pairs, m._idx)
        m._idx++
        if p.key {
            if key {
                *<**void> key = p.key
            }
            if val {
                sys.memcpy(val, p.val, m._map._valSize)
            }
            return 1
        }
    }
    return 0
}
