package utils

import "sys"

typ Error struct {
    error *char
}

typ Slice struct {
    size int
    len int
    cap int
    _array *void
}

typ Map struct {
    _valSize int
    _len int
    _pairs Slice
}

typ MapStats struct {
    hits int
    misses int
    lookups int
    iters int
}

typ MapIter struct {
    _map *const Map
    _idx int
}

fun NewError(msg *const char) *Error {
    var err Error = {
        error: sys.strdup(msg),
    }
    return &&err
}

fun Error_move(src *Error, dst **Error) {
    if dst != NULL {
        *dst = src
    } else {
        panic(sys.sprintf("Unhandled error: %s", src.error))
    }
}

fun Error_check(e **Error) {
    if sys.errno() {
        var err *Error = NewError(sys.errnoString())
        Error_move(err, e)
    }
}

fun clearError() {
    sys.errnoReset()
}

fun Error_free(e *Error) {
    sys.free(e.error)
    sys.free(e)
}

fun Slice_make(size int) Slice {
    var s Slice = {
        size: size,
        len: 0,
        cap: 0,
        _array: NULL,
    }
    return s
}

fun Slice_unmake(s *Slice) {
    sys.free(s._array)
}

fun Slice_len(s *const Slice) int {
    return s.len
}

fun Slice_cap(s *const Slice) int {
    return s.cap
}

fun Slice_get(s *const Slice, i int, dst *void) *void {
    if i >= s.len {
        panic(sys.sprintf("out of range: index=%d, len=%d", i, s.len))
    }
    var ref *char = &(typ *char(s._array))[i * s.size]
    if dst {
        if s.size == 1 {
            *typ *char(dst) = *ref
        } else {
            sys.memcpy(dst, ref, s.size)
        }
    }
    return ref
}

fun _setCap(s *Slice, cap int) {
    s.cap = cap
    s._array = sys.realloc(s._array, s.cap * s.size)
}

fun _setLen(s *Slice, len int) {
    var grow bool = false
    var cap int = s.cap
    if cap == 0 {
        cap = 1
        grow = true
    }
    while cap < len {
        cap *= 2
        grow = true
    }
    if s._array == NULL || grow {
        _setCap(s, cap)
    }
    s.len = len
}

fun Slice_setLen(s *Slice, len int) {
    var old int = s.len
    _setLen(s, len)
    var diff int = len - old
    if diff > 0 {
        sys.memset(Slice_get(s, old, NULL), 0, diff * s.size)
    }
}

fun Slice_set(s *Slice, i int, x *const void) {
    if s.size == 1 {
        (typ *char(s._array))[i] = *typ *char(x)
    } else {
        sys.memcpy(Slice_get(s, i, NULL), x, s.size)
    }
}

fun Slice_append(s *Slice, x *const void) {
    _setLen(s, s.len + 1)
    Slice_set(s, s.len - 1, x)
}

fun nilArray(s *Slice) *void {
    var nil *void = NULL
    Slice_append(s, &nil)
    return s._array
}

var MAP_LOAD_FACTOR const float = 0.65

var DEFAULT_CAP const int = 8

var stats MapStats = {}

fun djb2(s *const char) uintptr_t {
    var hash uintptr_t = 5381
    var ch int = *s
    while ch {
        hash = ((hash << 5) + hash) + ch
        s++
        ch = *s
    }
    return hash
}

fun memdup(src *const void, size size_t) *void {
    return sys.memcpy(sys.malloc(size), src, size)
}

typ MapPair struct {
    key *void
    val *void
}

fun Map_make(valSize int) Map {
    var m Map = {
        _valSize: valSize,
        _len: 0,
        _pairs: Slice_make(sizeof(MapPair)),
    }
    Slice_setLen(&m._pairs, DEFAULT_CAP)
    return m
}

fun Map_unmake(m *Map) {
    Slice_unmake(&m._pairs)
}

fun Map_len(m *const Map) int {
    return m._len
}

fun Map_cap(m *const Map) int {
    return Slice_len(&m._pairs)
}

fun pair_ref(m *const Map, key *const void) *MapPair {
    var hash uintptr_t = djb2(key) % Map_cap(m)
    stats.lookups++
    for var i int = 0; i < Slice_len(&m._pairs); i++ {
        stats.iters++
        var idx int = (hash + i) % Map_cap(m)
        var p *MapPair = Slice_get(&m._pairs, idx, NULL)
        if !p.key || sys.streq(key, p.key) {
            if !i {
                stats.hits++
            } else {
                stats.misses++
            }
            return p
        }
    }
    return NULL
}

fun set_unsafe(m *Map, key *const char, val *const void) {
    var p *MapPair = pair_ref(m, key)
    if p.key == NULL {
        p.key = sys.strdup(key)
        p.val = memdup(val, m._valSize)
        m._len++
    } else {
        sys.memcpy(p.val, val, m._valSize)
    }
}

fun Map_get(m *const Map, key *const char, val *void) bool {
    var p *MapPair = pair_ref(m, key)
    if p.val {
        if val {
            sys.memcpy(val, p.val, m._valSize)
        }
        return true
    }
    return false
}

fun Map_set(m *Map, key *const char, val *const void) {
    set_unsafe(m, key, val)
    var load_factor float = typ float(Map_len(m)) / Map_cap(m)
    if load_factor >= MAP_LOAD_FACTOR {
        var newCap int = Map_cap(m) * 2
        var pairs Slice = m._pairs
        m._pairs = Slice_make(m._pairs.size)
        Slice_setLen(&m._pairs, newCap)
        m._len = 0
        for var i int = 0; i < Slice_len(&pairs); i++ {
            var p *MapPair = Slice_get(&pairs, i, NULL)
            if p.key {
                set_unsafe(m, p.key, p.val)
            }
        }
        Slice_unmake(&pairs)
    }
}

fun NewMapIter(m *const Map) MapIter {
    var iter MapIter = {
        _map: m,
    }
    return iter
}

fun MapIter_next(m *MapIter, key **char, val *void) int {
    while m._idx < Slice_len(&m._map._pairs) {
        var p *MapPair = typ *MapPair(Slice_get(&m._map._pairs, m._idx, NULL))
        m._idx++
        if p.key {
            if key {
                *typ **void(key) = p.key
            }
            if val {
                sys.memcpy(val, p.val, m._map._valSize)
            }
            return 1
        }
    }
    return 0
}
