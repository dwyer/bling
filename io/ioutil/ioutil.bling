package ioutil

import "bytes"
import "os"
import "runtime"

fun readAll(file *os.File, error **runtime.Error) []char {
    var bufsiz const int = 1024
    var err *runtime.Error = nil
    var b = bytes.Buffer{}
    var buf = runtime.makebuf(1024)
    for ;; {
        var n = file.read(buf, &err)
        if err != nil {
            goto end
        }
        if n < bufsiz {
            runtime.Array_setLen(typ *runtime.Slice(&buf), 1, n)
        }
        b.write(buf, nil)
        if n < bufsiz {
            break
        }
    }
end:
    if err != nil {
        runtime.Error_move(err, error)
    }
    return b
}

fun readDir(name runtime.charstr, error **runtime.Error) []*os.FileInfo {
    var info = []*os.FileInfo{}
    var err *runtime.Error = nil
    var file = os.openDir(name, &err)
    if err != nil {
        goto end
    }
    info = os.readdir(file, &err)
    if err != nil {
        file.close(nil)
        goto end
    }
    file.close(&err)
end:
    if err != nil {
        runtime.Error_move(err, error)
    }
    return info
}

fun readFile(name runtime.charstr, error **runtime.Error) []char {
    var ret = []char{}
    var err *runtime.Error = nil
    var file = os.open(name, &err)
    if err != nil {
        goto end
    }
    ret = readAll(file, &err)
    if err != nil {
        file.close(nil)
        goto end
    }
    file.close(&err)
end:
    if err != nil {
        runtime.Error_move(err, error)
    }
    return ret
}

fun writeFile(filename runtime.charstr, data []char, perm int, error **runtime.Error) {
    var err *runtime.Error = nil
    var file = os.create(filename, &err)
    if err != nil {
        goto end
    }
    file.write(data, &err)
    if err != nil {
        file.close(nil)
        goto end
    }
    file.close(nil)
end:
    if err != nil {
        runtime.Error_move(err, error)
    }
}
