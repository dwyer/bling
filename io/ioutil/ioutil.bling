package ioutil

import "bytes"
import "os"
import "runtime"

fun readAll(file *os.File, error **runtime.Error) *char {
    var bufsiz const int = 1024
    var ret *char = nil
    var err *runtime.Error = nil
    var b = bytes.Buffer{}
    for ;; {
        var buf [bufsiz]char
        var n = os.read(file, buf, bufsiz, &err)
        if err != nil {
            goto end
        }
        bytes.Buffer_write(&b, buf, n, nil)
        if n < bufsiz {
            break
        }
    }
    ret = bytes.Buffer_string(&b)
end:
    if err != nil {
        runtime.Error_move(err, error)
    }
    return ret
}

fun readDir(name *const char, error **runtime.Error) [array]*os.FileInfo {
    var info = makearray(*os.FileInfo)
    var err *runtime.Error = nil
    var file = os.openDir(name, &err)
    if err != nil {
        goto end
    }
    info = os.readdir(file, &err)
    if err != nil {
        os.close(file, nil)
        goto end
    }
    os.close(file, &err)
end:
    if err != nil {
        runtime.Error_move(err, error)
    }
    return info
}

fun readFile(name *const char, error **runtime.Error) *char {
    var ret *char = nil
    var err *runtime.Error = nil
    var file = os.open(name, &err)
    if err != nil {
        goto end
    }
    ret = readAll(file, &err)
    if err != nil {
        os.close(file, nil)
        goto end
    }
    os.close(file, &err)
end:
    if err != nil {
        runtime.Error_move(err, error)
    }
    return ret
}

fun writeFile(filename *const char, data *const char, perm int, error **runtime.Error) {
    var err *runtime.Error = nil
    var file = os.create(filename, &err)
    if err != nil {
        goto end
    }
    os.write(file, data, &err)
    if err != nil {
        os.close(file, nil)
        goto end
    }
    os.close(file, nil)
end:
    if err != nil {
        runtime.Error_move(err, error)
    }
}
