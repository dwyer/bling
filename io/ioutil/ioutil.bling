package ioutil

import "bytes"
import "os"
import "runtime"

fun readAll(file *os.File, error **runtime.Error) runtime.charptr {
    var bufsiz const int = 1024
    var ret runtime.charptr = nil
    var err *runtime.Error = nil
    var b = bytes.Buffer{}
    for ;; {
        var buf [bufsiz]char
        var n = os.read(file, buf, bufsiz, &err)
        if err != nil {
            goto end
        }
        b.write(buf, n, nil)
        if n < bufsiz {
            break
        }
    }
    ret = b.toString()
end:
    if err != nil {
        runtime.Error_move(err, error)
    }
    return ret
}

fun readDir(name runtime.charstr, error **runtime.Error) []*os.FileInfo {
    var info = makearray(*os.FileInfo)
    var err *runtime.Error = nil
    var file = os.openDir(name, &err)
    if err != nil {
        goto end
    }
    info = os.readdir(file, &err)
    if err != nil {
        os.close(file, nil)
        goto end
    }
    os.close(file, &err)
end:
    if err != nil {
        runtime.Error_move(err, error)
    }
    return info
}

fun readFile(name runtime.charstr, error **runtime.Error) runtime.charptr {
    var ret runtime.charptr = nil
    var err *runtime.Error = nil
    var file = os.open(name, &err)
    if err != nil {
        goto end
    }
    ret = readAll(file, &err)
    if err != nil {
        os.close(file, nil)
        goto end
    }
    os.close(file, &err)
end:
    if err != nil {
        runtime.Error_move(err, error)
    }
    return ret
}

fun writeFile(filename runtime.charstr, data runtime.charstr, perm int, error **runtime.Error) {
    var err *runtime.Error = nil
    var file = os.create(filename, &err)
    if err != nil {
        goto end
    }
    os.write(file, data, &err)
    if err != nil {
        os.close(file, nil)
        goto end
    }
    os.close(file, nil)
end:
    if err != nil {
        runtime.Error_move(err, error)
    }
}
