package cparser

import "C"
import "bling/ast"
import "bling/parser"
import "bling/scanner"
import "bling/token"
import "io/ioutil"
import "runtime"
import "sys"

fun isType(p *parser.Parser) bool {
    switch p.tok {
    case token.ARRAY, token.CONST, token.ENUM, token.EXTERN, token.MAP, token.SIGNED, token.STATIC, token.STRUCT, token.UNION, token.UNSIGNED:
        return true
    case token.IDENT:
        return runtime.Map_get(&p.typeNames, p.lit, nil)
    default:
        return false
    }
}

fun operand(p *parser.Parser) *ast.Expr {
    switch p.tok {
    case token.GET:
        p.expect(token.GET)
        p.expect(token.LPAREN)
        typeName(p)
        p.expect(token.COMMA)
        var arr = expression(p)
        p.expect(token.COMMA)
        var index = expression(p)
        p.expect(token.RPAREN)
        var y = ast.Expr{
            kind: ast.EXPR_INDEX,
            index: {
                x: arr,
                index: index,
            },
        }
        return &&y
    default:
        return p.parseOperand()
    }
}

fun postfixExpr(p *parser.Parser, x *ast.Expr) *ast.Expr {
    if x == nil {
        x = operand(p)
    }
    for ;; {
        switch p.tok {
        case token.LBRACK:
            p.expect(token.LBRACK)
            var y = ast.Expr{
                kind: ast.EXPR_INDEX,
                index: {
                    x: x,
                    index: expression(p),
                },
            }
            p.expect(token.RBRACK)
            x = &&y
            break
        case token.LPAREN:
            var args = []*ast.Expr{}
            p.expect(token.LPAREN)
            while p.tok != token.RPAREN {
                var x *ast.Expr = nil
                if isType(p) {
                    x = typeName(p)
                } else {
                    x = expression(p)
                }
                append(args, x)
                if !p.accept(token.COMMA) {
                    break
                }
            }
            p.expect(token.RPAREN)
            var call = ast.Expr{
                kind: ast.EXPR_CALL,
                call: {
                    func: x,
                    args: args,
                },
            }
            x = &&call
            break
        case token.ARROW, token.PERIOD:
            var tok = p.tok
            p.next()
            var y = ast.Expr{
                kind: ast.EXPR_SELECTOR,
                selector: {
                    x: x,
                    tok: tok,
                    sel: p.parseIdent(),
                },
            }
            x = &&y
            break
        default:
            goto done
        }
    }
done:
    return x
}

fun unaryExpr(p *parser.Parser) *ast.Expr {
    var pos = p.pos
    switch p.tok {
    case token.ADD, token.AND, token.BITWISE_NOT, token.NOT, token.SUB:
        var op = p.tok
        p.next()
        var x = ast.Expr{
            kind: ast.EXPR_UNARY,
            unary: {
                pos: pos,
                op: op,
                x: castExpr(p),
            },
        }
        if op == token.LAND {
            p.expect(token.RPAREN)
        }
        return &&x
    case token.MUL:
        p.next()
        var x = ast.Expr{
            kind: ast.EXPR_STAR,
            star: {
                pos: pos,
                x: castExpr(p),
            },
        }
        return &&x
    case token.SIZEOF:
        p.next()
        p.expect(token.LPAREN)
        var x *ast.Expr = nil
        if isType(p) {
            x = typeName(p)
            if p.tok == token.MUL {
                declarator(p, &x)
            }
        } else {
            x = unaryExpr(p)
        }
        p.expect(token.RPAREN)
        var y = ast.Expr{
            kind: ast.EXPR_UNARY,
            unary: {
                pos: pos,
                op: token.SIZEOF,
                x: x,
            },
        }
        return &&y
    case token.DEC, token.INC:
        p.error(p.pos, C.sprintf("unary `%s` not supported in subc", p.tok.string()))
        return nil
    default:
        return postfixExpr(p, nil)
    }
}

fun castExpr(p *parser.Parser) *ast.Expr {
    if p.tok == token.LPAREN {
        var pos = p.expect(token.LPAREN)
        if isType(p) {
            var type = typeName(p)
            p.expect(token.RPAREN)
            if p.tok == token.LBRACE {
                var x = initializer(p)
                x.composite.type = type
                return x
            }
            var y = ast.Expr{
                kind: ast.EXPR_CAST,
                cast: {
                    pos: pos,
                    type: type,
                    expr: castExpr(p),
                },
            }
            return &&y
        } else {
            var x = expression(p)
            if x.kind != ast.EXPR_COMPOSITE_LIT {
                var y = ast.Expr{
                    kind: ast.EXPR_PAREN,
                    paren: {
                        pos: pos,
                        x: x,
                    },
                }
                x = &&y
            }
            p.expect(token.RPAREN)
            return postfixExpr(p, x)
        }
    }
    return unaryExpr(p)
}

fun binaryExpr(p *parser.Parser, prec1 int) *ast.Expr {
    var x = castExpr(p)
    for ;; {
        var op = p.tok
        var oprec = op.precedence()
        if oprec < prec1 {
            return x
        }
        p.expect(op)
        var y = binaryExpr(p, oprec + 1)
        var z = ast.Expr{
            kind: ast.EXPR_BINARY,
            binary: {
                x: x,
                op: op,
                y: y,
            },
        }
        x = &&z
    }
}

fun ternaryExpr(p *parser.Parser) *ast.Expr {
    var x = binaryExpr(p, token.lowest_prec + 1)
    if p.accept(token.QUESTION_MARK) {
        var consequence *ast.Expr = nil
        if p.tok != token.COLON {
            consequence = expression(p)
        }
        p.expect(token.COLON)
        var alternative = ternaryExpr(p)
        var y = ast.Expr{
            kind: ast.EXPR_TERNARY,
            ternary: {
                cond: x,
                x: consequence,
                y: alternative,
            },
        }
        x = &&y
    }
    return x
}

fun expression(p *parser.Parser) *ast.Expr {
    return ternaryExpr(p)
}

fun constantExpr(p *parser.Parser) *ast.Expr {
    return ternaryExpr(p)
}

fun structOrUnionSpec(p *parser.Parser) *ast.Expr {
    var keyword = p.tok
    var pos = p.expect(keyword)
    var name *ast.Expr = nil
    if p.tok == token.IDENT {
        name = p.parseIdent()
    }
    var fields = []*ast.Decl{}
    if p.accept(token.LBRACE) {
        for ;; {
            var pos = p.pos
            var type = specifierQualifierList(p)
            var name = declarator(p, &type)
            var f = ast.Decl{
                kind: ast.DECL_FIELD,
                pos: pos,
                field: {
                    type: type,
                    name: name,
                },
            }
            p.expect(token.SEMICOLON)
            var field = &&f
            append(fields, field)
            if p.tok == token.RBRACE {
                break
            }
        }
        p.expect(token.RBRACE)
    }
    var x = ast.Expr{
        kind: ast.TYPE_STRUCT,
        struct_: {
            pos: pos,
            tok: keyword,
            name: name,
            fields: fields,
        },
    }
    return &&x
}

fun enumSpec(p *parser.Parser) *ast.Expr {
    var pos = p.expect(token.ENUM)
    var name *ast.Expr = nil
    if p.tok == token.IDENT {
        name = p.parseIdent()
    }
    var enums = []*ast.Decl{}
    if p.accept(token.LBRACE) {
        for ;; {
            var decl = ast.Decl{
                kind: ast.DECL_VALUE,
                pos: p.pos,
                value: {
                    name: p.parseIdent(),
                    kind: token.VAR,
                },
            }
            if p.accept(token.ASSIGN) {
                decl.value.value = constantExpr(p)
            }
            var enumerator = &&decl
            append(enums, enumerator)
            if !p.accept(token.COMMA) || p.tok == token.RBRACE {
                break
            }
        }
        p.expect(token.RBRACE)
    }
    var x = ast.Expr{
        kind: ast.TYPE_ENUM,
        enum_: {
            pos: pos,
            name: name,
            enums: enums,
        },
    }
    return &&x
}

fun declarator(p *parser.Parser, typePtr **ast.Expr) *ast.Expr {
    if p.tok == token.MUL {
        *typePtr = pointer(p, *typePtr)
    }
    var name *ast.Expr = nil
    var isPtr = false
    switch p.tok {
    case token.IDENT:
        name = p.parseIdent()
        break
    case token.LPAREN:
        p.expect(token.LPAREN)
        isPtr = p.accept(token.MUL)
        if !isPtr || p.tok == token.IDENT {
            name = p.parseIdent()
        }
        p.expect(token.RPAREN)
        break
    default:
        break
    }
    if p.tok == token.LBRACK {
        var pos token.Pos = p.pos
        p.next()
        var len *ast.Expr = nil
        if p.tok != token.RBRACK {
            len = constantExpr(p)
        }
        var type = ast.Expr{
            kind: ast.TYPE_ARRAY,
            array_: {
                pos: pos,
                elt: *typePtr,
                len: len,
            },
        }
        p.expect(token.RBRACK)
        *typePtr = &&type
    } else if p.accept(token.LPAREN) {
        var params = []*ast.Decl{}
        if p.tok != token.RPAREN {
            params = paramTypeList(p)
        }
        var type = ast.Expr{
            kind: ast.TYPE_FUNC,
            func: {
                pos: (*typePtr).pos(),
                result: *typePtr,
                params: params,
            },
        }
        p.expect(token.RPAREN)
        *typePtr = &&type
    }
    if isPtr {
        var type = ast.Expr{
            kind: ast.EXPR_STAR,
            star: {
                x: *typePtr,
            },
        }
        *typePtr = &&type
    }
    return name
}

fun typeQualifier(p *parser.Parser, type *ast.Expr) *ast.Expr {
    if p.accept(token.CONST) {
        type.is_const = true
    }
    return type
}

fun pointer(p *parser.Parser, type *ast.Expr) *ast.Expr {
    while p.tok == token.MUL {
        var x = ast.Expr{
            kind: ast.EXPR_STAR,
            star: {
                pos: p.pos,
                x: type,
            },
        }
        p.next()
        type = &&x
        type = typeQualifier(p, type)
    }
    return type
}

fun paramTypeList(p *parser.Parser) []*ast.Decl {
    var params = []*ast.Decl{}
    while p.tok != token.RPAREN {
        var param = parameterDeclaration(p)
        append(params, param)
        if !p.accept(token.COMMA) {
            break
        }
        if p.tok == token.ELLIPSIS {
            var pos = p.expect(token.ELLIPSIS)
            var type = ast.Expr{
                kind: ast.TYPE_ELLIPSIS,
                ellipsis: {
                    pos: pos,
                },
            }
            var decl = ast.Decl{
                kind: ast.DECL_FIELD,
                pos: pos,
                field: {
                    type: &&type,
                },
            }
            var param = &&decl
            append(params, param)
            break
        }
    }
    return params
}

fun typeName(p *parser.Parser) *ast.Expr {
    var type = specifierQualifierList(p)
    var decl = abstractDeclarator(p, type)
    type = decl.field.type
    delete(decl)
    return type
}

fun abstractDeclarator(p *parser.Parser, type *ast.Expr) *ast.Decl {
    var pos = p.pos
    if p.tok == token.MUL {
        type = pointer(p, type)
    }
    var isPtr = false
    if p.accept(token.LPAREN) {
        p.expect(token.MUL)
        p.expect(token.RPAREN)
        isPtr = true
    }
    for ;; {
        if p.accept(token.LBRACK) {
            var len *ast.Expr = nil
            if p.tok != token.RBRACK {
                len = constantExpr(p)
            }
            var t = ast.Expr{
                kind: ast.TYPE_ARRAY,
                array_: {
                    pos: pos,
                    elt: type,
                    len: len,
                },
            }
            p.expect(token.RBRACK)
            type = &&t
        } else if p.accept(token.LPAREN) {
            var params = []*ast.Decl{}
            if p.tok != token.RPAREN {
                params = paramTypeList(p)
            }
            var t = ast.Expr{
                kind: ast.TYPE_FUNC,
                func: {
                    pos: pos,
                    result: type,
                    params: params,
                },
            }
            p.expect(token.RPAREN)
            type = &&t
        } else {
            break
        }
    }
    if isPtr {
        var tmp = ast.Expr{
            kind: ast.EXPR_STAR,
            star: {
                pos: pos,
                x: type,
            },
        }
        type = &&tmp
    }
    var declarator = ast.Decl{
        kind: ast.DECL_FIELD,
        pos: pos,
        field: {
            type: type,
        },
    }
    return &&declarator
}

fun initializer(p *parser.Parser) *ast.Expr {
    if !p.accept(token.LBRACE) {
        return expression(p)
    }
    var list = []*ast.Expr{}
    while p.tok != token.RBRACE && p.tok != token.EOF {
        var key *ast.Expr = nil
        var isArray = false
        if p.accept(token.PERIOD) {
            key = p.parseIdent()
            p.expect(token.ASSIGN)
        } else if p.accept(token.LBRACK) {
            isArray = true
            key = expression(p)
            p.expect(token.RBRACK)
            p.expect(token.ASSIGN)
        }
        var value = initializer(p)
        if key {
            var x = ast.Expr{
                kind: ast.EXPR_KEY_VALUE,
                key_value: {
                    key: key,
                    value: value,
                    isArray: isArray,
                },
            }
            value = &&x
        }
        append(list, value)
        if !p.accept(token.COMMA) {
            break
        }
    }
    var expr = ast.Expr{
        kind: ast.EXPR_COMPOSITE_LIT,
        composite: {
            pos: p.expect(token.RBRACE),
            list: list,
        },
    }
    return &&expr
}

fun simpleStmt(p *parser.Parser, labelOk bool) *ast.Stmt {
    var x = expression(p)
    var op = p.tok
    switch op {
    case token.ADD_ASSIGN, token.ASSIGN, token.DIV_ASSIGN, token.MOD_ASSIGN, token.MUL_ASSIGN, token.SHL_ASSIGN, token.SHR_ASSIGN, token.SUB_ASSIGN, token.XOR_ASSIGN:
        p.next()
        var y = expression(p)
        var stmt = ast.Stmt{
            kind: ast.STMT_ASSIGN,
            assign: {
                x: x,
                op: op,
                y: y,
            },
        }
        return &&stmt
    case token.INC, token.DEC:
        p.next()
        var stmt = ast.Stmt{
            kind: ast.STMT_POSTFIX,
            postfix: {
                x: x,
                op: op,
            },
        }
        return &&stmt
    default:
        break
    }
    if labelOk && x.kind == ast.EXPR_IDENT {
        if p.accept(token.COLON) {
            var stmt = ast.Stmt{
                kind: ast.STMT_LABEL,
                label: {
                    label: x,
                    stmt: statement(p),
                },
            }
            return &&stmt
        }
    }
    var stmt = ast.Stmt{
        kind: ast.STMT_EXPR,
        expr: {
            x: x,
        },
    }
    return &&stmt
}

fun statement(p *parser.Parser) *ast.Stmt {
    if isType(p) {
        var stmt = ast.Stmt{
            kind: ast.STMT_DECL,
            decl: {
                decl: declaration(p, false),
            },
        }
        return &&stmt
    }
    var pos = p.pos
    if p.accept(token.FOR) {
        p.expect(token.LPAREN)
        var init *ast.Stmt = nil
        if !p.accept(token.SEMICOLON) {
            init = statement(p)
        }
        var cond *ast.Expr = nil
        if p.tok != token.SEMICOLON {
            cond = expression(p)
        }
        p.expect(token.SEMICOLON)
        var post *ast.Stmt = nil
        if p.tok != token.RPAREN {
            post = simpleStmt(p, false)
        }
        p.expect(token.RPAREN)
        var body = compoundStmt(p, true)
        var stmt = ast.Stmt{
            kind: ast.STMT_ITER,
            iter: {
                pos: pos,
                kind: token.FOR,
                init: init,
                cond: cond,
                post: post,
                body: body,
            },
        }
        return &&stmt
    }
    if p.accept(token.IF) {
        p.expect(token.LPAREN)
        var cond = expression(p)
        p.expect(token.RPAREN)
        var body = compoundStmt(p, true)
        var else_ *ast.Stmt = nil
        if p.accept(token.ELSE) {
            if p.tok == token.IF {
                else_ = statement(p)
            } else {
                else_ = compoundStmt(p, true)
            }
        }
        var stmt = ast.Stmt{
            kind: ast.STMT_IF,
            if_: {
                pos: pos,
                cond: cond,
                body: body,
                else_: else_,
            },
        }
        return &&stmt
    }
    if p.accept(token.RETURN) {
        var x *ast.Expr = nil
        if p.tok != token.SEMICOLON {
            x = expression(p)
        }
        p.expect(token.SEMICOLON)
        var stmt = ast.Stmt{
            kind: ast.STMT_RETURN,
            return_: {
                pos: pos,
                x: x,
            },
        }
        return &&stmt
    }
    if p.accept(token.SWITCH) {
        p.expect(token.LPAREN)
        var tag = expression(p)
        p.expect(token.RPAREN)
        p.expect(token.LBRACE)
        var clauses = []*ast.Stmt{}
        while p.tok == token.CASE || p.tok == token.DEFAULT {
            var exprs = []*ast.Expr{}
            while p.accept(token.CASE) {
                var expr = constantExpr(p)
                p.expect(token.COLON)
                append(exprs, expr)
            }
            if len(exprs) == 0 {
                p.expect(token.DEFAULT)
                p.expect(token.COLON)
            }
            var stmts = []*ast.Stmt{}
            for var loop = true; loop; {
                switch p.tok {
                case token.CASE, token.DEFAULT, token.RBRACE:
                    loop = false
                    break
                default:
                    break
                }
                if loop {
                    append(stmts, statement(p))
                }
            }
            var stmt = ast.Stmt{
                kind: ast.STMT_CASE,
                case_: {
                    pos: pos,
                    exprs: exprs,
                    stmts: stmts,
                },
            }
            var clause = &&stmt
            append(clauses, clause)
        }
        p.expect(token.RBRACE)
        var stmt = ast.Stmt{
            kind: ast.STMT_SWITCH,
            switch_: {
                pos: pos,
                tag: tag,
                stmts: clauses,
            },
        }
        return &&stmt
    }
    if p.accept(token.WHILE) {
        p.expect(token.LPAREN)
        var cond = expression(p)
        p.expect(token.RPAREN)
        var body = compoundStmt(p, true)
        var stmt = ast.Stmt{
            kind: ast.STMT_ITER,
            iter: {
                pos: pos,
                kind: token.WHILE,
                cond: cond,
                body: body,
            },
        }
        return &&stmt
    }
    switch p.tok {
    case token.BREAK, token.CONTINUE, token.FALLTHROUGH, token.GOTO:
        var keyword = p.tok
        p.next()
        var label *ast.Expr = nil
        if keyword == token.GOTO {
            label = p.parseIdent()
        }
        p.expect(token.SEMICOLON)
        var stmt = ast.Stmt{
            kind: ast.STMT_JUMP,
            jump: {
                pos: pos,
                keyword: keyword,
                label: label,
            },
        }
        return &&stmt
    case token.LBRACE:
        return compoundStmt(p, false)
    default:
        break
    }
    if p.accept(token.SEMICOLON) {
        var stmt = ast.Stmt{
            kind: ast.STMT_EMPTY,
            empty: {
                pos: pos,
            },
        }
        return &&stmt
    }
    var stmt = simpleStmt(p, true)
    if stmt.kind != ast.STMT_LABEL {
        p.expect(token.SEMICOLON)
    }
    return stmt
}

fun compoundStmt(p *parser.Parser, allow_single bool) *ast.Stmt {
    var stmts = []*ast.Stmt{}
    var pos token.Pos = 0
    if allow_single && p.tok != token.LBRACE {
        var stmt = statement(p)
        assert(stmt.kind != ast.STMT_DECL)
        append(stmts, stmt)
        pos = stmt.pos()
    } else {
        pos = p.expect(token.LBRACE)
        while p.tok != token.RBRACE {
            append(stmts, statement(p))
        }
        p.expect(token.RBRACE)
    }
    var stmt = ast.Stmt{
        kind: ast.STMT_BLOCK,
        block: {
            pos: pos,
            stmts: stmts,
        },
    }
    return &&stmt
}

fun parameterDeclaration(p *parser.Parser) *ast.Decl {
    var decl = ast.Decl{
        kind: ast.DECL_FIELD,
        pos: p.pos,
    }
    decl.field.type = declarationSpecifiers(p, false)
    decl.field.name = declarator(p, &decl.field.type)
    return &&decl
}

fun arraySpecifier(p *parser.Parser) *ast.Expr {
    var pos = p.pos
    p.expect(token.ARRAY)
    p.expect(token.LPAREN)
    var elt = typeName(p)
    p.expect(token.RPAREN)
    var tmp = ast.Expr{
        kind: ast.TYPE_ARRAY,
        array_: {
            pos: pos,
            elt: elt,
            dynamic: true,
        },
    }
    return &&tmp
}

fun mapSpecifier(p *parser.Parser) *ast.Expr {
    var pos = p.pos
    p.expect(token.MAP)
    p.expect(token.LPAREN)
    var val = typeName(p)
    p.expect(token.RPAREN)
    var tmp = ast.Expr{
        kind: ast.TYPE_MAP,
        map_: {
            pos: pos,
            val: val,
        },
    }
    return &&tmp
}

fun typeSpecifier(p *parser.Parser) *ast.Expr {
    var x *ast.Expr = nil
    switch p.tok {
    case token.SIGNED, token.UNSIGNED:
        p.error(p.pos, C.sprintf("`%s` is not supported in subc", p.tok.string()))
        break
    case token.STRUCT, token.UNION:
        x = structOrUnionSpec(p)
        break
    case token.ENUM:
        x = enumSpec(p)
        break
    case token.ARRAY:
        x = arraySpecifier(p)
        break
    case token.MAP:
        x = mapSpecifier(p)
        break
    default:
        if isType(p) {
            x = p.parseIdent()
        } else {
            p.errorExpected(p.pos, "type")
        }
        break
    }
    return x
}

fun declarationSpecifiers(p *parser.Parser, isTop bool) *ast.Expr {
    if isTop {
        switch p.tok {
        case token.EXTERN, token.STATIC:
            p.next()
            break
        default:
            break
        }
    }
    var isConst = p.accept(token.CONST)
    var type = typeSpecifier(p)
    if isConst {
        type.is_const = isConst
    }
    return type
}

fun specifierQualifierList(p *parser.Parser) *ast.Expr {
    return declarationSpecifiers(p, false)
}

fun declaration(p *parser.Parser, isExternal bool) *ast.Decl {
    if p.tok == token.HASH {
        return p.parsePragma()
    }
    var pos token.Pos = p.pos
    if p.tok == token.TYPEDEF {
        var keyword = p.tok
        p.expect(keyword)
        var type = declarationSpecifiers(p, true)
        var name = declarator(p, &type)
        p.expect(token.SEMICOLON)
        var decl = ast.Decl{
            kind: ast.DECL_TYPE,
            pos: pos,
            type: {
                name: name,
                type: type,
            },
        }
        var d = &&decl
        var obj = ast.newObject(ast.ObjKind_TYP, name.ident.name)
        runtime.Map_set(&p.typeNames, name.ident.name, &type)
        return d
    }
    var type = declarationSpecifiers(p, true)
    var name = declarator(p, &type)
    var value *ast.Expr = nil
    if type.kind == ast.TYPE_FUNC {
        var decl = ast.Decl{
            kind: ast.DECL_FUNC,
            pos: pos,
            func: {
                type: type,
                name: name,
            },
        }
        if isExternal && p.tok == token.LBRACE {
            decl.func.body = compoundStmt(p, false)
        } else {
            p.expect(token.SEMICOLON)
        }
        return &&decl
    }
    if p.accept(token.ASSIGN) {
        value = initializer(p)
    }
    p.expect(token.SEMICOLON)
    if name != nil {
        var decl = ast.Decl{
            kind: ast.DECL_VALUE,
            pos: pos,
            value: {
                type: type,
                name: name,
                value: value,
                kind: token.VAR,
            },
        }
        return &&decl
    } else {
        switch type.kind {
        case ast.TYPE_STRUCT:
            name = type.struct_.name
            break
        default:
            panic(C.sprintf("bad kind: %d", type.kind))
            break
        }
        var decl = ast.Decl{
            kind: ast.DECL_TYPE,
            pos: pos,
            type: {
                type: type,
                name: name,
            },
        }
        return &&decl
    }
}

fun _parseFile(p *parser.Parser) *ast.File {
    var decls = []*ast.Decl{}
    var imports = []*ast.Decl{}
    var name *ast.Expr = nil
    while p.tok == token.HASH {
        var lit = p.parsePragma()
        append(decls, lit)
    }
    if p.accept(token.PACKAGE) {
        p.expect(token.LPAREN)
        name = p.parseIdent()
        p.expect(token.RPAREN)
        p.expect(token.SEMICOLON)
    }
    while p.tok == token.IMPORT {
        p.expect(token.IMPORT)
        p.expect(token.LPAREN)
        var path = p.parseBasicLit(token.STRING)
        p.expect(token.RPAREN)
        p.expect(token.SEMICOLON)
        var decl = ast.Decl{
            kind: ast.DECL_IMPORT,
            imp: {
                path: path,
            },
        }
        append(imports, &&decl)
    }
    while p.tok != token.EOF {
        append(decls, declaration(p, true))
    }
    var file = ast.File{
        filename: p.file.name,
        name: name,
        decls: decls,
        imports: imports,
    }
    return &&file
}

fun parseFile(fset *token.FileSet, filename runtime.charstr) *ast.File {
    var src = ioutil.readFile(filename, nil)
    var p = parser.Parser{}
    p.init(fset, filename, src)
    p.cMode = true
    var file = _parseFile(&p)
    runtime.Slice_unmake(&src)
    return file
}
