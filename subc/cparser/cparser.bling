package cparser

import "bling/ast"
import "bling/parser"
import "bling/scanner"
import "bling/token"
import "io/ioutil"
import "runtime"
import "sys"

fun is_type(p *parser.Parser) bool {
    switch p.tok {
    case token.ARRAY, token.CONST, token.ENUM, token.EXTERN, token.MAP, token.SIGNED, token.STATIC, token.STRUCT, token.UNION, token.UNSIGNED:
        return true
    case token.IDENT:
        {
            for var s *ast.Scope = p.topScope; s; s = s.outer {
                var obj *ast.Object = ast.Scope_lookup(s, p.lit)
                if obj && obj.kind == ast.ObjKind_TYP {
                    return true
                }
            }
            return false
        }
    default:
        return false
    }
}

fun operand(p *parser.Parser) *ast.Expr {
    switch p.tok {
    case token.GET:
        {
            parser.expect(p, token.GET)
            parser.expect(p, token.LPAREN)
            type_name(p)
            parser.expect(p, token.COMMA)
            var arr *ast.Expr = expression(p)
            parser.expect(p, token.COMMA)
            var index *ast.Expr = expression(p)
            parser.expect(p, token.RPAREN)
            var y ast.Expr = {
                kind: ast.EXPR_INDEX,
                index: {
                    x: arr,
                    index: index,
                },
            }
            return &&y
        }
    default:
        return parser.parseOperand(p, true)
    }
}

fun postfix_expression(p *parser.Parser, x *ast.Expr) *ast.Expr {
    if x == NULL {
        x = operand(p)
    }
    for ;; {
        switch p.tok {
        case token.LBRACK:
            {
                parser.expect(p, token.LBRACK)
                var y ast.Expr = {
                    kind: ast.EXPR_INDEX,
                    index: {
                        x: x,
                        index: expression(p),
                    },
                }
                parser.expect(p, token.RBRACK)
                x = &&y
            }
            break
        case token.LPAREN:
            {
                var args [array]*ast.Expr = makearray(*ast.Expr)
                parser.expect(p, token.LPAREN)
                while p.tok != token.RPAREN {
                    var x *ast.Expr = NULL
                    if is_type(p) {
                        x = type_name(p)
                    } else {
                        x = expression(p)
                    }
                    append(args, x)
                    if !parser.accept(p, token.COMMA) {
                        break
                    }
                }
                parser.expect(p, token.RPAREN)
                var call ast.Expr = {
                    kind: ast.EXPR_CALL,
                    call: {
                        func: x,
                        args: args,
                    },
                }
                x = &&call
            }
            break
        case token.ARROW, token.PERIOD:
            {
                var tok token.Token = p.tok
                parser.next(p)
                var y ast.Expr = {
                    kind: ast.EXPR_SELECTOR,
                    selector: {
                        x: x,
                        tok: tok,
                        sel: parser.parseIdent(p),
                    },
                }
                x = &&y
            }
            break
        default:
            goto done
        }
    }
done:
    return x
}

fun unary_expression(p *parser.Parser) *ast.Expr {
    var pos token.Pos = p.pos
    switch p.tok {
    case token.ADD, token.AND, token.ESC, token.BITWISE_NOT, token.NOT, token.SUB:
        {
            var op token.Token = p.tok
            parser.next(p)
            if op == token.ESC {
                op = token.LAND
                parser.expect(p, token.LPAREN)
            }
            var x ast.Expr = {
                kind: ast.EXPR_UNARY,
                unary: {
                    pos: pos,
                    op: op,
                    x: cast_expression(p),
                },
            }
            if op == token.LAND {
                parser.expect(p, token.RPAREN)
            }
            return &&x
        }
    case token.MUL:
        {
            parser.next(p)
            var x ast.Expr = {
                kind: ast.EXPR_STAR,
                star: {
                    pos: pos,
                    x: cast_expression(p),
                },
            }
            return &&x
        }
    case token.SIZEOF:
        {
            parser.next(p)
            parser.expect(p, token.LPAREN)
            var x *ast.Expr = NULL
            if is_type(p) {
                x = type_name(p)
                if p.tok == token.MUL {
                    declarator(p, &x)
                }
            } else {
                x = unary_expression(p)
            }
            parser.expect(p, token.RPAREN)
            var y ast.Expr = {
                kind: ast.EXPR_SIZEOF,
                sizeof_: {
                    pos: pos,
                    x: x,
                },
            }
            return &&y
        }
    case token.DEC, token.INC:
        parser.error(p, p.pos, sys.sprintf("unary `%s` not supported in subc", token.string(p.tok)))
        return NULL
    default:
        return postfix_expression(p, NULL)
    }
}

fun cast_expression(p *parser.Parser) *ast.Expr {
    if p.tok == token.LPAREN {
        var pos token.Pos = parser.expect(p, token.LPAREN)
        if is_type(p) {
            var type *ast.Expr = type_name(p)
            parser.expect(p, token.RPAREN)
            var x *ast.Expr
            if p.tok == token.LBRACE {
                x = initializer(p)
                x.composite.type = type
                return x
            }
            var y ast.Expr = {
                kind: ast.EXPR_CAST,
                cast: {
                    pos: pos,
                    type: type,
                    expr: cast_expression(p),
                },
            }
            return &&y
        } else {
            var x *ast.Expr = expression(p)
            if x.kind != ast.EXPR_COMPOSITE_LIT {
                var y ast.Expr = {
                    kind: ast.EXPR_PAREN,
                    paren: {
                        pos: pos,
                        x: x,
                    },
                }
                x = &&y
            }
            parser.expect(p, token.RPAREN)
            return postfix_expression(p, x)
        }
    }
    return unary_expression(p)
}

fun binary_expression(p *parser.Parser, prec1 int) *ast.Expr {
    var x *ast.Expr = cast_expression(p)
    for ;; {
        var op token.Token = p.tok
        var oprec int = token.precedence(op)
        if oprec < prec1 {
            return x
        }
        parser.expect(p, op)
        var y *ast.Expr = binary_expression(p, oprec + 1)
        var z ast.Expr = {
            kind: ast.EXPR_BINARY,
            binary: {
                x: x,
                op: op,
                y: y,
            },
        }
        x = &&z
    }
}

fun ternary_expression(p *parser.Parser) *ast.Expr {
    var x *ast.Expr = binary_expression(p, token.lowest_prec + 1)
    if parser.accept(p, token.QUESTION_MARK) {
        var consequence *ast.Expr = NULL
        if p.tok != token.COLON {
            consequence = expression(p)
        }
        parser.expect(p, token.COLON)
        var alternative *ast.Expr = ternary_expression(p)
        var y ast.Expr = {
            kind: ast.EXPR_TERNARY,
            ternary: {
                cond: x,
                x: consequence,
                y: alternative,
            },
        }
        x = &&y
    }
    return x
}

fun expression(p *parser.Parser) *ast.Expr {
    return ternary_expression(p)
}

fun constant_expression(p *parser.Parser) *ast.Expr {
    return ternary_expression(p)
}

fun struct_or_union_specifier(p *parser.Parser) *ast.Expr {
    var keyword token.Token = p.tok
    var pos token.Pos = parser.expect(p, keyword)
    var name *ast.Expr = NULL
    if p.tok == token.IDENT {
        name = parser.parseIdent(p)
    }
    var fields [array]*ast.Decl = makearray(*ast.Decl)
    if parser.accept(p, token.LBRACE) {
        for ;; {
            var pos token.Pos = p.pos
            var type *ast.Expr = specifier_qualifier_list(p)
            var name *ast.Expr = declarator(p, &type)
            var f ast.Decl = {
                kind: ast.DECL_FIELD,
                pos: pos,
                field: {
                    type: type,
                    name: name,
                },
            }
            parser.expect(p, token.SEMICOLON)
            var field *ast.Decl = &&f
            append(fields, field)
            if p.tok == token.RBRACE {
                break
            }
        }
        parser.expect(p, token.RBRACE)
    }
    var x ast.Expr = {
        kind: ast.TYPE_STRUCT,
        struct_: {
            pos: pos,
            tok: keyword,
            name: name,
            fields: fields,
        },
    }
    return &&x
}

fun enum_specifier(p *parser.Parser) *ast.Expr {
    var pos token.Pos = parser.expect(p, token.ENUM)
    var name *ast.Expr = NULL
    if p.tok == token.IDENT {
        name = parser.parseIdent(p)
    }
    var enums [array]*ast.Decl = makearray(*ast.Decl)
    if parser.accept(p, token.LBRACE) {
        for ;; {
            var decl ast.Decl = {
                kind: ast.DECL_VALUE,
                pos: p.pos,
                value: {
                    name: parser.parseIdent(p),
                    kind: token.VAR,
                },
            }
            if parser.accept(p, token.ASSIGN) {
                decl.value.value = constant_expression(p)
            }
            var enumerator *ast.Decl = &&decl
            append(enums, enumerator)
            if !parser.accept(p, token.COMMA) || p.tok == token.RBRACE {
                break
            }
        }
        parser.expect(p, token.RBRACE)
    }
    var x ast.Expr = {
        kind: ast.TYPE_ENUM,
        enum_: {
            pos: pos,
            name: name,
            enums: enums,
        },
    }
    return &&x
}

fun declarator(p *parser.Parser, type_ptr **ast.Expr) *ast.Expr {
    if p.tok == token.MUL {
        *type_ptr = pointer(p, *type_ptr)
    }
    var name *ast.Expr = NULL
    var is_ptr bool = false
    switch p.tok {
    case token.IDENT:
        name = parser.parseIdent(p)
        break
    case token.LPAREN:
        parser.expect(p, token.LPAREN)
        is_ptr = parser.accept(p, token.MUL)
        if !is_ptr || p.tok == token.IDENT {
            name = parser.parseIdent(p)
        }
        parser.expect(p, token.RPAREN)
        break
    default:
        break
    }
    if p.tok == token.LBRACK {
        var pos token.Pos = p.pos
        parser.next(p)
        var len *ast.Expr = NULL
        if p.tok != token.RBRACK {
            len = constant_expression(p)
        }
        var type ast.Expr = {
            kind: ast.TYPE_ARRAY,
            array_: {
                pos: pos,
                elt: *type_ptr,
                len: len,
            },
        }
        parser.expect(p, token.RBRACK)
        *type_ptr = &&type
    } else if parser.accept(p, token.LPAREN) {
        var params [array]*ast.Decl = makearray(*ast.Decl)
        if p.tok != token.RPAREN {
            params = parameter_type_list(p)
        }
        var type ast.Expr = {
            kind: ast.TYPE_FUNC,
            func: {
                pos: ast.Expr_pos(*type_ptr),
                result: *type_ptr,
                params: params,
            },
        }
        parser.expect(p, token.RPAREN)
        *type_ptr = &&type
    }
    if is_ptr {
        var type ast.Expr = {
            kind: ast.EXPR_STAR,
            star: {
                x: *type_ptr,
            },
        }
        *type_ptr = &&type
    }
    return name
}

fun type_qualifier(p *parser.Parser, type *ast.Expr) *ast.Expr {
    if parser.accept(p, token.CONST) {
        type.is_const = true
    }
    return type
}

fun pointer(p *parser.Parser, type *ast.Expr) *ast.Expr {
    while p.tok == token.MUL {
        var x ast.Expr = {
            kind: ast.EXPR_STAR,
            star: {
                pos: p.pos,
                x: type,
            },
        }
        parser.next(p)
        type = &&x
        type = type_qualifier(p, type)
    }
    return type
}

fun parameter_type_list(p *parser.Parser) [array]*ast.Decl {
    var params [array]*ast.Decl = makearray(*ast.Decl)
    while p.tok != token.RPAREN {
        var param *ast.Decl = parameter_declaration(p)
        append(params, param)
        if !parser.accept(p, token.COMMA) {
            break
        }
        if p.tok == token.ELLIPSIS {
            var pos token.Pos = parser.expect(p, token.ELLIPSIS)
            var type ast.Expr = {
                kind: ast.TYPE_ELLIPSIS,
                ellipsis: {
                    pos: pos,
                },
            }
            var decl ast.Decl = {
                kind: ast.DECL_FIELD,
                pos: pos,
                field: {
                    type: &&type,
                },
            }
            var param *ast.Decl = &&decl
            append(params, param)
            break
        }
    }
    return params
}

fun type_name(p *parser.Parser) *ast.Expr {
    var type *ast.Expr = specifier_qualifier_list(p)
    var decl *ast.Decl = abstract_declarator(p, type)
    type = decl.field.type
    sys.free(decl)
    return type
}

fun abstract_declarator(p *parser.Parser, type *ast.Expr) *ast.Decl {
    var pos token.Pos = p.pos
    if p.tok == token.MUL {
        type = pointer(p, type)
    }
    var is_ptr bool = false
    if parser.accept(p, token.LPAREN) {
        parser.expect(p, token.MUL)
        parser.expect(p, token.RPAREN)
        is_ptr = true
    }
    for ;; {
        if parser.accept(p, token.LBRACK) {
            var len *ast.Expr = NULL
            if p.tok != token.RBRACK {
                len = constant_expression(p)
            }
            var t ast.Expr = {
                kind: ast.TYPE_ARRAY,
                array_: {
                    pos: pos,
                    elt: type,
                    len: len,
                },
            }
            parser.expect(p, token.RBRACK)
            type = &&t
        } else if parser.accept(p, token.LPAREN) {
            var params [array]*ast.Decl = makearray(*ast.Decl)
            if p.tok != token.RPAREN {
                params = parameter_type_list(p)
            }
            var t ast.Expr = {
                kind: ast.TYPE_FUNC,
                func: {
                    pos: pos,
                    result: type,
                    params: params,
                },
            }
            parser.expect(p, token.RPAREN)
            type = &&t
        } else {
            break
        }
    }
    if is_ptr {
        var tmp ast.Expr = {
            kind: ast.EXPR_STAR,
            star: {
                pos: pos,
                x: type,
            },
        }
        type = &&tmp
    }
    var declarator ast.Decl = {
        kind: ast.DECL_FIELD,
        pos: pos,
        field: {
            type: type,
        },
    }
    return &&declarator
}

fun initializer(p *parser.Parser) *ast.Expr {
    if !parser.accept(p, token.LBRACE) {
        return expression(p)
    }
    var list [array]*ast.Expr = makearray(*ast.Expr)
    while p.tok != token.RBRACE && p.tok != token.EOF {
        var key *ast.Expr = NULL
        var isArray bool = false
        if parser.accept(p, token.PERIOD) {
            key = parser.parseIdent(p)
            parser.expect(p, token.ASSIGN)
        } else if parser.accept(p, token.LBRACK) {
            isArray = true
            key = expression(p)
            parser.expect(p, token.RBRACK)
            parser.expect(p, token.ASSIGN)
        }
        var value *ast.Expr = initializer(p)
        if key {
            var x ast.Expr = {
                kind: ast.EXPR_KEY_VALUE,
                key_value: {
                    key: key,
                    value: value,
                    isArray: isArray,
                },
            }
            value = &&x
        }
        append(list, value)
        if !parser.accept(p, token.COMMA) {
            break
        }
    }
    var expr ast.Expr = {
        kind: ast.EXPR_COMPOSITE_LIT,
        composite: {
            pos: parser.expect(p, token.RBRACE),
            list: list,
        },
    }
    return &&expr
}

fun simple_statement(p *parser.Parser, labelOk bool) *ast.Stmt {
    var x *ast.Expr = expression(p)
    var op token.Token = p.tok
    switch op {
    case token.ADD_ASSIGN, token.ASSIGN, token.DIV_ASSIGN, token.MOD_ASSIGN, token.MUL_ASSIGN, token.SHL_ASSIGN, token.SHR_ASSIGN, token.SUB_ASSIGN, token.XOR_ASSIGN:
        {
            parser.next(p)
            var y *ast.Expr = expression(p)
            var stmt ast.Stmt = {
                kind: ast.STMT_ASSIGN,
                assign: {
                    x: x,
                    op: op,
                    y: y,
                },
            }
            return &&stmt
        }
    case token.INC, token.DEC:
        {
            parser.next(p)
            var stmt ast.Stmt = {
                kind: ast.STMT_POSTFIX,
                postfix: {
                    x: x,
                    op: op,
                },
            }
            return &&stmt
        }
    default:
        break
    }
    if labelOk && x.kind == ast.EXPR_IDENT {
        if parser.accept(p, token.COLON) {
            var stmt ast.Stmt = {
                kind: ast.STMT_LABEL,
                label: {
                    label: x,
                    stmt: statement(p),
                },
            }
            return &&stmt
        }
    }
    var stmt ast.Stmt = {
        kind: ast.STMT_EXPR,
        expr: {
            x: x,
        },
    }
    return &&stmt
}

fun statement(p *parser.Parser) *ast.Stmt {
    if is_type(p) {
        var stmt ast.Stmt = {
            kind: ast.STMT_DECL,
            decl: {
                decl: declaration(p, false),
            },
        }
        return &&stmt
    }
    var pos token.Pos = p.pos
    if parser.accept(p, token.FOR) {
        parser.expect(p, token.LPAREN)
        var init *ast.Stmt = NULL
        if !parser.accept(p, token.SEMICOLON) {
            init = statement(p)
        }
        var cond *ast.Expr = NULL
        if p.tok != token.SEMICOLON {
            cond = expression(p)
        }
        parser.expect(p, token.SEMICOLON)
        var post *ast.Stmt = NULL
        if p.tok != token.RPAREN {
            post = simple_statement(p, false)
        }
        parser.expect(p, token.RPAREN)
        var body *ast.Stmt = compound_statement(p, true)
        var stmt ast.Stmt = {
            kind: ast.STMT_ITER,
            iter: {
                pos: pos,
                kind: token.FOR,
                init: init,
                cond: cond,
                post: post,
                body: body,
            },
        }
        return &&stmt
    }
    if parser.accept(p, token.IF) {
        parser.expect(p, token.LPAREN)
        var cond *ast.Expr = expression(p)
        parser.expect(p, token.RPAREN)
        var body *ast.Stmt = compound_statement(p, true)
        var else_ *ast.Stmt = NULL
        if parser.accept(p, token.ELSE) {
            if p.tok == token.IF {
                else_ = statement(p)
            } else {
                else_ = compound_statement(p, true)
            }
        }
        var stmt ast.Stmt = {
            kind: ast.STMT_IF,
            if_: {
                pos: pos,
                cond: cond,
                body: body,
                else_: else_,
            },
        }
        return &&stmt
    }
    if parser.accept(p, token.RETURN) {
        var x *ast.Expr = NULL
        if p.tok != token.SEMICOLON {
            x = expression(p)
        }
        parser.expect(p, token.SEMICOLON)
        var stmt ast.Stmt = {
            kind: ast.STMT_RETURN,
            return_: {
                pos: pos,
                x: x,
            },
        }
        return &&stmt
    }
    if parser.accept(p, token.SWITCH) {
        parser.expect(p, token.LPAREN)
        var tag *ast.Expr = expression(p)
        parser.expect(p, token.RPAREN)
        parser.expect(p, token.LBRACE)
        var clauses [array]*ast.Stmt = makearray(*ast.Stmt)
        while p.tok == token.CASE || p.tok == token.DEFAULT {
            var exprs [array]*ast.Expr = makearray(*ast.Expr)
            while parser.accept(p, token.CASE) {
                var expr *ast.Expr = constant_expression(p)
                parser.expect(p, token.COLON)
                append(exprs, expr)
            }
            if len(exprs) == 0 {
                parser.expect(p, token.DEFAULT)
                parser.expect(p, token.COLON)
            }
            var stmts [array]*ast.Stmt = makearray(*ast.Stmt)
            var loop bool = true
            while loop {
                switch p.tok {
                case token.CASE, token.DEFAULT, token.RBRACE:
                    loop = false
                    break
                default:
                    break
                }
                if loop {
                    var stmt *ast.Stmt = statement(p)
                    append(stmts, stmt)
                }
            }
            var stmt ast.Stmt = {
                kind: ast.STMT_CASE,
                case_: {
                    pos: pos,
                    exprs: exprs,
                    stmts: stmts,
                },
            }
            var clause *ast.Stmt = &&stmt
            append(clauses, clause)
        }
        parser.expect(p, token.RBRACE)
        var stmt ast.Stmt = {
            kind: ast.STMT_SWITCH,
            switch_: {
                pos: pos,
                tag: tag,
                stmts: clauses,
            },
        }
        return &&stmt
    }
    if parser.accept(p, token.WHILE) {
        parser.expect(p, token.LPAREN)
        var cond *ast.Expr = expression(p)
        parser.expect(p, token.RPAREN)
        var body *ast.Stmt = compound_statement(p, true)
        var stmt ast.Stmt = {
            kind: ast.STMT_ITER,
            iter: {
                pos: pos,
                kind: token.WHILE,
                cond: cond,
                body: body,
            },
        }
        return &&stmt
    }
    switch p.tok {
    case token.BREAK, token.CONTINUE, token.FALLTHROUGH, token.GOTO:
        {
            var keyword token.Token = p.tok
            parser.next(p)
            var label *ast.Expr = NULL
            if keyword == token.GOTO {
                label = parser.parseIdent(p)
            }
            parser.expect(p, token.SEMICOLON)
            var stmt ast.Stmt = {
                kind: ast.STMT_JUMP,
                jump: {
                    pos: pos,
                    keyword: keyword,
                    label: label,
                },
            }
            return &&stmt
        }
    case token.LBRACE:
        return compound_statement(p, false)
    default:
        break
    }
    if parser.accept(p, token.SEMICOLON) {
        var stmt ast.Stmt = {
            kind: ast.STMT_EMPTY,
            empty: {
                pos: pos,
            },
        }
        return &&stmt
    }
    var stmt *ast.Stmt = simple_statement(p, true)
    if stmt.kind != ast.STMT_LABEL {
        parser.expect(p, token.SEMICOLON)
    }
    return stmt
}

fun compound_statement(p *parser.Parser, allow_single bool) *ast.Stmt {
    var stmts [array]*ast.Stmt = makearray(*ast.Stmt)
    var pos token.Pos = 0
    if allow_single && p.tok != token.LBRACE {
        var stmt *ast.Stmt = statement(p)
        assert(stmt.kind != ast.STMT_DECL)
        append(stmts, stmt)
        pos = ast.Stmt_pos(stmt)
    } else {
        pos = parser.expect(p, token.LBRACE)
        while p.tok != token.RBRACE {
            var stmt *ast.Stmt = statement(p)
            append(stmts, stmt)
        }
        parser.expect(p, token.RBRACE)
    }
    var stmt ast.Stmt = {
        kind: ast.STMT_BLOCK,
        block: {
            pos: pos,
            stmts: stmts,
        },
    }
    return &&stmt
}

fun parameter_declaration(p *parser.Parser) *ast.Decl {
    var decl ast.Decl = {
        kind: ast.DECL_FIELD,
        pos: p.pos,
    }
    decl.field.type = declaration_specifiers(p, false)
    decl.field.name = declarator(p, &decl.field.type)
    return &&decl
}

fun array_specifier(p *parser.Parser) *ast.Expr {
    var pos token.Pos = p.pos
    parser.expect(p, token.ARRAY)
    parser.expect(p, token.LPAREN)
    var elt *ast.Expr = type_name(p)
    parser.expect(p, token.RPAREN)
    var tmp ast.Expr = {
        kind: ast.TYPE_ARRAY,
        array_: {
            pos: pos,
            elt: elt,
            dynamic: true,
        },
    }
    return &&tmp
}

fun map_specifier(p *parser.Parser) *ast.Expr {
    var pos token.Pos = p.pos
    parser.expect(p, token.MAP)
    parser.expect(p, token.LPAREN)
    var val *ast.Expr = type_name(p)
    parser.expect(p, token.RPAREN)
    var tmp ast.Expr = {
        kind: ast.TYPE_MAP,
        map_: {
            pos: pos,
            val: val,
        },
    }
    return &&tmp
}

fun type_specifier(p *parser.Parser) *ast.Expr {
    var x *ast.Expr = NULL
    switch p.tok {
    case token.SIGNED, token.UNSIGNED:
        parser.error(p, p.pos, sys.sprintf("`%s` is not supported in subc", token.string(p.tok)))
        break
    case token.STRUCT, token.UNION:
        x = struct_or_union_specifier(p)
        break
    case token.ENUM:
        x = enum_specifier(p)
        break
    case token.ARRAY:
        x = array_specifier(p)
        break
    case token.MAP:
        x = map_specifier(p)
        break
    default:
        if is_type(p) {
            x = parser.parseIdent(p)
        } else {
            parser.errorExpected(p, p.pos, "type")
        }
        break
    }
    return x
}

fun declaration_specifiers(p *parser.Parser, is_top bool) *ast.Expr {
    if is_top {
        switch p.tok {
        case token.EXTERN, token.STATIC:
            parser.next(p)
            break
        default:
            break
        }
    }
    var is_const bool = parser.accept(p, token.CONST)
    var type *ast.Expr = type_specifier(p)
    if is_const {
        type.is_const = is_const
    }
    return type
}

fun specifier_qualifier_list(p *parser.Parser) *ast.Expr {
    return declaration_specifiers(p, false)
}

fun declaration(p *parser.Parser, is_external bool) *ast.Decl {
    if p.tok == token.HASH {
        return parser.parsePragma(p)
    }
    var pos token.Pos = p.pos
    if p.tok == token.TYPEDEF {
        var keyword token.Token = p.tok
        parser.expect(p, keyword)
        var type *ast.Expr = declaration_specifiers(p, true)
        var name *ast.Expr = declarator(p, &type)
        parser.expect(p, token.SEMICOLON)
        var declref ast.Decl = {
            kind: ast.DECL_TYPEDEF,
            pos: pos,
            typedef_: {
                name: name,
                type: type,
            },
        }
        var decl *ast.Decl = &&declref
        var obj *ast.Object = ast.newObject(ast.ObjKind_TYP, name.ident.name)
        ast.Scope_insert(p.topScope, obj)
        return decl
    }
    var type *ast.Expr = declaration_specifiers(p, true)
    var name *ast.Expr = declarator(p, &type)
    var value *ast.Expr = NULL
    if type.kind == ast.TYPE_FUNC {
        var decl ast.Decl = {
            kind: ast.DECL_FUNC,
            pos: pos,
            func: {
                type: type,
                name: name,
            },
        }
        if is_external && p.tok == token.LBRACE {
            decl.func.body = compound_statement(p, false)
        } else {
            parser.expect(p, token.SEMICOLON)
        }
        return &&decl
    }
    if parser.accept(p, token.ASSIGN) {
        value = initializer(p)
    }
    parser.expect(p, token.SEMICOLON)
    if name != NULL {
        var decl ast.Decl = {
            kind: ast.DECL_VALUE,
            pos: pos,
            value: {
                type: type,
                name: name,
                value: value,
                kind: token.VAR,
            },
        }
        return &&decl
    } else {
        switch type.kind {
        case ast.TYPE_STRUCT:
            name = type.struct_.name
            break
        default:
            panic(sys.sprintf("bad kind: %d", type.kind))
            break
        }
        var decl ast.Decl = {
            kind: ast.DECL_TYPEDEF,
            pos: pos,
            typedef_: {
                type: type,
                name: name,
            },
        }
        return &&decl
    }
}

fun parse_cfile(p *parser.Parser, scope *ast.Scope) *ast.File {
    var decls [array]*ast.Decl = makearray(*ast.Decl)
    var imports [array]*ast.Decl = makearray(*ast.Decl)
    var name *ast.Expr = NULL
    while p.tok == token.HASH {
        var lit *ast.Decl = parser.parsePragma(p)
        append(decls, lit)
    }
    if parser.accept(p, token.PACKAGE) {
        parser.expect(p, token.LPAREN)
        name = parser.parseIdent(p)
        parser.expect(p, token.RPAREN)
        parser.expect(p, token.SEMICOLON)
    }
    p.topScope = scope
    p.pkgScope = p.topScope
    while p.tok == token.IMPORT {
        parser.expect(p, token.IMPORT)
        parser.expect(p, token.LPAREN)
        var path *ast.Expr = parser.parseBasicLit(p, token.STRING)
        parser.expect(p, token.RPAREN)
        parser.expect(p, token.SEMICOLON)
        var decl ast.Decl = {
            kind: ast.DECL_IMPORT,
            imp: {
                path: path,
            },
        }
        var declp *ast.Decl = &&decl
        append(imports, declp)
    }
    while p.tok != token.EOF {
        var decl *ast.Decl = declaration(p, true)
        append(decls, decl)
    }
    var file ast.File = {
        filename: p.file.name,
        name: name,
        decls: decls,
        imports: imports,
        scope: p.pkgScope,
    }
    return &&file
}

fun parseFile(fset *token.FileSet, filename *const char, scope *ast.Scope) *ast.File {
    var src *char = ioutil.readFile(filename, NULL)
    var p parser.Parser = {}
    parser.init(&p, fset, filename, src)
    p.c_mode = true
    assert(scope)
    var file *ast.File = parse_cfile(&p, scope)
    sys.free(src)
    return file
}
