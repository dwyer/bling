package cparser

import "C"
import "bling/ast"
import "bling/parser"
import "bling/scanner"
import "bling/token"
import "io/ioutil"
import "runtime"
import "sys"

fun isType(p *parser.Parser) bool {
    switch p.tok {
    case token.ARRAY, token.CONST, token.ENUM, token.EXTERN, token.MAP, token.SIGNED, token.STATIC, token.STRUCT, token.UNION, token.UNSIGNED:
        return true
    case token.IDENT:
        return runtime.Map_get(&p.typeNames, p.lit, nil)
    default:
        return false
    }
}

fun operand(p *parser.Parser) *ast.Expr {
    switch p.tok {
    case token.GET:
        {
            parser.expect(p, token.GET)
            parser.expect(p, token.LPAREN)
            typeName(p)
            parser.expect(p, token.COMMA)
            var arr = expression(p)
            parser.expect(p, token.COMMA)
            var index = expression(p)
            parser.expect(p, token.RPAREN)
            var y = ast.Expr{
                kind: ast.EXPR_INDEX,
                index: {
                    x: arr,
                    index: index,
                },
            }
            return &&y
        }
    default:
        return parser.parseOperand(p)
    }
}

fun postfixExpr(p *parser.Parser, x *ast.Expr) *ast.Expr {
    if x == nil {
        x = operand(p)
    }
    for ;; {
        switch p.tok {
        case token.LBRACK:
            {
                parser.expect(p, token.LBRACK)
                var y = ast.Expr{
                    kind: ast.EXPR_INDEX,
                    index: {
                        x: x,
                        index: expression(p),
                    },
                }
                parser.expect(p, token.RBRACK)
                x = &&y
            }
            break
        case token.LPAREN:
            {
                var args = makearray(*ast.Expr)
                parser.expect(p, token.LPAREN)
                while p.tok != token.RPAREN {
                    var x *ast.Expr = nil
                    if isType(p) {
                        x = typeName(p)
                    } else {
                        x = expression(p)
                    }
                    append(args, x)
                    if !parser.accept(p, token.COMMA) {
                        break
                    }
                }
                parser.expect(p, token.RPAREN)
                var call = ast.Expr{
                    kind: ast.EXPR_CALL,
                    call: {
                        func: x,
                        args: args,
                    },
                }
                x = &&call
            }
            break
        case token.ARROW, token.PERIOD:
            {
                var tok = p.tok
                parser.next(p)
                var y = ast.Expr{
                    kind: ast.EXPR_SELECTOR,
                    selector: {
                        x: x,
                        tok: tok,
                        sel: parser.parseIdent(p),
                    },
                }
                x = &&y
            }
            break
        default:
            goto done
        }
    }
done:
    return x
}

fun unaryExpr(p *parser.Parser) *ast.Expr {
    var pos = p.pos
    switch p.tok {
    case token.ADD, token.AND, token.BITWISE_NOT, token.NOT, token.SUB:
        {
            var op = p.tok
            parser.next(p)
            var x = ast.Expr{
                kind: ast.EXPR_UNARY,
                unary: {
                    pos: pos,
                    op: op,
                    x: castExpr(p),
                },
            }
            if op == token.LAND {
                parser.expect(p, token.RPAREN)
            }
            return &&x
        }
    case token.MUL:
        {
            parser.next(p)
            var x = ast.Expr{
                kind: ast.EXPR_STAR,
                star: {
                    pos: pos,
                    x: castExpr(p),
                },
            }
            return &&x
        }
    case token.SIZEOF:
        {
            parser.next(p)
            parser.expect(p, token.LPAREN)
            var x *ast.Expr = nil
            if isType(p) {
                x = typeName(p)
                if p.tok == token.MUL {
                    declarator(p, &x)
                }
            } else {
                x = unaryExpr(p)
            }
            parser.expect(p, token.RPAREN)
            var y = ast.Expr{
                kind: ast.EXPR_SIZEOF,
                sizeof_: {
                    pos: pos,
                    x: x,
                },
            }
            return &&y
        }
    case token.DEC, token.INC:
        parser.error(p, p.pos, C.sprintf("unary `%s` not supported in subc", token.string(p.tok)))
        return nil
    default:
        return postfixExpr(p, nil)
    }
}

fun castExpr(p *parser.Parser) *ast.Expr {
    if p.tok == token.LPAREN {
        var pos = parser.expect(p, token.LPAREN)
        if isType(p) {
            var type = typeName(p)
            parser.expect(p, token.RPAREN)
            if p.tok == token.LBRACE {
                var x *ast.Expr = initializer(p) // XXX
                x.composite.type = type
                return x
            }
            var y = ast.Expr{
                kind: ast.EXPR_CAST,
                cast: {
                    pos: pos,
                    type: type,
                    expr: castExpr(p),
                },
            }
            return &&y
        } else {
            var x *ast.Expr = expression(p) // XXX
            if x.kind != ast.EXPR_COMPOSITE_LIT {
                var y = ast.Expr{
                    kind: ast.EXPR_PAREN,
                    paren: {
                        pos: pos,
                        x: x,
                    },
                }
                x = &&y
            }
            parser.expect(p, token.RPAREN)
            return postfixExpr(p, x)
        }
    }
    return unaryExpr(p)
}

fun binaryExpr(p *parser.Parser, prec1 int) *ast.Expr {
    var x = castExpr(p)
    for ;; {
        var op = p.tok
        var oprec = token.precedence(op)
        if oprec < prec1 {
            return x
        }
        parser.expect(p, op)
        var y = binaryExpr(p, oprec + 1)
        var z = ast.Expr{
            kind: ast.EXPR_BINARY,
            binary: {
                x: x,
                op: op,
                y: y,
            },
        }
        x = &&z
    }
}

fun ternaryExpr(p *parser.Parser) *ast.Expr {
    var x = binaryExpr(p, token.lowest_prec + 1)
    if parser.accept(p, token.QUESTION_MARK) {
        var consequence *ast.Expr = nil
        if p.tok != token.COLON {
            consequence = expression(p)
        }
        parser.expect(p, token.COLON)
        var alternative = ternaryExpr(p)
        var y = ast.Expr{
            kind: ast.EXPR_TERNARY,
            ternary: {
                cond: x,
                x: consequence,
                y: alternative,
            },
        }
        x = &&y
    }
    return x
}

fun expression(p *parser.Parser) *ast.Expr {
    return ternaryExpr(p)
}

fun constantExpr(p *parser.Parser) *ast.Expr {
    return ternaryExpr(p)
}

fun structOrUnionSpec(p *parser.Parser) *ast.Expr {
    var keyword = p.tok
    var pos = parser.expect(p, keyword)
    var name *ast.Expr = nil
    if p.tok == token.IDENT {
        name = parser.parseIdent(p)
    }
    var fields = makearray(*ast.Decl)
    if parser.accept(p, token.LBRACE) {
        for ;; {
            var pos = p.pos
            var type = specifierQualifierList(p)
            var name = declarator(p, &type)
            var f = ast.Decl{
                kind: ast.DECL_FIELD,
                pos: pos,
                field: {
                    type: type,
                    name: name,
                },
            }
            parser.expect(p, token.SEMICOLON)
            var field = &&f
            append(fields, field)
            if p.tok == token.RBRACE {
                break
            }
        }
        parser.expect(p, token.RBRACE)
    }
    var x = ast.Expr{
        kind: ast.TYPE_STRUCT,
        struct_: {
            pos: pos,
            tok: keyword,
            name: name,
            fields: fields,
        },
    }
    return &&x
}

fun enumSpec(p *parser.Parser) *ast.Expr {
    var pos = parser.expect(p, token.ENUM)
    var name *ast.Expr = nil
    if p.tok == token.IDENT {
        name = parser.parseIdent(p)
    }
    var enums = makearray(*ast.Decl)
    if parser.accept(p, token.LBRACE) {
        for ;; {
            var decl = ast.Decl{
                kind: ast.DECL_VALUE,
                pos: p.pos,
                value: {
                    name: parser.parseIdent(p),
                    kind: token.VAR,
                },
            }
            if parser.accept(p, token.ASSIGN) {
                decl.value.value = constantExpr(p)
            }
            var enumerator = &&decl
            append(enums, enumerator)
            if !parser.accept(p, token.COMMA) || p.tok == token.RBRACE {
                break
            }
        }
        parser.expect(p, token.RBRACE)
    }
    var x = ast.Expr{
        kind: ast.TYPE_ENUM,
        enum_: {
            pos: pos,
            name: name,
            enums: enums,
        },
    }
    return &&x
}

fun declarator(p *parser.Parser, typePtr **ast.Expr) *ast.Expr {
    if p.tok == token.MUL {
        *typePtr = pointer(p, *typePtr)
    }
    var name *ast.Expr = nil
    var isPtr = false
    switch p.tok {
    case token.IDENT:
        name = parser.parseIdent(p)
        break
    case token.LPAREN:
        parser.expect(p, token.LPAREN)
        isPtr = parser.accept(p, token.MUL)
        if !isPtr || p.tok == token.IDENT {
            name = parser.parseIdent(p)
        }
        parser.expect(p, token.RPAREN)
        break
    default:
        break
    }
    if p.tok == token.LBRACK {
        var pos token.Pos = p.pos
        parser.next(p)
        var len *ast.Expr = nil
        if p.tok != token.RBRACK {
            len = constantExpr(p)
        }
        var type = ast.Expr{
            kind: ast.TYPE_ARRAY,
            array_: {
                pos: pos,
                elt: *typePtr,
                len: len,
            },
        }
        parser.expect(p, token.RBRACK)
        *typePtr = &&type
    } else if parser.accept(p, token.LPAREN) {
        var params = makearray(*ast.Decl)
        if p.tok != token.RPAREN {
            params = paramTypeList(p)
        }
        var type = ast.Expr{
            kind: ast.TYPE_FUNC,
            func: {
                pos: ast.Expr_pos(*typePtr),
                result: *typePtr,
                params: params,
            },
        }
        parser.expect(p, token.RPAREN)
        *typePtr = &&type
    }
    if isPtr {
        var type = ast.Expr{
            kind: ast.EXPR_STAR,
            star: {
                x: *typePtr,
            },
        }
        *typePtr = &&type
    }
    return name
}

fun typeQualifier(p *parser.Parser, type *ast.Expr) *ast.Expr {
    if parser.accept(p, token.CONST) {
        type.is_const = true
    }
    return type
}

fun pointer(p *parser.Parser, type *ast.Expr) *ast.Expr {
    while p.tok == token.MUL {
        var x = ast.Expr{
            kind: ast.EXPR_STAR,
            star: {
                pos: p.pos,
                x: type,
            },
        }
        parser.next(p)
        type = &&x
        type = typeQualifier(p, type)
    }
    return type
}

fun paramTypeList(p *parser.Parser) [array]*ast.Decl {
    var params = makearray(*ast.Decl)
    while p.tok != token.RPAREN {
        var param = parameterDeclaration(p)
        append(params, param)
        if !parser.accept(p, token.COMMA) {
            break
        }
        if p.tok == token.ELLIPSIS {
            var pos = parser.expect(p, token.ELLIPSIS)
            var type = ast.Expr{
                kind: ast.TYPE_ELLIPSIS,
                ellipsis: {
                    pos: pos,
                },
            }
            var decl = ast.Decl{
                kind: ast.DECL_FIELD,
                pos: pos,
                field: {
                    type: &&type,
                },
            }
            var param = &&decl
            append(params, param)
            break
        }
    }
    return params
}

fun typeName(p *parser.Parser) *ast.Expr {
    var type = specifierQualifierList(p)
    var decl *ast.Decl = abstractDeclarator(p, type) // XXX
    type = decl.field.type
    runtime.free(decl)
    return type
}

fun abstractDeclarator(p *parser.Parser, type *ast.Expr) *ast.Decl {
    var pos = p.pos
    if p.tok == token.MUL {
        type = pointer(p, type)
    }
    var isPtr = false
    if parser.accept(p, token.LPAREN) {
        parser.expect(p, token.MUL)
        parser.expect(p, token.RPAREN)
        isPtr = true
    }
    for ;; {
        if parser.accept(p, token.LBRACK) {
            var len *ast.Expr = nil
            if p.tok != token.RBRACK {
                len = constantExpr(p)
            }
            var t = ast.Expr{
                kind: ast.TYPE_ARRAY,
                array_: {
                    pos: pos,
                    elt: type,
                    len: len,
                },
            }
            parser.expect(p, token.RBRACK)
            type = &&t
        } else if parser.accept(p, token.LPAREN) {
            var params = makearray(*ast.Decl)
            if p.tok != token.RPAREN {
                params = paramTypeList(p)
            }
            var t = ast.Expr{
                kind: ast.TYPE_FUNC,
                func: {
                    pos: pos,
                    result: type,
                    params: params,
                },
            }
            parser.expect(p, token.RPAREN)
            type = &&t
        } else {
            break
        }
    }
    if isPtr {
        var tmp = ast.Expr{
            kind: ast.EXPR_STAR,
            star: {
                pos: pos,
                x: type,
            },
        }
        type = &&tmp
    }
    var declarator = ast.Decl{
        kind: ast.DECL_FIELD,
        pos: pos,
        field: {
            type: type,
        },
    }
    return &&declarator
}

fun initializer(p *parser.Parser) *ast.Expr {
    if !parser.accept(p, token.LBRACE) {
        return expression(p)
    }
    var list = makearray(*ast.Expr)
    while p.tok != token.RBRACE && p.tok != token.EOF {
        var key *ast.Expr = nil
        var isArray = false
        if parser.accept(p, token.PERIOD) {
            key = parser.parseIdent(p)
            parser.expect(p, token.ASSIGN)
        } else if parser.accept(p, token.LBRACK) {
            isArray = true
            key = expression(p)
            parser.expect(p, token.RBRACK)
            parser.expect(p, token.ASSIGN)
        }
        var value = initializer(p)
        if key {
            var x = ast.Expr{
                kind: ast.EXPR_KEY_VALUE,
                key_value: {
                    key: key,
                    value: value,
                    isArray: isArray,
                },
            }
            value = &&x
        }
        append(list, value)
        if !parser.accept(p, token.COMMA) {
            break
        }
    }
    var expr = ast.Expr{
        kind: ast.EXPR_COMPOSITE_LIT,
        composite: {
            pos: parser.expect(p, token.RBRACE),
            list: list,
        },
    }
    return &&expr
}

fun simpleStmt(p *parser.Parser, labelOk bool) *ast.Stmt {
    var x = expression(p)
    var op = p.tok
    switch op {
    case token.ADD_ASSIGN, token.ASSIGN, token.DIV_ASSIGN, token.MOD_ASSIGN, token.MUL_ASSIGN, token.SHL_ASSIGN, token.SHR_ASSIGN, token.SUB_ASSIGN, token.XOR_ASSIGN:
        {
            parser.next(p)
            var y = expression(p)
            var stmt = ast.Stmt{
                kind: ast.STMT_ASSIGN,
                assign: {
                    x: x,
                    op: op,
                    y: y,
                },
            }
            return &&stmt
        }
    case token.INC, token.DEC:
        {
            parser.next(p)
            var stmt = ast.Stmt{
                kind: ast.STMT_POSTFIX,
                postfix: {
                    x: x,
                    op: op,
                },
            }
            return &&stmt
        }
    default:
        break
    }
    if labelOk && x.kind == ast.EXPR_IDENT {
        if parser.accept(p, token.COLON) {
            var stmt = ast.Stmt{
                kind: ast.STMT_LABEL,
                label: {
                    label: x,
                    stmt: statement(p),
                },
            }
            return &&stmt
        }
    }
    var stmt = ast.Stmt{
        kind: ast.STMT_EXPR,
        expr: {
            x: x,
        },
    }
    return &&stmt
}

fun statement(p *parser.Parser) *ast.Stmt {
    if isType(p) {
        var stmt = ast.Stmt{
            kind: ast.STMT_DECL,
            decl: {
                decl: declaration(p, false),
            },
        }
        return &&stmt
    }
    var pos = p.pos
    if parser.accept(p, token.FOR) {
        parser.expect(p, token.LPAREN)
        var init *ast.Stmt = nil
        if !parser.accept(p, token.SEMICOLON) {
            init = statement(p)
        }
        var cond *ast.Expr = nil
        if p.tok != token.SEMICOLON {
            cond = expression(p)
        }
        parser.expect(p, token.SEMICOLON)
        var post *ast.Stmt = nil
        if p.tok != token.RPAREN {
            post = simpleStmt(p, false)
        }
        parser.expect(p, token.RPAREN)
        var body = compoundStmt(p, true)
        var stmt = ast.Stmt{
            kind: ast.STMT_ITER,
            iter: {
                pos: pos,
                kind: token.FOR,
                init: init,
                cond: cond,
                post: post,
                body: body,
            },
        }
        return &&stmt
    }
    if parser.accept(p, token.IF) {
        parser.expect(p, token.LPAREN)
        var cond = expression(p)
        parser.expect(p, token.RPAREN)
        var body = compoundStmt(p, true)
        var else_ *ast.Stmt = nil
        if parser.accept(p, token.ELSE) {
            if p.tok == token.IF {
                else_ = statement(p)
            } else {
                else_ = compoundStmt(p, true)
            }
        }
        var stmt = ast.Stmt{
            kind: ast.STMT_IF,
            if_: {
                pos: pos,
                cond: cond,
                body: body,
                else_: else_,
            },
        }
        return &&stmt
    }
    if parser.accept(p, token.RETURN) {
        var x *ast.Expr = nil
        if p.tok != token.SEMICOLON {
            x = expression(p)
        }
        parser.expect(p, token.SEMICOLON)
        var stmt = ast.Stmt{
            kind: ast.STMT_RETURN,
            return_: {
                pos: pos,
                x: x,
            },
        }
        return &&stmt
    }
    if parser.accept(p, token.SWITCH) {
        parser.expect(p, token.LPAREN)
        var tag = expression(p)
        parser.expect(p, token.RPAREN)
        parser.expect(p, token.LBRACE)
        var clauses = makearray(*ast.Stmt)
        while p.tok == token.CASE || p.tok == token.DEFAULT {
            var exprs = makearray(*ast.Expr)
            while parser.accept(p, token.CASE) {
                var expr = constantExpr(p)
                parser.expect(p, token.COLON)
                append(exprs, expr)
            }
            if len(exprs) == 0 {
                parser.expect(p, token.DEFAULT)
                parser.expect(p, token.COLON)
            }
            var stmts = makearray(*ast.Stmt)
            for var loop = true; loop; {
                switch p.tok {
                case token.CASE, token.DEFAULT, token.RBRACE:
                    loop = false
                    break
                default:
                    break
                }
                if loop {
                    append(stmts, statement(p))
                }
            }
            var stmt = ast.Stmt{
                kind: ast.STMT_CASE,
                case_: {
                    pos: pos,
                    exprs: exprs,
                    stmts: stmts,
                },
            }
            var clause = &&stmt
            append(clauses, clause)
        }
        parser.expect(p, token.RBRACE)
        var stmt = ast.Stmt{
            kind: ast.STMT_SWITCH,
            switch_: {
                pos: pos,
                tag: tag,
                stmts: clauses,
            },
        }
        return &&stmt
    }
    if parser.accept(p, token.WHILE) {
        parser.expect(p, token.LPAREN)
        var cond = expression(p)
        parser.expect(p, token.RPAREN)
        var body = compoundStmt(p, true)
        var stmt = ast.Stmt{
            kind: ast.STMT_ITER,
            iter: {
                pos: pos,
                kind: token.WHILE,
                cond: cond,
                body: body,
            },
        }
        return &&stmt
    }
    switch p.tok {
    case token.BREAK, token.CONTINUE, token.FALLTHROUGH, token.GOTO:
        {
            var keyword = p.tok
            parser.next(p)
            var label *ast.Expr = nil
            if keyword == token.GOTO {
                label = parser.parseIdent(p)
            }
            parser.expect(p, token.SEMICOLON)
            var stmt = ast.Stmt{
                kind: ast.STMT_JUMP,
                jump: {
                    pos: pos,
                    keyword: keyword,
                    label: label,
                },
            }
            return &&stmt
        }
    case token.LBRACE:
        return compoundStmt(p, false)
    default:
        break
    }
    if parser.accept(p, token.SEMICOLON) {
        var stmt = ast.Stmt{
            kind: ast.STMT_EMPTY,
            empty: {
                pos: pos,
            },
        }
        return &&stmt
    }
    var stmt = simpleStmt(p, true)
    if stmt.kind != ast.STMT_LABEL {
        parser.expect(p, token.SEMICOLON)
    }
    return stmt
}

fun compoundStmt(p *parser.Parser, allow_single bool) *ast.Stmt {
    var stmts = makearray(*ast.Stmt)
    var pos token.Pos = 0
    if allow_single && p.tok != token.LBRACE {
        var stmt = statement(p)
        assert(stmt.kind != ast.STMT_DECL)
        append(stmts, stmt)
        pos = ast.Stmt_pos(stmt)
    } else {
        pos = parser.expect(p, token.LBRACE)
        while p.tok != token.RBRACE {
            append(stmts, statement(p))
        }
        parser.expect(p, token.RBRACE)
    }
    var stmt = ast.Stmt{
        kind: ast.STMT_BLOCK,
        block: {
            pos: pos,
            stmts: stmts,
        },
    }
    return &&stmt
}

fun parameterDeclaration(p *parser.Parser) *ast.Decl {
    var decl = ast.Decl{
        kind: ast.DECL_FIELD,
        pos: p.pos,
    }
    decl.field.type = declarationSpecifiers(p, false)
    decl.field.name = declarator(p, &decl.field.type)
    return &&decl
}

fun arraySpecifier(p *parser.Parser) *ast.Expr {
    var pos = p.pos
    parser.expect(p, token.ARRAY)
    parser.expect(p, token.LPAREN)
    var elt = typeName(p)
    parser.expect(p, token.RPAREN)
    var tmp = ast.Expr{
        kind: ast.TYPE_ARRAY,
        array_: {
            pos: pos,
            elt: elt,
            dynamic: true,
        },
    }
    return &&tmp
}

fun mapSpecifier(p *parser.Parser) *ast.Expr {
    var pos = p.pos
    parser.expect(p, token.MAP)
    parser.expect(p, token.LPAREN)
    var val = typeName(p)
    parser.expect(p, token.RPAREN)
    var tmp = ast.Expr{
        kind: ast.TYPE_MAP,
        map_: {
            pos: pos,
            val: val,
        },
    }
    return &&tmp
}

fun typeSpecifier(p *parser.Parser) *ast.Expr {
    var x *ast.Expr = nil
    switch p.tok {
    case token.SIGNED, token.UNSIGNED:
        parser.error(p, p.pos, C.sprintf("`%s` is not supported in subc", token.string(p.tok)))
        break
    case token.STRUCT, token.UNION:
        x = structOrUnionSpec(p)
        break
    case token.ENUM:
        x = enumSpec(p)
        break
    case token.ARRAY:
        x = arraySpecifier(p)
        break
    case token.MAP:
        x = mapSpecifier(p)
        break
    default:
        if isType(p) {
            x = parser.parseIdent(p)
        } else {
            parser.errorExpected(p, p.pos, "type")
        }
        break
    }
    return x
}

fun declarationSpecifiers(p *parser.Parser, isTop bool) *ast.Expr {
    if isTop {
        switch p.tok {
        case token.EXTERN, token.STATIC:
            parser.next(p)
            break
        default:
            break
        }
    }
    var isConst = parser.accept(p, token.CONST)
    var type = typeSpecifier(p)
    if isConst {
        type.is_const = isConst
    }
    return type
}

fun specifierQualifierList(p *parser.Parser) *ast.Expr {
    return declarationSpecifiers(p, false)
}

fun declaration(p *parser.Parser, isExternal bool) *ast.Decl {
    if p.tok == token.HASH {
        return parser.parsePragma(p)
    }
    var pos token.Pos = p.pos
    if p.tok == token.TYPEDEF {
        var keyword = p.tok
        parser.expect(p, keyword)
        var type = declarationSpecifiers(p, true)
        var name = declarator(p, &type)
        parser.expect(p, token.SEMICOLON)
        var decl = ast.Decl{
            kind: ast.DECL_TYPE,
            pos: pos,
            type: {
                name: name,
                type: type,
            },
        }
        var d = &&decl
        var obj = ast.newObject(ast.ObjKind_TYP, name.ident.name)
        runtime.Map_set(&p.typeNames, name.ident.name, &type)
        return d
    }
    var type = declarationSpecifiers(p, true)
    var name = declarator(p, &type)
    var value *ast.Expr = nil
    if type.kind == ast.TYPE_FUNC {
        var decl = ast.Decl{
            kind: ast.DECL_FUNC,
            pos: pos,
            func: {
                type: type,
                name: name,
            },
        }
        if isExternal && p.tok == token.LBRACE {
            decl.func.body = compoundStmt(p, false)
        } else {
            parser.expect(p, token.SEMICOLON)
        }
        return &&decl
    }
    if parser.accept(p, token.ASSIGN) {
        value = initializer(p)
    }
    parser.expect(p, token.SEMICOLON)
    if name != nil {
        var decl = ast.Decl{
            kind: ast.DECL_VALUE,
            pos: pos,
            value: {
                type: type,
                name: name,
                value: value,
                kind: token.VAR,
            },
        }
        return &&decl
    } else {
        switch type.kind {
        case ast.TYPE_STRUCT:
            name = type.struct_.name
            break
        default:
            panic(C.sprintf("bad kind: %d", type.kind))
            break
        }
        var decl = ast.Decl{
            kind: ast.DECL_TYPE,
            pos: pos,
            type: {
                type: type,
                name: name,
            },
        }
        return &&decl
    }
}

fun _parseFile(p *parser.Parser) *ast.File {
    var decls = makearray(*ast.Decl)
    var imports = makearray(*ast.Decl)
    var name *ast.Expr = nil
    while p.tok == token.HASH {
        var lit = parser.parsePragma(p)
        append(decls, lit)
    }
    if parser.accept(p, token.PACKAGE) {
        parser.expect(p, token.LPAREN)
        name = parser.parseIdent(p)
        parser.expect(p, token.RPAREN)
        parser.expect(p, token.SEMICOLON)
    }
    while p.tok == token.IMPORT {
        parser.expect(p, token.IMPORT)
        parser.expect(p, token.LPAREN)
        var path = parser.parseBasicLit(p, token.STRING)
        parser.expect(p, token.RPAREN)
        parser.expect(p, token.SEMICOLON)
        var decl = ast.Decl{
            kind: ast.DECL_IMPORT,
            imp: {
                path: path,
            },
        }
        append(imports, &&decl)
    }
    while p.tok != token.EOF {
        append(decls, declaration(p, true))
    }
    var file = ast.File{
        filename: p.file.name,
        name: name,
        decls: decls,
        imports: imports,
    }
    return &&file
}

fun parseFile(fset *token.FileSet, filename *const char) *ast.File {
    var src = ioutil.readFile(filename, nil)
    var p = parser.Parser{}
    parser.init(&p, fset, filename, src)
    p.c_mode = true
    var file = _parseFile(&p)
    runtime.free(src)
    return file
}
