package cemitter

import "bling/ast"
import "bling/emitter"
import "bling/token"
import "bling/types"
import "sys"
import "utils"

fun emitExpr(e *emitter.Emitter, expr *ast.Expr) {
    if !expr {
        panic("cemitter$emitExpr: expr is NULL")
    }
    switch expr.kind {
    case ast.EXPR_BASIC_LIT:
        emitter.emitString(e, expr.basic.value)
        break
    case ast.EXPR_BINARY:
        emitExpr(e, expr.binary.x)
        emitter.emitSpace(e)
        emitter.emitToken(e, expr.binary.op)
        emitter.emitSpace(e)
        emitExpr(e, expr.binary.y)
        break
    case ast.EXPR_CALL:
        emitExpr(e, expr.call.func)
        emitter.emitToken(e, token.LPAREN)
        for var args **ast.Expr = expr.call.args; args && *args; {
            emitExpr(e, *args)
            args++
            if *args {
                emitter.emitToken(e, token.COMMA)
                emitter.emitSpace(e)
            }
        }
        emitter.emitToken(e, token.RPAREN)
        break
    case ast.EXPR_CAST:
        emitter.emitToken(e, token.LPAREN)
        emitType(e, expr.cast.type, NULL)
        emitter.emitToken(e, token.RPAREN)
        emitExpr(e, expr.cast.expr)
        break
    case ast.EXPR_COMPOSITE_LIT:
        emitter.emitToken(e, token.LBRACE)
        emitter.emitNewline(e)
        e.indent++
        for var exprs **ast.Expr = expr.composite.list; exprs && *exprs; exprs++ {
            emitter.emitTabs(e)
            emitExpr(e, *exprs)
            emitter.emitToken(e, token.COMMA)
            emitter.emitNewline(e)
        }
        e.indent--
        emitter.emitTabs(e)
        emitter.emitToken(e, token.RBRACE)
        break
    case ast.EXPR_IDENT:
        var obj *ast.Object = expr.ident.obj
        if obj {
            var scope *ast.Scope = obj.scope
            if scope {
                var pkg *char = scope.pkg
                if pkg && !streq(pkg, "main") {
                    emitter.emitString(e, pkg)
                    emitter.emitToken(e, token.DOLLAR)
                }
            }
        }
        emitter.emitString(e, expr.ident.name)
        break
    case ast.EXPR_INDEX:
        emitExpr(e, expr.index.x)
        emitter.emitToken(e, token.LBRACK)
        emitExpr(e, expr.index.index)
        emitter.emitToken(e, token.RBRACK)
        break
    case ast.EXPR_KEY_VALUE:
        if expr.key_value.isArray {
            emitter.emitToken(e, token.LBRACK)
            emitExpr(e, expr.key_value.key)
            emitter.emitToken(e, token.RBRACK)
        } else {
            emitter.emitToken(e, token.PERIOD)
            emitExpr(e, expr.key_value.key)
        }
        emitter.emitSpace(e)
        emitter.emitToken(e, token.ASSIGN)
        emitter.emitSpace(e)
        emitExpr(e, expr.key_value.value)
        break
    case ast.EXPR_PAREN:
        emitter.emitToken(e, token.LPAREN)
        emitExpr(e, expr.paren.x)
        emitter.emitToken(e, token.RPAREN)
        break
    case ast.EXPR_SELECTOR:
        if expr.selector.tok != token.DOLLAR {
            emitExpr(e, expr.selector.x)
            emitter.emitToken(e, expr.selector.tok)
        }
        emitExpr(e, expr.selector.sel)
        break
    case ast.EXPR_SIZEOF:
        emitter.emitToken(e, token.SIZEOF)
        emitter.emitToken(e, token.LPAREN)
        emitType(e, expr.sizeof_.x, NULL)
        emitter.emitToken(e, token.RPAREN)
        break
    case ast.EXPR_STAR:
        emitter.emitToken(e, token.MUL)
        emitExpr(e, expr.star.x)
        break
    case ast.EXPR_TERNARY:
        emitExpr(e, expr.ternary.cond)
        emitter.emitSpace(e)
        emitter.emitToken(e, token.QUESTION_MARK)
        if expr.ternary.x {
            emitter.emitSpace(e)
            emitExpr(e, expr.ternary.x)
            emitter.emitSpace(e)
        }
        emitter.emitToken(e, token.COLON)
        emitter.emitSpace(e)
        emitExpr(e, expr.ternary.y)
        break
    case ast.EXPR_UNARY:
        emitter.emitToken(e, expr.unary.op)
        emitExpr(e, expr.unary.x)
        break
    default:
        panic(sys.sprintf("Unknown expr: %d", expr.kind))
        break
    }
}

fun emitStmt(e *emitter.Emitter, stmt *ast.Stmt) {
    switch stmt.kind {
    case ast.STMT_ASSIGN:
        emitExpr(e, stmt.assign.x)
        emitter.emitSpace(e)
        emitter.emitToken(e, stmt.assign.op)
        emitter.emitSpace(e)
        emitExpr(e, stmt.assign.y)
        emitter.emitToken(e, token.SEMICOLON)
        break
    case ast.STMT_BLOCK:
        emitter.emitToken(e, token.LBRACE)
        emitter.emitNewline(e)
        e.indent++
        for var stmts **ast.Stmt = stmt.block.stmts; stmts && *stmts; stmts++ {
            switch (*stmts).kind {
            case ast.STMT_LABEL:
                break
            default:
                emitter.emitTabs(e)
                break
            }
            emitStmt(e, *stmts)
            emitter.emitNewline(e)
        }
        e.indent--
        emitter.emitTabs(e)
        emitter.emitToken(e, token.RBRACE)
        break
    case ast.STMT_CASE:
        if stmt.case_.exprs && *stmt.case_.exprs {
            for var i int = 0; stmt.case_.exprs[i]; i++ {
                if i > 0 {
                    emitter.emitToken(e, token.COLON)
                    emitter.emitNewline(e)
                    emitter.emitTabs(e)
                }
                emitter.emitToken(e, token.CASE)
                emitter.emitSpace(e)
                emitExpr(e, stmt.case_.exprs[i])
            }
        } else {
            emitter.emitToken(e, token.DEFAULT)
        }
        emitter.emitToken(e, token.COLON)
        emitter.emitNewline(e)
        e.indent++
        for var stmts **ast.Stmt = stmt.case_.stmts; stmts && *stmts; stmts++ {
            emitter.emitTabs(e)
            emitStmt(e, *stmts)
            emitter.emitNewline(e)
        }
        e.indent--
        break
    case ast.STMT_DECL:
        emitDecl(e, stmt.decl.decl)
        break
    case ast.STMT_EMPTY:
        emitter.emitToken(e, token.SEMICOLON)
        break
    case ast.STMT_EXPR:
        emitExpr(e, stmt.expr.x)
        emitter.emitToken(e, token.SEMICOLON)
        break
    case ast.STMT_IF:
        emitter.emitToken(e, token.IF)
        emitter.emitSpace(e)
        emitter.emitToken(e, token.LPAREN)
        emitExpr(e, stmt.if_.cond)
        emitter.emitToken(e, token.RPAREN)
        emitter.emitSpace(e)
        emitStmt(e, stmt.if_.body)
        if stmt.if_.else_ {
            emitter.emitSpace(e)
            emitter.emitToken(e, token.ELSE)
            emitter.emitSpace(e)
            emitStmt(e, stmt.if_.else_)
        }
        break
    case ast.STMT_ITER:
        emitter.emitToken(e, stmt.iter.kind)
        emitter.emitSpace(e)
        emitter.emitToken(e, token.LPAREN)
        if stmt.iter.kind == token.FOR {
            if stmt.iter.init {
                emitStmt(e, stmt.iter.init)
                emitter.emitSpace(e)
            } else {
                emitter.emitToken(e, token.SEMICOLON)
                emitter.emitSpace(e)
            }
        }
        if stmt.iter.cond {
            emitExpr(e, stmt.iter.cond)
        }
        if stmt.iter.kind == token.FOR {
            emitter.emitToken(e, token.SEMICOLON)
            emitter.emitSpace(e)
            if stmt.iter.post {
                e.skipSemi = true
                emitStmt(e, stmt.iter.post)
                e.skipSemi = false
            }
        }
        emitter.emitToken(e, token.RPAREN)
        emitter.emitSpace(e)
        emitStmt(e, stmt.iter.body)
        break
    case ast.STMT_JUMP:
        emitter.emitToken(e, stmt.jump.keyword)
        if stmt.jump.label {
            emitter.emitSpace(e)
            emitExpr(e, stmt.jump.label)
        }
        emitter.emitToken(e, token.SEMICOLON)
        break
    case ast.STMT_LABEL:
        emitExpr(e, stmt.label.label)
        emitter.emitToken(e, token.COLON)
        emitter.emitNewline(e)
        emitter.emitTabs(e)
        emitStmt(e, stmt.label.stmt)
        break
    case ast.STMT_POSTFIX:
        emitExpr(e, stmt.postfix.x)
        emitter.emitToken(e, stmt.postfix.op)
        emitter.emitToken(e, token.SEMICOLON)
        break
    case ast.STMT_RETURN:
        emitter.emitToken(e, token.RETURN)
        if stmt.return_.x {
            emitter.emitSpace(e)
            emitExpr(e, stmt.return_.x)
        }
        emitter.emitToken(e, token.SEMICOLON)
        break
    case ast.STMT_SWITCH:
        emitter.emitToken(e, token.SWITCH)
        emitter.emitSpace(e)
        emitter.emitToken(e, token.LPAREN)
        emitExpr(e, stmt.switch_.tag)
        emitter.emitToken(e, token.RPAREN)
        emitter.emitSpace(e)
        emitter.emitToken(e, token.LBRACE)
        emitter.emitNewline(e)
        for var stmts **ast.Stmt = stmt.switch_.stmts; stmts && *stmts; stmts++ {
            emitter.emitTabs(e)
            emitStmt(e, *stmts)
        }
        emitter.emitTabs(e)
        emitter.emitToken(e, token.RBRACE)
        break
    default:
        panic("Unknown stmt")
        break
    }
}

fun emitType(e *emitter.Emitter, type *ast.Expr, name *ast.Expr) {
    if type == NULL {
        panic("cemitter$emitType: type is nil")
    }
    if type.is_const && type.kind != ast.EXPR_STAR {
        emitter.emitToken(e, token.CONST)
        emitter.emitSpace(e)
    }
    switch type.kind {
    case ast.TYPE_ARRAY:
        emitType(e, type.array.elt, name)
        emitter.emitToken(e, token.LBRACK)
        if type.array.len {
            emitExpr(e, type.array.len)
        }
        emitter.emitToken(e, token.RBRACK)
        name = NULL
        break
    case ast.TYPE_FUNC:
        if type.func.result != NULL {
            emitType(e, type.func.result, name)
        } else {
            emitter.emitString(e, "void")
            emitter.emitSpace(e)
            emitExpr(e, name)
        }
        emitter.emitToken(e, token.LPAREN)
        for var params **ast.Decl = type.func.params; params && *params; {
            emitDecl(e, *params)
            params++
            if *params != NULL {
                emitter.emitToken(e, token.COMMA)
                emitter.emitSpace(e)
            }
        }
        emitter.emitToken(e, token.RPAREN)
        name = NULL
        break
    case ast.TYPE_ELLIPSIS:
        emitter.emitToken(e, token.ELLIPSIS)
        break
    case ast.TYPE_ENUM:
        emitter.emitToken(e, token.ENUM)
        if type.enum_.name {
            emitter.emitSpace(e)
            emitExpr(e, type.enum_.name)
        }
        if !e.forwardDecl && type.enum_.enums {
            emitter.emitSpace(e)
            emitter.emitToken(e, token.LBRACE)
            emitter.emitNewline(e)
            e.indent++
            for var enums **ast.Decl = type.enum_.enums; enums && *enums; enums++ {
                var decl *ast.Decl = *enums
                emitter.emitTabs(e)
                emitExpr(e, decl.value.name)
                if decl.value.value {
                    emitter.emitSpace(e)
                    emitter.emitToken(e, token.ASSIGN)
                    emitter.emitSpace(e)
                    emitExpr(e, decl.value.value)
                }
                emitter.emitToken(e, token.COMMA)
                emitter.emitNewline(e)
            }
            e.indent--
            emitter.emitTabs(e)
            emitter.emitToken(e, token.RBRACE)
        }
        break
    case ast.EXPR_STAR:
        type = type.star.x
        if type.kind == ast.TYPE_FUNC {
            emitType(e, type.func.result, NULL)
            emitter.emitToken(e, token.LPAREN)
            emitter.emitToken(e, token.MUL)
            if name != NULL {
                emitExpr(e, name)
            }
            emitter.emitToken(e, token.RPAREN)
            emitter.emitToken(e, token.LPAREN)
            for var params **ast.Decl = type.func.params; params && *params; {
                emitDecl(e, *params)
                params++
                if *params != NULL {
                    emitter.emitToken(e, token.COMMA)
                    emitter.emitSpace(e)
                }
            }
            emitter.emitToken(e, token.RPAREN)
            name = NULL
        } else {
            emitType(e, type, NULL)
            emitter.emitToken(e, token.MUL)
        }
        break
    case ast.TYPE_STRUCT:
        emitter.emitToken(e, type.struct_.tok)
        if type.struct_.name {
            emitter.emitSpace(e)
            emitExpr(e, type.struct_.name)
        }
        if !e.forwardDecl && type.struct_.fields {
            emitter.emitSpace(e)
            emitter.emitToken(e, token.LBRACE)
            emitter.emitNewline(e)
            e.indent++
            for var fields **ast.Decl = type.struct_.fields; fields && *fields; fields++ {
                emitter.emitTabs(e)
                emitDecl(e, *fields)
                emitter.emitToken(e, token.SEMICOLON)
                emitter.emitNewline(e)
            }
            e.indent--
            emitter.emitTabs(e)
            emitter.emitToken(e, token.RBRACE)
        }
        break
    case ast.EXPR_IDENT:
        emitExpr(e, type)
        break
    case ast.EXPR_SELECTOR:
        emitExpr(e, type.selector.sel)
        break
    default:
        panic(sys.sprintf("Unknown type: %d", type.kind))
    }
    if type.is_const && type.kind == ast.EXPR_STAR {
        emitter.emitSpace(e)
        emitter.emitToken(e, token.CONST)
    }
    if name {
        emitter.emitSpace(e)
        emitExpr(e, name)
    }
}

fun emitDecl(e *emitter.Emitter, decl *ast.Decl) {
    switch decl.kind {
    case ast.DECL_FIELD:
        emitType(e, decl.field.type, decl.field.name)
        break
    case ast.DECL_FUNC:
        emitType(e, decl.func.type, decl.func.name)
        if !e.forwardDecl && decl.func.body {
            emitter.emitSpace(e)
            emitStmt(e, decl.func.body)
        } else {
            emitter.emitToken(e, token.SEMICOLON)
        }
        break
    case ast.DECL_PRAGMA:
        emitter.emitString(e, "//")
        emitter.emitToken(e, token.HASH)
        emitter.emitString(e, decl.pragma.lit)
        break
    case ast.DECL_TYPEDEF:
        emitter.emitToken(e, token.TYPEDEF)
        emitter.emitSpace(e)
        emitType(e, decl.typedef_.type, decl.typedef_.name)
        emitter.emitToken(e, token.SEMICOLON)
        break
    case ast.DECL_VALUE:
        if e.forwardDecl {
            var isPublic bool = true
            switch decl.value.type.kind {
            case ast.TYPE_ARRAY, ast.TYPE_STRUCT:
                isPublic = false
                break
            default:
                break
            }
            if !isPublic {
                break
            }
        }
        if e.forwardDecl && decl.value.value {
            emitter.emitToken(e, token.EXTERN)
            emitter.emitSpace(e)
        }
        emitType(e, decl.value.type, decl.value.name)
        if !e.forwardDecl && decl.value.value {
            emitter.emitSpace(e)
            emitter.emitToken(e, token.ASSIGN)
            emitter.emitSpace(e)
            emitExpr(e, decl.value.value)
        }
        emitter.emitToken(e, token.SEMICOLON)
        break
    default:
        panic("Unknown decl")
        break
    }
}

fun emitFile(e *emitter.Emitter, file *ast.File) {
    emitter.emitString(e, "//")
    emitter.emitString(e, file.filename)
    emitter.emitNewline(e)
    emitter.emitNewline(e)
    if file.name != NULL {
        emitter.emitToken(e, token.PACKAGE)
        emitter.emitToken(e, token.LPAREN)
        emitExpr(e, file.name)
        emitter.emitToken(e, token.RPAREN)
        emitter.emitToken(e, token.SEMICOLON)
        emitter.emitNewline(e)
    }
    for var i int = 0; file.decls[i]; i++ {
        emitter.emitNewline(e)
        emitDecl(e, file.decls[i])
        emitter.emitNewline(e)
    }
}

fun emitObjects(e *emitter.Emitter, scope *ast.Scope, kind ast.ObjKind) {
    var key *char = NULL
    var obj *ast.Object = NULL
    for var i int = 0; i < utils.Slice_len(&scope.keys); i++ {
        utils.Slice_get(&scope.keys, i, &key)
        utils.Map_get(&scope.objects, key, &obj)
        if obj.kind == kind {
            emitter.emitNewline(e)
            emitDecl(e, obj.decl)
            emitter.emitNewline(e)
        }
    }
}

fun emitScope(e *emitter.Emitter, scope *ast.Scope) {
    emitObjects(e, scope, ast.ObjKind_TYP)
    emitObjects(e, scope, ast.ObjKind_VAL)
    emitObjects(e, scope, ast.ObjKind_FUN)
}

fun _emitPackage(e *emitter.Emitter, done *utils.Map, pkg *types.Package) {
    if utils.Map_has_key(done, pkg.path) {
        return
    }
    utils.Map_set(done, pkg.path, &pkg.path)
    for var i int = 0; i < utils.Slice_len(&pkg.imports); i++ {
        var impt *types.Package = NULL
        utils.Slice_get(&pkg.imports, i, &impt)
        _emitPackage(e, done, impt)
    }
    e.forwardDecl = true
    emitScope(e, pkg.scope)
    e.forwardDecl = false
    emitScope(e, pkg.scope)
}

fun emitPackage(e *emitter.Emitter, pkg *types.Package) {
    var done utils.Map = utils.Map_init(sizeof(*char))
    _emitPackage(e, &done, pkg)
    utils.Map_deinit(&done)
}

fun emitHeader(e *emitter.Emitter, pkg *types.Package) {
    var old bool = e.forwardDecl
    e.forwardDecl = true
    emitObjects(e, pkg.scope, ast.ObjKind_TYP)
    e.forwardDecl = false
    emitObjects(e, pkg.scope, ast.ObjKind_TYP)
    e.forwardDecl = true
    emitObjects(e, pkg.scope, ast.ObjKind_VAL)
    emitObjects(e, pkg.scope, ast.ObjKind_FUN)
    e.forwardDecl = old
}

fun emitBody(e *emitter.Emitter, pkg *types.Package) {
    var old bool = e.forwardDecl
    e.forwardDecl = false
    emitObjects(e, pkg.scope, ast.ObjKind_VAL)
    emitObjects(e, pkg.scope, ast.ObjKind_FUN)
    e.forwardDecl = old
}
