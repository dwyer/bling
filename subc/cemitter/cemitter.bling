package cemitter

import "C"
import "bling/ast"
import "bling/emitter"
import "bling/token"
import "bling/types"
import "runtime"

fun isSimpleType(type *ast.Expr) bool {
    for ;; {
        switch type.kind {
        case ast.TYPE_STRUCT:
            return false
        case ast.TYPE_ARRAY:
            type = type.array_.elt
            break
        default:
            return true
        }
    }
}

fun emitExpr(e *emitter.Emitter, expr *ast.Expr) {
    switch expr.kind {
    case ast.EXPR_BASIC_LIT:
        emitter.emitString(e, expr.basic.value)
        break
    case ast.EXPR_BINARY:
        emitExpr(e, expr.binary.x)
        emitter.emitSpace(e)
        emitter.emitToken(e, expr.binary.op)
        emitter.emitSpace(e)
        emitExpr(e, expr.binary.y)
        break
    case ast.EXPR_CALL:
        var recv *ast.Expr = nil
        var func = expr.call.func
        if func.kind == ast.EXPR_SELECTOR && func.selector.tok == token.FUNC {
            recv = func.selector.x
            func = func.selector.sel
        }
        emitExpr(e, expr.call.func)
        emitter.emitToken(e, token.LPAREN)
        if recv != nil {
            emitExpr(e, recv)
        }
        for var i = 0; i < len(expr.call.args); i++ {
            if i > 0 || recv != nil {
                emitter.emitToken(e, token.COMMA)
                emitter.emitSpace(e)
            }
            var arg = expr.call.args[i]
            if types.isType(arg) {
                emitType(e, arg, nil)
            } else {
                emitExpr(e, arg)
            }
        }
        emitter.emitToken(e, token.RPAREN)
        break
    case ast.EXPR_CAST:
        emitter.emitToken(e, token.LPAREN)
        emitType(e, expr.cast.type, nil)
        emitter.emitToken(e, token.RPAREN)
        emitExpr(e, expr.cast.expr)
        break
    case ast.EXPR_COMPOSITE_LIT:
        if isSimpleType(expr.composite.type) {
            emitter.emitToken(e, token.LPAREN)
            emitType(e, expr.composite.type, nil)
            emitter.emitToken(e, token.RPAREN)
        }
        emitter.emitToken(e, token.LBRACE)
        if len(expr.composite.list) > 0 {
            emitter.emitNewline(e)
            e.indent++
            for var i = 0; i < len(expr.composite.list); i++ {
                emitter.emitTabs(e)
                emitExpr(e, expr.composite.list[i])
                emitter.emitToken(e, token.COMMA)
                emitter.emitNewline(e)
            }
            e.indent--
            emitter.emitTabs(e)
        }
        emitter.emitToken(e, token.RBRACE)
        break
    case ast.EXPR_IDENT:
        if expr.ident.obj == nil {
            // C.printf("warning: not resolved: %s\n", expr.ident.name)
        }
        if expr.ident.obj && expr.ident.obj.scope && expr.ident.obj.scope.pkgName {
            if !runtime.streq(expr.ident.obj.scope.pkgName.ident.name, "main") {
                emitExpr(e, expr.ident.obj.scope.pkgName)
                emitter.emitToken(e, token.DOLLAR)
            }
        }
        emitter.emitString(e, expr.ident.name)
        break
    case ast.EXPR_INDEX:
        var t = types.baseType(types.exprType(expr.index.x))
        if types.isDynamicArray(t) {
            emitter.emitToken(e, token.GET)
            emitter.emitToken(e, token.LPAREN)
            emitType(e, t.array_.elt, nil)
            emitter.emitToken(e, token.COMMA)
            emitExpr(e, expr.index.x)
            emitter.emitToken(e, token.COMMA)
            emitExpr(e, expr.index.index)
            emitter.emitToken(e, token.RPAREN)
        } else {
            emitExpr(e, expr.index.x)
            emitter.emitToken(e, token.LBRACK)
            emitExpr(e, expr.index.index)
            emitter.emitToken(e, token.RBRACK)
        }
        break
    case ast.EXPR_KEY_VALUE:
        if expr.key_value.isArray {
            emitter.emitToken(e, token.LBRACK)
            emitExpr(e, expr.key_value.key)
            emitter.emitToken(e, token.RBRACK)
        } else {
            emitter.emitToken(e, token.PERIOD)
            emitExpr(e, expr.key_value.key)
        }
        emitter.emitSpace(e)
        emitter.emitToken(e, token.ASSIGN)
        emitter.emitSpace(e)
        emitExpr(e, expr.key_value.value)
        break
    case ast.EXPR_PAREN:
        emitter.emitToken(e, token.LPAREN)
        emitExpr(e, expr.paren.x)
        emitter.emitToken(e, token.RPAREN)
        break
    case ast.EXPR_SELECTOR:
        switch expr.selector.tok {
        case token.ARROW, token.PERIOD:
            emitExpr(e, expr.selector.x)
            emitter.emitToken(e, expr.selector.tok)
            break
        default:
            break
        }
        emitExpr(e, expr.selector.sel)
        break
    case ast.EXPR_STAR:
        emitter.emitToken(e, token.MUL)
        emitExpr(e, expr.star.x)
        break
    case ast.EXPR_TERNARY:
        emitExpr(e, expr.ternary.cond)
        emitter.emitSpace(e)
        emitter.emitToken(e, token.QUESTION_MARK)
        if expr.ternary.x {
            emitter.emitSpace(e)
            emitExpr(e, expr.ternary.x)
            emitter.emitSpace(e)
        }
        emitter.emitToken(e, token.COLON)
        emitter.emitSpace(e)
        emitExpr(e, expr.ternary.y)
        break
    case ast.EXPR_UNARY:
        if expr.unary.op == token.LAND {
            emitter.emitString(e, "$$ESC")
            emitter.emitToken(e, token.LPAREN)
        } else if expr.unary.op == token.SIZEOF {
            emitter.emitToken(e, token.SIZEOF)
            emitter.emitToken(e, token.LPAREN)
            emitType(e, expr.unary.x, nil)
            emitter.emitToken(e, token.RPAREN)
        } else {
            emitter.emitToken(e, expr.unary.op)
        }
        emitExpr(e, expr.unary.x)
        if expr.unary.op == token.LAND {
            emitter.emitToken(e, token.RPAREN)
        }
        break
    default:
        panic(C.sprintf("Unknown expr: %d", expr.kind))
        break
    }
}

fun emitStmt(e *emitter.Emitter, stmt *ast.Stmt) {
    switch stmt.kind {
    case ast.STMT_ASSIGN:
        emitExpr(e, stmt.assign.x)
        emitter.emitSpace(e)
        emitter.emitToken(e, stmt.assign.op)
        emitter.emitSpace(e)
        emitExpr(e, stmt.assign.y)
        emitter.emitToken(e, token.SEMICOLON)
        break
    case ast.STMT_BLOCK:
        emitter.emitToken(e, token.LBRACE)
        emitter.emitNewline(e)
        e.indent++
        for var i = 0; i < len(stmt.block.stmts); i++ {
            switch stmt.block.stmts[i].kind {
            case ast.STMT_LABEL:
                break
            default:
                emitter.emitTabs(e)
                break
            }
            emitStmt(e, stmt.block.stmts[i])
            emitter.emitNewline(e)
        }
        e.indent--
        emitter.emitTabs(e)
        emitter.emitToken(e, token.RBRACE)
        break
    case ast.STMT_CASE:
        if len(stmt.case_.exprs) > 0 {
            for var i = 0; i < len(stmt.case_.exprs); i++ {
                if i > 0 {
                    emitter.emitToken(e, token.COLON)
                    emitter.emitNewline(e)
                    emitter.emitTabs(e)
                }
                emitter.emitToken(e, token.CASE)
                emitter.emitSpace(e)
                emitExpr(e, stmt.case_.exprs[i])
            }
        } else {
            emitter.emitToken(e, token.DEFAULT)
        }
        emitter.emitToken(e, token.COLON)
        emitter.emitSpace(e)
        emitter.emitToken(e, token.LBRACE)
        emitter.emitNewline(e)
        e.indent++
        for var i = 0; i < len(stmt.case_.stmts); i++ {
            emitter.emitTabs(e)
            emitStmt(e, stmt.case_.stmts[i])
            emitter.emitNewline(e)
        }
        e.indent--
        emitter.emitTabs(e)
        emitter.emitToken(e, token.RBRACE)
        emitter.emitNewline(e)
        break
    case ast.STMT_DECL:
        emitDecl(e, stmt.decl.decl)
        break
    case ast.STMT_EMPTY:
        emitter.emitToken(e, token.SEMICOLON)
        break
    case ast.STMT_EXPR:
        emitExpr(e, stmt.expr.x)
        emitter.emitToken(e, token.SEMICOLON)
        break
    case ast.STMT_IF:
        if stmt.if_.init {
            emitter.emitToken(e, token.LBRACE)
            emitter.emitNewline(e)
            e.indent++
            emitter.emitTabs(e)
            emitStmt(e, stmt.if_.init)
            emitter.emitNewline(e)
            emitter.emitTabs(e)
        }
        emitter.emitToken(e, token.IF)
        emitter.emitSpace(e)
        emitter.emitToken(e, token.LPAREN)
        emitExpr(e, stmt.if_.cond)
        emitter.emitToken(e, token.RPAREN)
        emitter.emitSpace(e)
        emitStmt(e, stmt.if_.body)
        if stmt.if_.else_ {
            emitter.emitSpace(e)
            emitter.emitToken(e, token.ELSE)
            emitter.emitSpace(e)
            emitStmt(e, stmt.if_.else_)
        }
        if stmt.if_.init {
            emitter.emitNewline(e)
            e.indent--
            emitter.emitTabs(e)
            emitter.emitToken(e, token.RBRACE)
        }
        break
    case ast.STMT_ITER:
        emitter.emitToken(e, stmt.iter.kind)
        emitter.emitSpace(e)
        emitter.emitToken(e, token.LPAREN)
        if stmt.iter.kind == token.FOR {
            if stmt.iter.init {
                emitStmt(e, stmt.iter.init)
                emitter.emitSpace(e)
            } else {
                emitter.emitToken(e, token.SEMICOLON)
                emitter.emitSpace(e)
            }
        }
        if stmt.iter.cond {
            emitExpr(e, stmt.iter.cond)
        }
        if stmt.iter.kind == token.FOR {
            emitter.emitToken(e, token.SEMICOLON)
            emitter.emitSpace(e)
            if stmt.iter.post {
                e.skipSemi = true
                emitStmt(e, stmt.iter.post)
                e.skipSemi = false
            }
        }
        emitter.emitToken(e, token.RPAREN)
        emitter.emitSpace(e)
        emitStmt(e, stmt.iter.body)
        break
    case ast.STMT_JUMP:
        emitter.emitToken(e, stmt.jump.keyword)
        if stmt.jump.label {
            emitter.emitSpace(e)
            emitExpr(e, stmt.jump.label)
        }
        emitter.emitToken(e, token.SEMICOLON)
        break
    case ast.STMT_LABEL:
        emitExpr(e, stmt.label.label)
        emitter.emitToken(e, token.COLON)
        emitter.emitNewline(e)
        emitter.emitTabs(e)
        emitStmt(e, stmt.label.stmt)
        break
    case ast.STMT_POSTFIX:
        emitExpr(e, stmt.postfix.x)
        emitter.emitToken(e, stmt.postfix.op)
        emitter.emitToken(e, token.SEMICOLON)
        break
    case ast.STMT_RETURN:
        emitter.emitToken(e, token.RETURN)
        if stmt.return_.x {
            emitter.emitSpace(e)
            emitExpr(e, stmt.return_.x)
        }
        emitter.emitToken(e, token.SEMICOLON)
        break
    case ast.STMT_SWITCH:
        emitter.emitToken(e, token.SWITCH)
        emitter.emitSpace(e)
        emitter.emitToken(e, token.LPAREN)
        emitExpr(e, stmt.switch_.tag)
        emitter.emitToken(e, token.RPAREN)
        emitter.emitSpace(e)
        emitter.emitToken(e, token.LBRACE)
        emitter.emitNewline(e)
        for var i = 0; i < len(stmt.switch_.stmts); i++ {
            emitter.emitTabs(e)
            emitStmt(e, stmt.switch_.stmts[i])
        }
        emitter.emitTabs(e)
        emitter.emitToken(e, token.RBRACE)
        break
    default:
        panic("Unknown stmt")
        break
    }
}

fun _emitFields(e *emitter.Emitter, fields []*ast.Decl) {
    for var i = 0; i < len(fields); i++ {
        var field = fields[i]
        if field.field.name || field.field.type.kind == ast.TYPE_STRUCT {
            emitter.emitTabs(e)
            emitDecl(e, field)
            emitter.emitToken(e, token.SEMICOLON)
            emitter.emitNewline(e)
        } else {
            var base = types.baseType(field.field.type)
            _emitFields(e, base.struct_.fields)
        }
    }
}

fun emitFuncType(e *emitter.Emitter, type *ast.Expr, name *ast.Expr, recv *ast.Decl) {
    if type.func.result != nil {
        emitType(e, type.func.result, name)
    } else {
        emitter.emitString(e, "void")
        emitter.emitSpace(e)
        emitExpr(e, name)
    }
    emitter.emitToken(e, token.LPAREN)
    if recv != nil {
        emitDecl(e, recv)
    }
    for var i = 0; i < len(type.func.params); i++ {
        if i > 0 || recv != nil {
            emitter.emitToken(e, token.COMMA)
            emitter.emitSpace(e)
        }
        emitDecl(e, type.func.params[i])
    }
    emitter.emitToken(e, token.RPAREN)
}

fun emitType(e *emitter.Emitter, type *ast.Expr, name *ast.Expr) {
    if type == nil {
        panic("type is nil")
    }
    switch type.kind {
    case ast.EXPR_IDENT:
        emitExpr(e, type)
        break
    case ast.EXPR_SELECTOR:
        emitExpr(e, type.selector.sel) // XXX
        break
    case ast.EXPR_STAR:
        var base = type.star.x
        if base.kind == ast.TYPE_FUNC {
            emitType(e, base.func.result, nil)
            emitter.emitToken(e, token.LPAREN)
            emitter.emitToken(e, token.MUL)
            if name != nil {
                emitExpr(e, name)
            }
            emitter.emitToken(e, token.RPAREN)
            emitter.emitToken(e, token.LPAREN)
            for var i = 0; i < len(base.func.params); i++ {
                if i > 0 {
                    emitter.emitToken(e, token.COMMA)
                    emitter.emitSpace(e)
                }
                emitDecl(e, base.func.params[i])
            }
            emitter.emitToken(e, token.RPAREN)
            name = nil
        } else {
            emitType(e, base, nil)
            emitter.emitToken(e, token.MUL)
        }
        break
    case ast.TYPE_ARRAY:
        if type.array_.dynamic {
            emitter.emitToken(e, token.ARRAY)
            emitter.emitToken(e, token.LPAREN)
            emitType(e, type.array_.elt, nil)
            emitter.emitToken(e, token.RPAREN)
        } else {
            emitType(e, type.array_.elt, name)
            emitter.emitToken(e, token.LBRACK)
            if type.array_.len {
                emitExpr(e, type.array_.len)
            }
            emitter.emitToken(e, token.RBRACK)
            name = nil
        }
        break
    case ast.TYPE_ELLIPSIS:
        emitter.emitToken(e, token.ELLIPSIS)
        break
    case ast.TYPE_ENUM:
        emitter.emitToken(e, token.ENUM)
        if type.enum_.name {
            emitter.emitSpace(e)
            emitExpr(e, type.enum_.name)
        }
        if !e.forwardDecl && len(type.enum_.enums) > 0 {
            emitter.emitSpace(e)
            emitter.emitToken(e, token.LBRACE)
            emitter.emitNewline(e)
            e.indent++
            for var i = 0; i < len(type.enum_.enums); i++ {
                var decl = type.enum_.enums[i]
                emitter.emitTabs(e)
                emitExpr(e, decl.value.name)
                if decl.value.value {
                    emitter.emitSpace(e)
                    emitter.emitToken(e, token.ASSIGN)
                    emitter.emitSpace(e)
                    emitExpr(e, decl.value.value)
                }
                emitter.emitToken(e, token.COMMA)
                emitter.emitNewline(e)
            }
            e.indent--
            emitter.emitTabs(e)
            emitter.emitToken(e, token.RBRACE)
        }
        break
    case ast.TYPE_FUNC:
        emitFuncType(e, type, name, nil)
        name = nil
        break
    case ast.TYPE_MAP:
        emitter.emitToken(e, token.MAP)
        emitter.emitToken(e, token.LPAREN)
        emitExpr(e, type.map_.val)
        emitter.emitToken(e, token.RPAREN)
        break
    case ast.TYPE_STRUCT:
        emitter.emitToken(e, type.struct_.tok)
        if type.struct_.name {
            emitter.emitSpace(e)
            emitExpr(e, type.struct_.name)
        }
        if !e.forwardDecl && len(type.struct_.fields) > 0 {
            emitter.emitSpace(e)
            emitter.emitToken(e, token.LBRACE)
            emitter.emitNewline(e)
            e.indent++
            _emitFields(e, type.struct_.fields)
            e.indent--
            emitter.emitTabs(e)
            emitter.emitToken(e, token.RBRACE)
        }
        break
    default:
        panic(C.sprintf("Unknown type: %d", type.kind))
    }
    if type.is_const {
        emitter.emitSpace(e)
        emitter.emitToken(e, token.CONST)
    }
    if name {
        emitter.emitSpace(e)
        emitExpr(e, name)
    }
}

fun emitDecl(e *emitter.Emitter, decl *ast.Decl) {
    switch decl.kind {
    case ast.DECL_FIELD:
        emitType(e, decl.field.type, decl.field.name)
        break
    case ast.DECL_FUNC:
        emitFuncType(e, decl.func.type, decl.func.name, decl.func.recv)
        if !e.forwardDecl && decl.func.body {
            emitter.emitSpace(e)
            emitStmt(e, decl.func.body)
        } else {
            emitter.emitToken(e, token.SEMICOLON)
        }
        break
    case ast.DECL_PRAGMA:
        emitter.emitString(e, "//")
        emitter.emitToken(e, token.HASH)
        emitter.emitString(e, decl.pragma.lit)
        break
    case ast.DECL_TYPE:
        emitter.emitToken(e, token.TYPEDEF)
        emitter.emitSpace(e)
        emitType(e, decl.type.type, decl.type.name)
        emitter.emitToken(e, token.SEMICOLON)
        break
    case ast.DECL_VALUE:
        if e.forwardDecl {
            var isPublic = true
            switch decl.value.type.kind {
            case ast.TYPE_ARRAY, ast.TYPE_STRUCT:
                isPublic = false
                break
            default:
                break
            }
            if !isPublic {
                break
            }
        }
        if e.forwardDecl && decl.value.value {
            emitter.emitToken(e, token.EXTERN)
            emitter.emitSpace(e)
        }
        emitType(e, decl.value.type, decl.value.name)
        if !e.forwardDecl && decl.value.value {
            emitter.emitSpace(e)
            emitter.emitToken(e, token.ASSIGN)
            emitter.emitSpace(e)
            emitExpr(e, decl.value.value)
        }
        emitter.emitToken(e, token.SEMICOLON)
        break
    default:
        panic("Unknown decl")
        break
    }
}

fun emitFile(e *emitter.Emitter, file *ast.File) {
    emitter.emitString(e, "//")
    emitter.emitString(e, file.filename)
    emitter.emitNewline(e)
    emitter.emitNewline(e)
    if file.name != nil {
        emitter.emitToken(e, token.PACKAGE)
        emitter.emitToken(e, token.LPAREN)
        emitExpr(e, file.name)
        emitter.emitToken(e, token.RPAREN)
        emitter.emitToken(e, token.SEMICOLON)
        emitter.emitNewline(e)
    }
    for var i = 0; len(file.decls); i++ {
        emitter.emitNewline(e)
        emitDecl(e, file.decls[i])
        emitter.emitNewline(e)
    }
}

fun emitObjects(e *emitter.Emitter, scope *ast.Scope, kind ast.ObjKind) {
    var obj *ast.Object = nil
    for var i = 0; i < len(scope.keys); i++ {
        runtime.Map_get(&scope.objects, scope.keys[i], &obj)
        if obj.kind == kind {
            emitter.emitNewline(e)
            emitDecl(e, obj.decl)
            emitter.emitNewline(e)
        }
        if kind == ast.ObjKind_FUN && obj.kind == ast.ObjKind_TYP {
            if var scope *ast.Scope = obj.data; scope {
                emitObjects(e, scope, kind)
            }
        }
    }
}

fun emitScope(e *emitter.Emitter, scope *ast.Scope) {
    emitObjects(e, scope, ast.ObjKind_TYP)
    emitObjects(e, scope, ast.ObjKind_VAL)
    emitObjects(e, scope, ast.ObjKind_FUN)
}

fun _emitPackage(e *emitter.Emitter, done *map string, pkg *types.Package) {
    if runtime.Map_get(done, pkg.path, nil) {
        return
    }
    runtime.Map_set(done, pkg.path, &pkg.path)
    for var i = 0; i < len(pkg.imports); i++ {
        _emitPackage(e, done, pkg.imports[i])
    }
    e.forwardDecl = true
    emitScope(e, pkg.scope)
    e.forwardDecl = false
    emitScope(e, pkg.scope)
}

fun emitPackage(e *emitter.Emitter, pkg *types.Package) {
    var done = makemap(string)
    _emitPackage(e, &done, pkg)
    delete(done)
}

fun emitHeader(e *emitter.Emitter, pkg *types.Package) {
    var old = e.forwardDecl
    e.forwardDecl = true
    emitObjects(e, pkg.scope, ast.ObjKind_TYP)
    e.forwardDecl = false
    emitObjects(e, pkg.scope, ast.ObjKind_TYP)
    e.forwardDecl = true
    emitObjects(e, pkg.scope, ast.ObjKind_VAL)
    emitObjects(e, pkg.scope, ast.ObjKind_FUN)
    e.forwardDecl = old
}

fun emitBody(e *emitter.Emitter, pkg *types.Package) {
    var old = e.forwardDecl
    e.forwardDecl = false
    emitObjects(e, pkg.scope, ast.ObjKind_VAL)
    emitObjects(e, pkg.scope, ast.ObjKind_FUN)
    e.forwardDecl = old
}
