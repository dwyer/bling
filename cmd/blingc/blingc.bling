package main

import "bling/ast"
import "bling/build"
import "bling/emitter"
import "bling/parser"
import "bling/token"
import "bling/types"
import "bytes"
import "io/ioutil"
import "os"
import "paths"
import "subc/cemitter"
import "subc/cparser"
import "sys"
import "utils"

fun emit_rawfile(e *emitter.Emitter, filename *const char) {
    var err *utils.Error = NULL
    var src *char = ioutil.readFile(filename, &err)
    if err {
        panic(err.error)
    }
    emitter.emitString(e, src)
    sys.free(src)
}

fun isForwardDecl(decl *ast.Decl) bool {
    switch decl.kind {
    case ast.DECL_FUNC:
        return decl.func.body == NULL
    case ast.DECL_PRAGMA:
        return true
    case ast.DECL_TYPEDEF:
        {
            switch decl.typedef_.type.kind {
            case ast.TYPE_STRUCT:
                return len(decl.typedef_.type.struct_.fields) == 0
            default:
                return false
            }
        }
    case ast.DECL_VALUE:
        return decl.value.value == NULL
    default:
        return false
    }
}

fun compile_c(argv []*char) {
    var dst *const char = NULL
    while **argv == '-' {
        if sys.streq(*argv, "-o") {
            argv++
            dst = *argv
        } else {
            panic(sys.sprintf("unknown option: %s", *argv))
        }
        argv++
    }
    var e emitter.Emitter = {}
    var fset *token.FileSet = token.newFileSet()
    while *argv {
        var filename *char = *argv
        var file *ast.File = cparser.parseFile(fset, filename, types.universe())
        var allowForward bool = file.name && ast.isIdentNamed(file.name, "sys")
        if !allowForward {
            var i int = 0
            for var j int = 0; j < len(file.decls); j++ {
                var d *ast.Decl = file.decls[j]
                if !isForwardDecl(d) {
                    utils.Slice_set(&file.decls, i, &d)
                    i++
                }
            }
            utils.Slice_setLen(&file.decls, i)
        }
        emitter.emitFile(&e, file)
        argv++
    }
    var out *char = emitter.Emitter_string(&e)
    var file *os.File = os.stdout
    var err *utils.Error = NULL
    if dst {
        file = os.create(dst, &err)
        if err {
            panic(err.error)
        }
    }
    os.write(file, out, &err)
    if err {
        panic(err.error)
    }
    if dst {
        os.close(file, &err)
        if err {
            panic(err.error)
        }
    }
}

fun compile_bling(argv []*char) {
    var err *utils.Error = NULL
    var conf types.Config = {
        strict: true,
    }
    var dst *char = NULL
    while **argv == '-' {
        if sys.streq(*argv, "-o") {
            argv++
            dst = *argv
        } else {
            panic(sys.sprintf("unknown option: %s", *argv))
        }
        argv++
    }
    if !*argv {
        return
    }
    var e emitter.Emitter = {}
    emit_rawfile(&e, "bootstrap/bootstrap.h")
    var fset *token.FileSet = token.newFileSet()
    var filename *char = *argv
    var file *ast.File = NULL
    if bytes.hasSuffix(filename, ".bling") {
        file = parser.parseFile(fset, filename, types.universe())
    } else if bytes.hasSuffix(filename, ".c") {
        file = cparser.parseFile(fset, filename, types.universe())
    } else {
        panic(sys.sprintf("unknown file type: %s", filename))
    }
    var pkg *types.Package = types.checkFile(&conf, paths.dir(filename), fset, file, NULL)
    cemitter.emitPackage(&e, pkg)
    argv++
    assert(!*argv)
    var out *char = emitter.Emitter_string(&e)
    if dst {
        if bytes.hasSuffix(dst, ".out") {
            var tmp *char = paths.join2(os.tempDir(), "tmp.c")
            ioutil.writeFile(tmp, out, 0644, NULL)
            var args []*char = {
                "/usr/bin/cc",
                "-o",
                dst,
                tmp,
                "bazel-bin/bootstrap/libbootstrap.a",
                "bazel-bin/os/libos.a",
                "bazel-bin/sys/libsys.a",
                NULL,
            }
            var code int = sys.run(args)
            if code != 0 {
                panic(sys.sprintf("- failed with code %d", code))
            }
        } else {
            ioutil.writeFile(dst, out, 0644, NULL)
        }
    } else {
        os.write(os.stdout, out, &err)
    }
}

fun main(argc int, argv []*char) int {
    var progname *char = *argv
    argv++
    if !*argv {
        panic(sys.sprintf("usage: %s -o DST SRCS", progname))
    }
    if sys.streq(*argv, "version") {
        print("0.0.0-alpha")
        return 0
    }
    if sys.streq(*argv, "build") {
        argv++
        build.buildPackage(argv)
        return 0
    }
    if sys.streq(*argv, "-c") {
        argv++
        compile_c(argv)
        return 0
    }
    compile_bling(argv)
    return 0
}
