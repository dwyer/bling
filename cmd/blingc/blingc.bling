package main

import "C"
import "bling/ast"
import "bling/build"
import "bling/emitter"
import "bling/parser"
import "bling/token"
import "bling/types"
import "bytes"
import "io/ioutil"
import "os"
import "paths"
import "runtime"
import "subc/cemitter"
import "subc/cparser"

fun emitRawFile(e *emitter.Emitter, filename runtime.charstr) {
    var err *runtime.Error = nil
    var src = ioutil.readFile(filename, &err)
    if err {
        panic(err.error)
    }
    emitter.emitBytes(e, src)
    runtime.Slice_unmake(&src)
}

fun isForwardDecl(decl *ast.Decl) bool {
    switch decl.kind {
    case ast.DECL_FUNC:
        return decl.func.body == nil
    case ast.DECL_PRAGMA:
        return true
    case ast.DECL_TYPE:
        switch decl.type.type.kind {
        case ast.TYPE_STRUCT:
            return len(decl.type.type.struct_.fields) == 0
        default:
            return false
        }
    case ast.DECL_VALUE:
        return decl.value.value == nil
    default:
        return false
    }
}

fun compileC(argv [?]runtime.charptr) {
    var dst runtime.charstr = nil
    while **argv == '-' {
        if runtime.streq(*argv, "-o") {
            argv++
            dst = *argv
        } else {
            panic(C.sprintf("unknown option: %s", *argv))
        }
        argv++
    }
    var e = emitter.Emitter{}
    var fset = token.newFileSet()
    while *argv {
        var filename = *argv
        var file = cparser.parseFile(fset, filename)
        var allowForward = file.name && ast.isIdentNamed(file.name, "C")
        if !allowForward {
            var i = 0
            for var j = 0; j < len(file.decls); j++ {
                var d = file.decls[j]
                if !isForwardDecl(d) {
                    file.decls[i] = d
                    i++
                }
            }
            runtime.Array_setLen(typ *runtime.Slice(&file.decls), sizeof(*ast.File), i)
        }
        emitter.emitFile(&e, file)
        argv++
    }
    var file = os.stdout
    var err *runtime.Error = nil
    if dst {
        file = os.create(dst, &err)
        if err {
            panic(err.error)
        }
    }
    file.write(e.bytes(), &err)
    if err {
        panic(err.error)
    }
    if dst {
        file.close(&err)
        if err {
            panic(err.error)
        }
    }
}

fun compileBling(argv [?]runtime.charptr) {
    var err *runtime.Error = nil
    var conf = types.Config{
        strict: true,
    }
    var dst runtime.charptr = nil
    while **argv == '-' {
        if runtime.streq(*argv, "-o") {
            argv++
            dst = *argv
        } else {
            panic(C.sprintf("unknown option: %s", *argv))
        }
        argv++
    }
    if !*argv {
        return
    }
    var e = emitter.Emitter{}
    emitRawFile(&e, "bootstrap/bootstrap.h")
    var fset = token.newFileSet()
    var filename = *argv
    var file *ast.File = nil
    if bytes.hasSuffix(filename, ".bling") {
        file = parser.parseFile(fset, filename)
    } else if bytes.hasSuffix(filename, ".c") {
        file = cparser.parseFile(fset, filename)
    } else {
        panic(C.sprintf("unknown file type: %s", filename))
    }
    var pkg = types.checkFile(&conf, paths.dir(filename), fset, file, nil)
    cemitter.emitPackage(&e, pkg)
    argv++
    assert(!*argv)
    if dst {
        if bytes.hasSuffix(dst, ".out") {
            var tmp = paths.join2(os.tempDir(), "tmp.c")
            ioutil.writeFile(tmp, e.bytes(), 0644, nil)
            var args = [?]runtime.charptr{
                "/usr/bin/cc",
                "-o",
                dst,
                tmp,
                "bazel-bin/bootstrap/libbootstrap.a",
                "bazel-bin/os/libos.a",
                "bazel-bin/sys/libsys.a",
                nil,
            }
            var code = os.exec(args, nil)
            if code != 0 {
                panic(C.sprintf("- failed with code %d", code))
            }
        } else {
            ioutil.writeFile(dst, e.bytes(), 0644, nil)
        }
    } else {
        os.stdout.write(e.bytes(), &err)
    }
}

fun buildPackage(argv [?]runtime.charptr) {
    assert(*argv)
    var builder = build.newBuilder(token.newFileSet())
    if runtime.streq(*argv, "-f") {
        builder.force = true
        argv++
    }
    assert(*argv)
    var path = *argv
    build.buildPackage(builder, path)
}

fun main(argc int, argv [?]runtime.charptr) int {
    var progname = *argv
    argv++
    if !*argv {
        panic(C.sprintf("usage: %s -o DST SRCS", progname))
    }
    if runtime.streq(*argv, "version") {
        print("0.0.0-alpha")
        return 0
    }
    if runtime.streq(*argv, "build") {
        argv++
        buildPackage(argv)
        return 0
    }
    if runtime.streq(*argv, "-c") {
        argv++
        compileC(argv)
        return 0
    }
    compileBling(argv)
    return 0
}
