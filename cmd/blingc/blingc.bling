package main

import "bling/ast"
import "bling/build"
import "bling/emitter"
import "bling/parser"
import "bling/token"
import "bling/types"
import "bytes"
import "io/ioutil"
import "os"
import "paths"
import "subc/cemitter"
import "subc/cparser"
import "sys"
import "utils"

fun emit_rawfile(e *emitter.Emitter, filename *const char) {
    var err *utils.Error = NULL
    var src *char = ioutil.readFile(filename, &err)
    if err {
        panic(err.error)
    }
    emitter.emitString(e, src)
    free(src)
}

fun isForwardDecl(decl *ast.Decl) bool {
    switch decl.kind {
    case ast.DECL_FUNC: return decl.func.body == NULL
    case ast.DECL_PRAGMA: return true
    case ast.DECL_TYPEDEF: {
        switch decl.typedef_.type.kind {
        case ast.TYPE_STRUCT: return decl.typedef_.type.struct_.fields == NULL || decl.typedef_.type.struct_.fields[0] == NULL
        default: return false
        }
    }
    case ast.DECL_VALUE: return decl.value.value == NULL
    default: return false
    }
}

fun compile_c(argv []*char) {
    var dst *const char = NULL
    while **argv == '-' {
        if streq(*argv, "-o") {
            argv++
            dst = *argv
        } else {
            panic(sys.sprintf("unknown option: %s", *argv))
        }
        argv++
    }
    var e emitter.Emitter = {}
    var fset *token.FileSet = token.newFileSet()
    while *argv {
        var filename *char = *argv
        var file *ast.File = cparser.parseFile(fset, filename, types.universe())
        var allowForward bool = file.name && (ast.isIdentNamed(file.name, "os") || ast.isIdentNamed(file.name, "sys"))
        if !allowForward {
            var i int = 0
            for var j int = 0; file.decls[j]; j++ {
                if !isForwardDecl(file.decls[j]) {
                    file.decls[i] = file.decls[j]
                    i++
                }
            }
            file.decls[i] = NULL
        }
        emitter.emitFile(&e, file)
        argv++
    }
    var out *char = emitter.Emitter_string(&e)
    var file *os.File = os.stdout
    var err *utils.Error = NULL
    if dst {
        file = os.create(dst, &err)
        if err {
            panic(err.error)
        }
    }
    os.write(file, out, &err)
    if err {
        panic(err.error)
    }
    if dst {
        os.close(file, &err)
        if err {
            panic(err.error)
        }
    }
}

fun compile_bling(argv []*char) {
    var err *utils.Error = NULL
    var conf types.Config = {
        strict: true,
    }
    var dst *char = NULL
    while **argv == '-' {
        if streq(*argv, "-o") {
            argv++
            dst = *argv
        } else {
            panic(sys.sprintf("unknown option: %s", *argv))
        }
        argv++
    }
    var e emitter.Emitter = {}
    emit_rawfile(&e, "bootstrap/bootstrap.h")
    var fset *token.FileSet = token.newFileSet()
    while *argv {
        var filename *char = *argv
        var file *ast.File = NULL
        if bytes.hasSuffix(filename, ".bling") {
            file = parser.parseFile(fset, filename, types.universe())
        } else if bytes.hasSuffix(filename, ".c") {
            file = cparser.parseFile(fset, filename, types.universe())
        } else {
            panic(sys.sprintf("unknown file type: %s", filename))
        }
        var pkg *types.Package = types.checkFile(&conf, paths.dir(filename), fset, file, NULL)
        for var i int = 0; i < utils.Slice_len(&pkg.files); i++ {
            var file *ast.File = NULL
            utils.Slice_get(&pkg.files, i, &file)
            e.forwardDecl = true
            cemitter.emitScope(&e, file.scope)
            e.forwardDecl = false
            cemitter.emitScope(&e, file.scope)
            free(file.decls)
            free(file)
        }
        argv++
    }
    var out *char = emitter.Emitter_string(&e)
    if dst {
        if bytes.hasSuffix(dst, ".out") {
            var tmp *char = paths.join2(os.tempDir(), "tmp.c")
            ioutil.writeFile(tmp, out, 0644, NULL)
            var args []*char = {
                "/usr/bin/cc",
                "-o",
                dst,
                tmp,
                "bazel-bin/bootstrap/libbootstrap.a",
                "bazel-bin/os/libos.a",
                "bazel-bin/sys/libsys.a",
                NULL,
            }
            var code int = sys.run(args)
            if code != 0 {
                panic(sys.sprintf("- failed with code %d", code))
            }
        } else {
            ioutil.writeFile(dst, out, 0644, NULL)
        }
    } else {
        os.write(os.stdout, out, &err)
    }
}

fun main(argc int, argv []*char) int {
    var progname *char = *argv
    argv++
    if !*argv {
        panic(sys.sprintf("usage: %s -o DST SRCS", progname))
    }
    if streq(*argv, "build") {
        argv++
        build.buildPackage(argv)
    } else if streq(*argv, "-c") {
        argv++
        compile_c(argv)
    } else {
        compile_bling(argv)
    }
    return 0
}
