package bytes

import "runtime"

typ Buffer [array]char

fun hasSuffix(b runtime.charstr, suffix runtime.charstr) bool {
    for var i = 0; b[i]; i++ {
        if runtime.streq(&b[i], suffix) {
            return true
        }
    }
    return false
}

fun indexByte(b runtime.charstr, c char) int {
    for var i = 0; b[i]; i++ {
        if b[i] == c {
            return i
        }
    }
    return -1
}

fun join(a [?]runtime.charstr, size int, sep runtime.charstr) runtime.charptr {
    switch size {
    case 0:
        return runtime.strdup("")
    case 1:
        return runtime.strdup(a[0])
    }
    var b Buffer = makearray(char)
    Buffer_write(&b, a[0], runtime.strlen(a[0]), nil)
    for var i = 1; i < size; i++ {
        Buffer_write(&b, sep, runtime.strlen(sep), nil)
        Buffer_write(&b, a[i], runtime.strlen(a[i]), nil)
    }
    return Buffer_string(&b)
}

fun lastIndexByte(b runtime.charstr, c char) int {
    for var i = runtime.strlen(b) - 1; i >= 0; i-- {
        if c == b[i] {
            return i
        }
    }
    return -1
}

fun Buffer_init(b *Buffer) {
    if len(*b) == 0 {
        *b = makearray(char)
    }
}

fun Buffer_len(b *Buffer) int {
    return len(*b)
}

fun Buffer_bytes(b *Buffer) runtime.charptr {
    Buffer_init(b)
    return runtime.Array_get(b, 1, 0, nil)
}

fun Buffer_string(b *Buffer) runtime.charptr {
    Buffer_init(b)
    var s runtime.charptr = runtime.malloc(Buffer_len(b) + 1)
    runtime.memcpy(s, runtime.Array_get(b, 1, 0, nil), Buffer_len(b))
    s[Buffer_len(b)] = '\0'
    return s
}

fun Buffer_write(b *Buffer, p runtime.charstr, size int, error **runtime.Error) int {
    Buffer_init(b)
    if size < 0 {
        size = runtime.strlen(p)
    }
    for var i = 0; i < size; i++ {
        append(*b, p[i])
    }
    return size
}

fun Buffer_writeByte(b *Buffer, p char, error **runtime.Error) {
    Buffer_init(b)
    append(*b, p)
}
