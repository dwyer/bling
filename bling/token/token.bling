package token

import "C"
import "bytes"
import "sys"
import "runtime"

typ Token enum {
    ILLEGAL = 0
    CHAR
    FLOAT
    IDENT
    INT
    STRING
    _keywordBeg
    ARRAY
    BREAK
    CASE
    CONST
    CONTINUE
    DEFAULT
    ELSE
    ENUM
    ESC
    FALLTHROUGH
    FOR
    FUNC
    GET
    GOTO
    IF
    IMPORT
    MAP
    PACKAGE
    RETURN
    SIZEOF
    STRUCT
    SWITCH
    TYPE
    UNION
    VAR
    WHILE
    EXTERN
    SIGNED
    STATIC
    TYPEDEF
    UNSIGNED
    _AUTO
    _COMPLEX
    _DO
    _IMAGINARY
    _INLINE
    _LONG
    _REGISTER
    _RESTRICT
    _SHORT
    _TYPEOF
    _VOLATILE
    _keywordEnd
    ARROW
    COLON
    COMMA
    ELLIPSIS
    EOF
    HASH
    LBRACE
    LBRACK
    LPAREN
    PERIOD
    QUESTION_MARK
    RBRACE
    RBRACK
    RPAREN
    SEMICOLON
    ADD
    ADD_ASSIGN
    AND
    AND_ASSIGN
    ASSIGN
    BITWISE_NOT
    DEC
    DIV
    DIV_ASSIGN
    DOLLAR
    EQUAL
    GT
    GT_EQUAL
    INC
    LAND
    LOR
    LT
    LT_EQUAL
    MOD
    MOD_ASSIGN
    MUL
    MUL_ASSIGN
    NOT
    NOT_EQUAL
    OR
    OR_ASSIGN
    SHL
    SHL_ASSIGN
    SHR
    SHR_ASSIGN
    SUB
    SUB_ASSIGN
    XOR
    XOR_ASSIGN
}

typ Pos int

typ Prec enum {
    lowest_prec = 0
    unary_prec = 11
    highest_prec = 12
}

typ File struct {
    set *FileSet
    name *char
    base int
    size int
    lines [array]int
    src *char
}

typ FileSet struct {
    fset *FileSet
    base int
    files [array]*File
    last *File
}

typ Position struct {
    filename *char
    offset int
    line int
    column int
}

var tokens []*char = {
    ILLEGAL: "ILLEGAL",
    CHAR: "CHAR",
    FLOAT: "FLOAT",
    IDENT: "IDENT",
    INT: "INT",
    STRING: "STRING",
    ARRAY: "array",
    BREAK: "break",
    CASE: "case",
    CONST: "const",
    CONTINUE: "continue",
    DEFAULT: "default",
    ELSE: "else",
    ENUM: "enum",
    ESC: "esc",
    EXTERN: "extern",
    FALLTHROUGH: "fallthrough",
    FOR: "for",
    FUNC: "fun",
    GET: "get",
    GOTO: "goto",
    IF: "if",
    IMPORT: "import",
    MAP: "map",
    PACKAGE: "package",
    RETURN: "return",
    SIGNED: "signed",
    SIZEOF: "sizeof",
    STATIC: "static",
    STRUCT: "struct",
    SWITCH: "switch",
    TYPEDEF: "typedef",
    TYPE: "typ",
    UNION: "union",
    UNSIGNED: "unsigned",
    VAR: "var",
    WHILE: "while",
    _AUTO: "auto",
    _COMPLEX: "_Complex",
    _DO: "do",
    _IMAGINARY: "_Imaginary",
    _INLINE: "inline",
    _LONG: "long",
    _REGISTER: "register",
    _RESTRICT: "restrict",
    _SHORT: "short",
    _TYPEOF: "typeof",
    _VOLATILE: "volatile",
    ARROW: "->",
    COLON: ":",
    COMMA: ",",
    ELLIPSIS: "...",
    EOF: "EOF",
    HASH: "#",
    LBRACE: "{",
    LBRACK: "[",
    LPAREN: "(",
    PERIOD: ".",
    QUESTION_MARK: "?",
    RBRACE: "}",
    RBRACK: "]",
    RPAREN: ")",
    SEMICOLON: ";",
    ADD: "+",
    ADD_ASSIGN: "+=",
    AND: "&",
    AND_ASSIGN: "&=",
    ASSIGN: "=",
    BITWISE_NOT: "~",
    DEC: "--",
    DIV: "/",
    DIV_ASSIGN: "/=",
    DOLLAR: "$",
    EQUAL: "==",
    GT: ">",
    GT_EQUAL: ">=",
    INC: "++",
    LAND: "&&",
    LOR: "||",
    LT: "<",
    LT_EQUAL: "<=",
    MOD: "%",
    MOD_ASSIGN: "%=",
    MUL: "*",
    MUL_ASSIGN: "*=",
    NOT: "!",
    NOT_EQUAL: "!=",
    OR: "|",
    OR_ASSIGN: "|=",
    SHL: "<<",
    SHL_ASSIGN: "<<=",
    SHR: ">>",
    SHR_ASSIGN: ">>=",
    SUB: "-",
    SUB_ASSIGN: "-=",
    XOR: "^",
    XOR_ASSIGN: "^=",
}

fun string(tok Token) *char {
    return tokens[tok]
}

var keywords map Token = makemap(Token)

fun lookup(ident *char) Token {
    if len(keywords) == 0 {
        for var i int = _keywordBeg + 1; i < _keywordEnd; i++ {
            var s *char = string(i)
            runtime.Map_set(&keywords, s, &i)
        }
    }
    var tok Token = IDENT
    runtime.Map_get(&keywords, ident, &tok)
    return tok
}

fun precedence(op Token) int {
    switch op {
    case MUL, DIV, MOD:
        return 10
    case ADD, SUB:
        return 9
    case SHL, SHR:
        return 8
    case GT, GT_EQUAL, LT, LT_EQUAL:
        return 7
    case EQUAL, NOT_EQUAL:
        return 6
    case AND:
        return 5
    case XOR:
        return 4
    case OR:
        return 3
    case LAND:
        return 2
    case LOR:
        return 1
    default:
        return lowest_prec
    }
}

fun Position_string(p *Position) *char {
    return C.sprintf("%s:%d:%d", p.filename, p.line, p.column)
}

fun getInt(a *[array]int, i int) int {
    return (*a)[i]
}

fun File_addLine(f *File, offset int) {
    var i int = len(f.lines)
    if (i == 0 || getInt(&f.lines, i - 1) < offset) && offset < f.size {
        append(f.lines, offset)
    }
}

fun File_pos(f *File, offset int) Pos {
    return f.base + offset
}

fun searchInts(a *[array]int, x int) int {
    var i int = 0
    var j int = len(*a)
    while i < j {
        var h int = i + (j - i) / 2
        if getInt(a, h) <= x {
            i = h + 1
        } else {
            j = h
        }
    }
    return i - 1
}

fun _File_position(f *File, p Pos, adjusted bool) Position {
    var offset int = p - f.base
    var i int = searchInts(&f.lines, offset)
    var pos Position = {
        filename: f.name,
        offset: offset,
        line: i + 1,
        column: offset - getInt(&f.lines, i) + 1,
    }
    return pos
}

var noPos const Pos = 0

fun File_positionFor(f *File, p Pos, adjusted bool) Position {
    var pos Position = {}
    if p != noPos {
        if p < f.base || p > f.base + f.size {
            panic("illegal Pos value")
        }
        pos = _File_position(f, p, adjusted)
    }
    return pos
}

fun File_position(f *File, p Pos) Position {
    return File_positionFor(f, p, true)
}

fun File_lineString(f *File, line int) *char {
    if line < 1 {
        return NULL
    }
    var buf bytes.Buffer = {}
    var i int = f.lines[line - 1]
    var ch int = f.src[i]
    while ch > 0 && ch != '\n' {
        bytes.Buffer_writeByte(&buf, ch, NULL)
        i++
        ch = f.src[i]
    }
    return bytes.Buffer_string(&buf)
}

fun newFileSet() *FileSet {
    var fset FileSet = {
        base: 1,
        files: makearray(*File),
    }
    return &&fset
}

fun FileSet_addFile(s *FileSet, filename *const char, base int, size int) *File {
    if base < 0 {
        base = s.base
    }
    if base < s.base || size < 0 {
        panic("illegal base or size")
    }
    var lines [array]int = makearray(int)
    var zero int = 0
    append(lines, zero)
    var file File = {
        name: sys.strdup(filename),
        base: base,
        size: size,
        lines: lines,
    }
    var f *File = &&file
    base += size + 1
    s.base = base
    append(s.files, f)
    s.last = f
    return f
}

fun searchFiles(files *[array]*File, x int) int {
    for var i int = 0; i < len(*files); i++ {
        var f *File = (*files)[i]
        if f.base <= x && x <= f.base + f.size {
            return i
        }
    }
    return -1
}

fun FileSet_file(s *FileSet, p Pos) *File {
    var f *File = s.last
    if f != NULL && f.base <= p && p <= f.base + f.size {
        return f
    }
    var i int = searchFiles(&s.files, p)
    if i >= 0 {
        f = s.files[i]
        if p <= f.base + f.size {
            s.last = f
            return f
        }
    }
    return NULL
}

fun FileSet_print(fset *FileSet) {
    for var i int = 0; i < len(fset.files); i++ {
        var f *File = fset.files[i]
        var s *char = C.sprintf("%d: %s (base=%d, size=%d)", i, f.name, f.base, f.size)
        print(s)
        sys.free(s)
    }
}
