package token

import "bytes"
import "sys"
import "utils"

typ Token enum {
    ILLEGAL = 0
    CHAR
    FLOAT
    IDENT
    INT
    STRING
    _keywordBeg
    BREAK
    CASE
    CONST
    CONTINUE
    DEFAULT
    ELSE
    ENUM
    ESC
    FALLTHROUGH
    FOR
    FUNC
    GOTO
    IF
    IMPORT
    MAP
    PACKAGE
    RETURN
    SIZEOF
    STRUCT
    SWITCH
    TYPE
    UNION
    VAR
    WHILE
    EXTERN
    SIGNED
    STATIC
    TYPEDEF
    UNSIGNED
    _AUTO
    _COMPLEX
    _DO
    _IMAGINARY
    _INLINE
    _LONG
    _REGISTER
    _RESTRICT
    _SHORT
    _TYPEOF
    _VOLATILE
    _keywordEnd
    ARROW
    COLON
    COMMA
    ELLIPSIS
    EOF
    HASH
    LBRACE
    LBRACK
    LPAREN
    PERIOD
    QUESTION_MARK
    RBRACE
    RBRACK
    RPAREN
    SEMICOLON
    ADD
    ADD_ASSIGN
    AND
    AND_ASSIGN
    ASSIGN
    BITWISE_NOT
    DEC
    DIV
    DIV_ASSIGN
    DOLLAR
    EQUAL
    GT
    GT_EQUAL
    INC
    LAND
    LOR
    LT
    LT_EQUAL
    MOD
    MOD_ASSIGN
    MUL
    MUL_ASSIGN
    NOT
    NOT_EQUAL
    OR
    OR_ASSIGN
    SHL
    SHL_ASSIGN
    SHR
    SHR_ASSIGN
    SUB
    SUB_ASSIGN
    XOR
    XOR_ASSIGN
}

typ Pos int

typ Prec enum {
    lowest_prec = 0
    unary_prec = 11
    highest_prec = 12
}

typ File struct {
    set *FileSet
    name *char
    base int
    size int
    lines utils.Slice
    src *char
}

typ FileSet struct {
    fset *FileSet
    base int
    files utils.Slice
    last *File
}

typ Position struct {
    filename *char
    offset int
    line int
    column int
}

var tokens []*char = {
    ILLEGAL: "ILLEGAL",
    CHAR: "CHAR",
    FLOAT: "FLOAT",
    IDENT: "IDENT",
    INT: "INT",
    STRING: "STRING",
    BREAK: "break",
    CASE: "case",
    CONST: "const",
    CONTINUE: "continue",
    DEFAULT: "default",
    ELSE: "else",
    ENUM: "enum",
    ESC: "esc",
    EXTERN: "extern",
    FALLTHROUGH: "fallthrough",
    FOR: "for",
    FUNC: "fun",
    GOTO: "goto",
    IF: "if",
    IMPORT: "import",
    MAP: "map",
    PACKAGE: "package",
    RETURN: "return",
    SIGNED: "signed",
    SIZEOF: "sizeof",
    STATIC: "static",
    STRUCT: "struct",
    SWITCH: "switch",
    TYPEDEF: "typedef",
    TYPE: "typ",
    UNION: "union",
    UNSIGNED: "unsigned",
    VAR: "var",
    WHILE: "while",
    _AUTO: "auto",
    _COMPLEX: "_Complex",
    _DO: "do",
    _IMAGINARY: "_Imaginary",
    _INLINE: "inline",
    _LONG: "long",
    _REGISTER: "register",
    _RESTRICT: "restrict",
    _SHORT: "short",
    _TYPEOF: "typeof",
    _VOLATILE: "volatile",
    ARROW: "->",
    COLON: ":",
    COMMA: ",",
    ELLIPSIS: "...",
    EOF: "EOF",
    HASH: "#",
    LBRACE: "{",
    LBRACK: "[",
    LPAREN: "(",
    PERIOD: ".",
    QUESTION_MARK: "?",
    RBRACE: "}",
    RBRACK: "]",
    RPAREN: ")",
    SEMICOLON: ";",
    ADD: "+",
    ADD_ASSIGN: "+=",
    AND: "&",
    AND_ASSIGN: "&=",
    ASSIGN: "=",
    BITWISE_NOT: "~",
    DEC: "--",
    DIV: "/",
    DIV_ASSIGN: "/=",
    DOLLAR: "$",
    EQUAL: "==",
    GT: ">",
    GT_EQUAL: ">=",
    INC: "++",
    LAND: "&&",
    LOR: "||",
    LT: "<",
    LT_EQUAL: "<=",
    MOD: "%",
    MOD_ASSIGN: "%=",
    MUL: "*",
    MUL_ASSIGN: "*=",
    NOT: "!",
    NOT_EQUAL: "!=",
    OR: "|",
    OR_ASSIGN: "|=",
    SHL: "<<",
    SHL_ASSIGN: "<<=",
    SHR: ">>",
    SHR_ASSIGN: ">>=",
    SUB: "-",
    SUB_ASSIGN: "-=",
    XOR: "^",
    XOR_ASSIGN: "^=",
}

fun string(tok Token) *char {
    return tokens[tok]
}

var keywords utils.Map = {}

fun lookup(ident *char) Token {
    if utils.Map_len(&keywords) == 0 {
        keywords = utils.Map_make(sizeof(Token))
        for var i int = _keywordBeg + 1; i < _keywordEnd; i++ {
            var s *char = string(i)
            utils.Map_set(&keywords, s, &i)
        }
    }
    var tok Token = IDENT
    utils.Map_get(&keywords, ident, &tok)
    return tok
}

fun precedence(op Token) int {
    switch op {
    case MUL, DIV, MOD:
        return 10
    case ADD, SUB:
        return 9
    case SHL, SHR:
        return 8
    case GT, GT_EQUAL, LT, LT_EQUAL:
        return 7
    case EQUAL, NOT_EQUAL:
        return 6
    case AND:
        return 5
    case XOR:
        return 4
    case OR:
        return 3
    case LAND:
        return 2
    case LOR:
        return 1
    default:
        return lowest_prec
    }
}

fun Position_string(p *Position) *char {
    return sys.sprintf("%s:%d:%d", p.filename, p.line, p.column)
}

fun getInt(a *utils.Slice, i int) int {
    var x int
    utils.Slice_get(a, i, &x)
    return x
}

fun File_addLine(f *File, offset int) {
    var i int = utils.Slice_len(&f.lines)
    if (i == 0 || getInt(&f.lines, i - 1) < offset) && offset < f.size {
        utils.Slice_append(&f.lines, &offset)
    }
}

fun File_pos(f *File, offset int) Pos {
    return f.base + offset
}

fun searchInts(a *utils.Slice, x int) int {
    var i int = 0
    var j int = utils.Slice_len(a)
    while i < j {
        var h int = i + (j - i) / 2
        if getInt(a, h) <= x {
            i = h + 1
        } else {
            j = h
        }
    }
    return i - 1
}

fun _File_position(f *File, p Pos, adjusted bool) Position {
    var offset int = p - f.base
    var i int = searchInts(&f.lines, offset)
    var pos Position = {
        filename: f.name,
        offset: offset,
        line: i + 1,
        column: offset - getInt(&f.lines, i) + 1,
    }
    return pos
}

var noPos const Pos = 0

fun File_positionFor(f *File, p Pos, adjusted bool) Position {
    var pos Position = {}
    if p != noPos {
        if p < f.base || p > f.base + f.size {
            panic("illegal Pos value")
        }
        pos = _File_position(f, p, adjusted)
    }
    return pos
}

fun File_position(f *File, p Pos) Position {
    return File_positionFor(f, p, true)
}

fun File_lineString(f *File, line int) *char {
    if line < 1 {
        return NULL
    }
    var buf bytes.Buffer = {}
    var i int = 0
    utils.Slice_get(&f.lines, line - 1, &i)
    var ch int = f.src[i]
    while ch > 0 && ch != '\n' {
        bytes.Buffer_writeByte(&buf, ch, NULL)
        i++
        ch = f.src[i]
    }
    return bytes.Buffer_string(&buf)
}

fun newFileSet() *FileSet {
    var fset FileSet = {
        base: 1,
        files: utils.Slice_init(sizeof(*File)),
    }
    return &&fset
}

fun FileSet_addFile(s *FileSet, filename *const char, base int, size int) *File {
    if base < 0 {
        base = s.base
    }
    if base < s.base || size < 0 {
        panic("illegal base or size")
    }
    var lines utils.Slice = utils.Slice_init(sizeof(int))
    var zero int = 0
    utils.Slice_append(&lines, &zero)
    var file File = {
        name: strdup(filename),
        base: base,
        size: size,
        lines: lines,
    }
    var f *File = &&file
    base += size + 1
    s.base = base
    utils.Slice_append(&s.files, &f)
    s.last = f
    return f
}

fun searchFiles(files *utils.Slice, x int) int {
    for var i int = 0; i < utils.Slice_len(files); i++ {
        var f *File
        utils.Slice_get(files, i, &f)
        if f.base <= x && x <= f.base + f.size {
            return i
        }
    }
    return -1
}

fun FileSet_file(s *FileSet, p Pos) *File {
    var f *File = s.last
    if f != NULL && f.base <= p && p <= f.base + f.size {
        return f
    }
    var i int = searchFiles(&s.files, p)
    if i >= 0 {
        utils.Slice_get(&s.files, i, &f)
        if p <= f.base + f.size {
            s.last = f
            return f
        }
    }
    return NULL
}

fun FileSet_print(fset *FileSet) {
    for var i int = 0; i < utils.Slice_len(&fset.files); i++ {
        var f *File
        utils.Slice_get(&fset.files, i, &f)
        var s *char = sys.sprintf("%d: %s (base=%d, size=%d)", i, f.name, f.base, f.size)
        print(s)
        free(s)
    }
}
