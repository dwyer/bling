package build

import "bling/ast"
import "bling/emitter"
import "bling/parser"
import "bling/token"
import "bling/types"
import "bytes"
import "io/ioutil"
import "os"
import "paths"
import "subc/cemitter"
import "subc/cparser"
import "sys"
import "utils"

var AR_PATH *const char = "/usr/bin/ar"

var CC_PATH *const char = "/usr/bin/cc"

var GEN_PATH *const char = "gen"

var INCL_PATH *const char = "."

var VERBOSE const bool = true

fun emit_rawfile(e *emitter.Emitter, filename *const char) {
    var err *utils.Error = NULL
    var src *char = ioutil.readFile(filename, &err)
    if err {
        panic(err.error)
    }
    emitter.emitString(e, src)
    sys.free(src)
}

fun printStrArray(s **char) {
    for var i int = 0; s[i]; i++ {
        if i {
            sys.printf(" ")
        }
        sys.printf("%s", s[i])
    }
    sys.printf("\n")
}

fun execute(cmd *utils.Slice) {
    var args **char = utils.nilArray(cmd)
    if VERBOSE {
        printStrArray(args)
    }
    var code int = sys.run(args)
    if code != 0 {
        panic(sys.sprintf("- failed with code %d", code))
    }
    sys.free(args)
}

fun Slice_appendStrLit(a *utils.Slice, s *const char) {
    utils.Slice_append(a, &s)
}

fun mkdirForFile(path *const char) {
    var dir *char = paths.dir(path)
    os.mkdirAll(dir, 0755, NULL)
    sys.free(dir)
}

typ Package struct {
    path *char
    pkg *types.Package
    hPath *char
    cPath *char
    objPath *char
    objPaths utils.Slice
    libPath *char
    libModTime os.Time
    srcModTime os.Time
    deps utils.Slice
    isCmd bool
}

typ Builder struct {
    fset *token.FileSet
    info *types.Info
    force bool
    conf types.Config
    pkgs utils.Map
}

fun genObj(b *Builder, dst *const char, src *const char) {
    var cmd utils.Slice = {
        size: sizeof(*char),
    }
    Slice_appendStrLit(&cmd, CC_PATH)
    Slice_appendStrLit(&cmd, "-fms-extensions")
    Slice_appendStrLit(&cmd, "-Wno-microsoft-anon-tag")
    Slice_appendStrLit(&cmd, "-g")
    Slice_appendStrLit(&cmd, "-I")
    Slice_appendStrLit(&cmd, INCL_PATH)
    Slice_appendStrLit(&cmd, "-c")
    Slice_appendStrLit(&cmd, "-o")
    Slice_appendStrLit(&cmd, dst)
    Slice_appendStrLit(&cmd, src)
    mkdirForFile(dst)
    execute(&cmd)
}

fun getFileModTime(path *const char) os.Time {
    var t os.Time = 0
    var err *utils.Error = NULL
    var info *os.FileInfo = os.stat(path, &err)
    if info {
        t = os.FileInfo_modTime(info)
        os.FileInfo_free(info)
    }
    return t
}

fun getSrcModTime(path *const char) os.Time {
    var t os.Time = 0
    var files **os.FileInfo = ioutil.readDir(path, NULL)
    for var i int = 0; files[i]; i++ {
        var modTime os.Time = os.FileInfo_modTime(files[i])
        if bytes.hasSuffix(files[i]._name, ".bling") {
            if t < modTime {
                t = modTime
            }
        }
        os.FileInfo_free(files[i])
    }
    sys.free(files)
    return t
}

fun buildCFile(b *Builder, cFile *os.FileInfo) *os.FileInfo {
    var src *char = os.FileInfo_name(cFile)
    var dst *char = NULL
    {
        var i int = bytes.lastIndexByte(src, '.')
        var base *char = sys.strdup(src)
        base[i] = '\0'
        dst = sys.sprintf("%s/%s.o", GEN_PATH, base)
        sys.free(base)
    }
    var err *utils.Error = NULL
    var objFile *os.FileInfo = os.stat(dst, &err)
    var doBuild bool = objFile == NULL || os.FileInfo_modTime(cFile) > os.FileInfo_modTime(objFile)
    if b.force || doBuild {
        genObj(b, dst, src)
        os.FileInfo_free(objFile)
        objFile = os.stat(dst, &err)
    }
    return objFile
}

fun newPackage(b *Builder, path *const char) Package {
    var base *char = paths.base(path)
    var typesPkg *types.Package = types.check(&b.conf, path, b.fset, NULL, b.info)
    var isCmd bool = typesPkg.name ? sys.streq(typesPkg.name, "main") : false
    var genPath *char = paths.join2(GEN_PATH, path)
    var libPath *char = sys.sprintf("%s/%s.a", genPath, base)
    if isCmd {
        libPath = sys.sprintf("%s/%s", genPath, base)
    } else {
        libPath = sys.sprintf("%s/%s.a", genPath, base)
    }
    var pkg Package = {
        path: sys.strdup(path),
        pkg: typesPkg,
        hPath: sys.sprintf("%s/%s.h", genPath, base),
        cPath: sys.sprintf("%s/%s.c", genPath, base),
        objPath: sys.sprintf("%s/%s.o", genPath, base),
        libPath: libPath,
        libModTime: getFileModTime(libPath),
        srcModTime: getSrcModTime(path),
        deps: {
            size: sizeof(*Package),
        },
        isCmd: isCmd,
    }
    sys.free(genPath)
    sys.free(base)
    for var i int = 0; i < utils.Slice_len(&pkg.pkg.imports); i++ {
        var impt *types.Package = NULL
        utils.Slice_get(&pkg.pkg.imports, i, &impt)
        var dep *Package = _buildPackage(b, impt.path)
        utils.Slice_append(&pkg.deps, &dep)
        if pkg.srcModTime < dep.srcModTime {
            pkg.srcModTime = dep.srcModTime
        }
    }
    return pkg
}

typ SliceIter struct {
    s *utils.Slice
    i int
    it *void
}

fun SliceIter_next(iter *SliceIter, it *void) bool {
    if iter.i < utils.Slice_len(iter.s) {
        utils.Slice_get(iter.s, iter.i, it)
        iter.it = it
        iter.i++
        return true
    }
    return false
}

fun emitInclude(e *emitter.Emitter, path *const char) {
    var s *char = sys.sprintf("#include \"%s\"\n", path)
    emitter.emitString(e, s)
    sys.free(s)
}

fun writeFile(path *const char, out *const char) {
    if VERBOSE {
    }
    mkdirForFile(path)
    ioutil.writeFile(path, out, 0644, NULL)
}

fun genHeader(b *Builder, pkg *Package) {
    var e emitter.Emitter = {}
    emitter.emitString(&e, "#pragma once")
    emitter.emitNewline(&e)
    emit_rawfile(&e, "bootstrap/bootstrap.h")
    for var i int = 0; i < utils.Slice_len(&pkg.deps); i++ {
        var dep *Package = NULL
        utils.Slice_get(&pkg.deps, i, &dep)
        emitInclude(&e, dep.hPath)
    }
    cemitter.emitHeader(&e, pkg.pkg)
    var out *char = emitter.Emitter_string(&e)
    writeFile(pkg.hPath, out)
    sys.free(out)
}

fun getCFile(b *Builder, pkg *Package) {
    var e emitter.Emitter = {}
    emitInclude(&e, pkg.hPath)
    cemitter.emitBody(&e, pkg.pkg)
    var out *char = emitter.Emitter_string(&e)
    writeFile(pkg.cPath, out)
    sys.free(out)
}

fun buildCPackage(b *Builder, path *const char) *Package {
    var pkg Package = newPackage(b, path)
    var objFiles utils.Slice = {
        size: sizeof(*char),
    }
    {
        var files **os.FileInfo = ioutil.readDir(path, NULL)
        for var i int = 0; files[i]; i++ {
            var checkTime bool = false
            var modTime os.Time = os.FileInfo_modTime(files[i])
            if bytes.hasSuffix(files[i]._name, ".bling") {
                if pkg.srcModTime < modTime {
                    pkg.srcModTime = modTime
                }
            } else if bytes.hasSuffix(files[i]._name, ".c") {
                if pkg.srcModTime < modTime {
                    pkg.srcModTime = modTime
                }
                var obj *os.FileInfo = buildCFile(b, files[i])
                utils.Slice_append(&objFiles, &obj._name)
                checkTime = true
                modTime = os.FileInfo_modTime(obj)
                if pkg.srcModTime < modTime {
                    pkg.srcModTime = modTime
                }
            }
            os.FileInfo_free(files[i])
        }
    }
    if b.force || pkg.srcModTime > pkg.libModTime {
        if VERBOSE {
        }
        genHeader(b, &pkg)
        var cmd utils.Slice = {
            size: sizeof(*char),
        }
        Slice_appendStrLit(&cmd, AR_PATH)
        Slice_appendStrLit(&cmd, "rsc")
        Slice_appendStrLit(&cmd, pkg.libPath)
        for var i int = 0; i < utils.Slice_len(&objFiles); i++ {
            var obj *char = NULL
            utils.Slice_get(&objFiles, i, &obj)
            utils.Slice_append(&cmd, &obj)
        }
        mkdirForFile(pkg.libPath)
        execute(&cmd)
        pkg.libModTime = getFileModTime(pkg.libPath)
    }
    return &&pkg
}

fun buildBlingPackage(b *Builder, path *const char) *Package {
    var pkg Package = newPackage(b, path)
    if b.force || pkg.srcModTime > pkg.libModTime {
        genHeader(b, &pkg)
        getCFile(b, &pkg)
        genObj(b, pkg.objPath, pkg.cPath)
        if VERBOSE {
        }
        if pkg.isCmd {
            var cmd utils.Slice = {
                size: sizeof(*char),
            }
            Slice_appendStrLit(&cmd, CC_PATH)
            Slice_appendStrLit(&cmd, "-o")
            Slice_appendStrLit(&cmd, pkg.libPath)
            Slice_appendStrLit(&cmd, pkg.objPath)
            var pkg *Package = NULL
            var iter utils.MapIter = utils.NewMapIter(&b.pkgs)
            while utils.MapIter_next(&iter, NULL, &pkg) {
                Slice_appendStrLit(&cmd, pkg.libPath)
            }
            execute(&cmd)
        } else {
            var cmd utils.Slice = {
                size: sizeof(*char),
            }
            Slice_appendStrLit(&cmd, AR_PATH)
            Slice_appendStrLit(&cmd, "rsc")
            Slice_appendStrLit(&cmd, pkg.libPath)
            Slice_appendStrLit(&cmd, pkg.objPath)
            execute(&cmd)
        }
    }
    return &&pkg
}

fun _buildPackage(b *Builder, path *const char) *Package {
    var pkg *Package = NULL
    utils.Map_get(&b.pkgs, path, &pkg)
    if pkg {
        return pkg
    }
    if VERBOSE {
    }
    if sys.streq(path, "bootstrap") || sys.streq(path, "os") || sys.streq(path, "sys") {
        pkg = buildCPackage(b, path)
    } else {
        pkg = buildBlingPackage(b, path)
    }
    utils.Map_set(&b.pkgs, path, &pkg)
    return pkg
}

fun buildPackage(argv []*char) {
    assert(*argv)
    var path *char = *argv
    var builder Builder = {
        fset: token.newFileSet(),
        info: types.newInfo(),
        force: false,
        pkgs: utils.Map_make(sizeof(*Package)),
    }
    _buildPackage(&builder, "bootstrap")
    _buildPackage(&builder, path)
}
