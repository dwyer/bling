package build

import "C"
import "bling/ast"
import "bling/emitter"
import "bling/parser"
import "bling/token"
import "bling/types"
import "bytes"
import "io/ioutil"
import "os"
import "paths"
import "runtime"
import "subc/cemitter"
import "subc/cparser"

var AR_PATH runtime.charstr = "/usr/bin/ar"

var CC_PATH runtime.charstr = "/usr/bin/cc"

var GEN_PATH runtime.charstr = "gen"

var INCL_PATH runtime.charstr = "."

var VERBOSE const bool = true

fun printStrArray(s []runtime.charptr) {
    for var i = 0; i < len(s); i++ {
        if i {
            C.printf(" ")
        }
        C.printf("%s", s[i])
    }
    C.printf("\n")
}

fun execute(cmd *[]runtime.charptr) {
    if VERBOSE {
        printStrArray(*cmd)
    }
    var args = runtime.nilArray(typ *runtime.Slice(cmd), sizeof(runtime.charptr))
    var code = os.exec(args, nil)
    if code != 0 {
        panic(C.sprintf("- failed with code %d", code))
    }
    delete(args)
}

fun mkdirForFile(path runtime.charstr) {
    var dir = paths.dir(path)
    os.mkdirAll(dir, 0755, nil)
    delete(dir)
}

typ Package struct {
    path runtime.charptr
    pkg *types.Package
    hPath runtime.charptr
    cPath runtime.charptr
    objPath runtime.charptr
    objPaths []runtime.charptr
    libPath runtime.charptr
    libModTime os.Time
    srcModTime os.Time
    deps []*Package
    isCmd bool
}

typ Builder struct {
    fset *token.FileSet
    info *types.Info
    force bool
    conf types.Config
    pkgs map *Package
}

fun newBuilder(fset *token.FileSet) *Builder {
    var builder Builder = {
        fset: fset,
        info: types.newInfo(),
        force: false,
        pkgs: runtime.Map_make(sizeof(*Package)),
    }
    return &&builder
}

fun genObj(b *Builder, dst runtime.charstr, src runtime.charstr) {
    var cmd = []runtime.charptr{}
    append(cmd, CC_PATH)
    append(cmd, typ runtime.charptr("-g"))
    append(cmd, typ runtime.charptr("-I"))
    append(cmd, INCL_PATH)
    append(cmd, typ runtime.charptr("-c"))
    append(cmd, typ runtime.charptr("-o"))
    append(cmd, dst)
    append(cmd, src)
    mkdirForFile(dst)
    execute(&cmd)
}

fun getFileModTime(path runtime.charstr) os.Time {
    var t os.Time = 0
    if var info = os.stat(path, nil); info != nil {
        t = info.modTime()
        info.free()
    }
    return t
}

fun getSrcModTime(path runtime.charstr) os.Time {
    var t os.Time = 0
    var files = ioutil.readDir(path, nil)
    for var i = 0; i < len(files); i++ {
        var file = files[i]
        var modTime = file.modTime()
        if bytes.hasSuffix(file.name(), ".bling") {
            if t < modTime {
                t = modTime
            }
        }
        file.free()
    }
    delete(files)
    return t
}

fun buildCFile(b *Builder, cFile *os.FileInfo) *os.FileInfo {
    var src = cFile.name()
    var dst runtime.charptr = nil
    {
        var i = bytes.lastIndexByte(src, '.')
        var base = runtime.strdup(src)
        base[i] = '\0'
        dst = C.sprintf("%s/%s.o", GEN_PATH, base)
        delete(base)
    }
    var err *runtime.Error = nil
    var objFile = os.stat(dst, &err)
    var doBuild = objFile == nil || cFile.modTime() > objFile.modTime()
    if b.force || doBuild {
        genObj(b, dst, src)
        objFile.free()
        objFile = os.stat(dst, &err)
    }
    return objFile
}

fun newPackage(b *Builder, path runtime.charstr) Package {
    var base = paths.base(path)
    var files = parser.parseDir(b.fset, path, nil)
    var typesPkg = types.check(&b.conf, path, b.fset, files, b.info)
    var isCmd = typesPkg.name ? runtime.streq(typesPkg.name, "main") : false
    var genPath = paths.join2(GEN_PATH, path)
    var libPath = nil
    if isCmd {
        libPath = C.sprintf("%s/%s", genPath, base)
    } else {
        libPath = C.sprintf("%s/%s.a", genPath, base)
    }
    var pkg = Package{
        path: runtime.strdup(path),
        pkg: typesPkg,
        hPath: C.sprintf("%s/%s.h", genPath, base),
        cPath: C.sprintf("%s/%s.c", genPath, base),
        objPath: C.sprintf("%s/%s.o", genPath, base),
        libPath: libPath,
        libModTime: getFileModTime(libPath),
        srcModTime: getSrcModTime(path),
        deps: []*Package{},
        isCmd: isCmd,
    }
    delete(genPath)
    delete(base)
    for var i = 0; i < len(pkg.pkg.imports); i++ {
        var dep = _buildPackage(b, pkg.pkg.imports[i].path)
        append(pkg.deps, dep)
        if pkg.srcModTime < dep.srcModTime {
            pkg.srcModTime = dep.srcModTime
        }
    }
    return pkg
}

fun emitInclude(e *emitter.Emitter, path runtime.charstr) {
    var s = C.sprintf("#include \"%s\"\n", path)
    emitter.emitString(e, s)
    delete(s)
}

fun writeFile(path runtime.charstr, out runtime.charstr) {
    mkdirForFile(path)
    ioutil.writeFile(path, runtime.charstobytes(out), 0644, nil)
}

fun genHeader(b *Builder, pkg *Package) {
    var e = emitter.Emitter{}
    emitter.emitString(&e, "#pragma once")
    emitter.emitNewline(&e)
    emitInclude(&e, "bootstrap/bootstrap.h")
    for var i = 0; i < len(pkg.deps); i++ {
        emitInclude(&e, pkg.deps[i].hPath)
    }
    cemitter.emitHeader(&e, pkg.pkg)
    var out = emitter.Emitter_string(&e)
    writeFile(pkg.hPath, out)
    delete(out)
}

fun getCFile(b *Builder, pkg *Package) {
    var e = emitter.Emitter{}
    emitInclude(&e, pkg.hPath)
    cemitter.emitBody(&e, pkg.pkg)
    var out = emitter.Emitter_string(&e)
    writeFile(pkg.cPath, out)
    delete(out)
}

fun buildCPackage(b *Builder, path runtime.charstr) *Package {
    var pkg = newPackage(b, path)
    var files = ioutil.readDir(path, nil)
    for var i = 0; i < len(files); i++ {
        var checkTime = false
        var file = files[i]
        var modTime = file.modTime()
        var name = file.name()
        if bytes.hasSuffix(name, ".bling") || bytes.hasSuffix(name, ".c") {
            if pkg.srcModTime < modTime {
                pkg.srcModTime = modTime
            }
        }
    }
    if b.force || pkg.srcModTime > pkg.libModTime {
        genHeader(b, &pkg)
        var cmd = []runtime.charptr{}
        append(cmd, AR_PATH)
        append(cmd, typ runtime.charptr("rsc"))
        append(cmd, pkg.libPath)
        for var i = 0; i < len(files); i++ {
            var file = files[i]
            if bytes.hasSuffix(file.name(), ".c") {
                var obj = buildCFile(b, file)
                append(cmd, file.name())
            }
        }
        mkdirForFile(pkg.libPath)
        execute(&cmd)
        pkg.libModTime = getFileModTime(pkg.libPath)
    }
    for var i = 0; i < len(files); i++ {
        files[i].free()
    }
    delete(files)
    return &&pkg
}

fun buildBlingPackage(b *Builder, path runtime.charstr) *Package {
    var pkg = newPackage(b, path)
    if b.force || pkg.srcModTime > pkg.libModTime {
        genHeader(b, &pkg)
        getCFile(b, &pkg)
        genObj(b, pkg.objPath, pkg.cPath)
        if pkg.isCmd {
            var cmd = []runtime.charptr{}
            append(cmd, CC_PATH)
            append(cmd, typ runtime.charptr("-g"))
            append(cmd, typ runtime.charptr("-o"))
            append(cmd, pkg.libPath)
            append(cmd, pkg.objPath)
            var pkg *Package = nil
            var iter = runtime.NewMapIter(&b.pkgs)
            while runtime.MapIter_next(&iter, nil, &pkg) {
                append(cmd, pkg.libPath)
            }
            execute(&cmd)
        } else {
            var cmd = []runtime.charptr{}
            append(cmd, AR_PATH)
            append(cmd, typ runtime.charptr("rsc"))
            append(cmd, pkg.libPath)
            append(cmd, pkg.objPath)
            execute(&cmd)
        }
    }
    return &&pkg
}

fun _buildPackage(b *Builder, path runtime.charstr) *Package {
    var pkg *Package = nil
    runtime.Map_get(&b.pkgs, path, &pkg)
    if pkg {
        return pkg
    }
    if runtime.streq(path, "C") {
        pkg = buildCPackage(b, path)
    } else {
        pkg = buildBlingPackage(b, path)
    }
    runtime.Map_set(&b.pkgs, path, &pkg)
    return pkg
}

fun buildPackage(b *Builder, path runtime.charstr) {
    var clean = paths.clean(path)
    _buildPackage(b, "runtime")
    _buildPackage(b, clean)
    delete(clean)
}
