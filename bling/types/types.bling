package types

import "C"
import "bling/ast"
import "bling/emitter"
import "bling/parser"
import "bling/token"
import "runtime"

typ Config struct {
    strict bool
    cMode bool
    ignoreFuncBodies bool
}

typ Package struct {
    path runtime.charptr
    name runtime.charptr
    scope *ast.Scope
    imports []*Package
}

typ Info struct {
    imports map *Package
}

typ BasicKind enum {
    INVALID
    VOID
    BOOL
    CHAR
    INT
    INT8
    INT16
    INT32
    INT64
    UINT
    UINT8
    UINT16
    UINT32
    UINT64
    UINTPTR
    FLOAT32
    FLOAT64
    VOID_POINTER
    UNSAFE_POINTER
}

typ BasicInfo enum {
    IS_BOOLEAN = 1 << 0
    IS_INTEGER = 1 << 1
    IS_UNSIGNED = 1 << 2
    IS_FLOAT = 1 << 3
    IS_COMPLEX = 1 << 4
    IS_STRING = 1 << 5
    IS_UNTYPED = 1 << 6
    IS_ORDERED = IS_INTEGER | IS_FLOAT | IS_STRING
    IS_NUMERIC = IS_INTEGER | IS_FLOAT | IS_COMPLEX
    IS_CONST_EXPR = IS_BOOLEAN | IS_NUMERIC | IS_STRING
}

typ Basic struct {
    kind BasicKind
    info BasicInfo
    name runtime.charptr
}

typ builtinId enum {
    APPEND
    ASSERT
    LEN
    MAKEARRAY
    MAKEMAP
    PANIC
    PRINT
    numBuiltinIds
}

typ exprKind enum {
    expression
    statement
}

fun constant_stringVal(x *ast.Expr) runtime.charptr {
    assert(x.kind == ast.EXPR_BASIC_LIT)
    var lit runtime.charstr = x.basic.value
    var n = runtime.strlen(lit) - 2
    var val runtime.charptr = runtime.malloc(n + 1)
    for var i = 0; i < n; i++ {
        val[i] = lit[i + 1]
    }
    val[n] = '\0'
    return val
}

fun declString(decl *ast.Decl) runtime.charptr {
    var e = emitter.Emitter{}
    emitter.emitDecl(&e, decl)
    return emitter.Emitter_string(&e)
}

fun exprString(expr *ast.Expr) runtime.charptr {
    var e = emitter.Emitter{}
    emitter.emitExpr(&e, expr)
    return emitter.Emitter_string(&e)
}

fun stmtString(stmt *ast.Stmt) runtime.charptr {
    var e = emitter.Emitter{}
    emitter.emitStmt(&e, stmt)
    return emitter.Emitter_string(&e)
}

fun typeString(expr *ast.Expr) runtime.charptr {
    var e = emitter.Emitter{}
    emitter.emitType(&e, expr)
    return emitter.Emitter_string(&e)
}

fun isType(expr *ast.Expr) bool {
    for ;; {
        switch expr.kind {
        case ast.EXPR_IDENT:
            if expr.ident.obj == nil {
                panic(C.sprintf("unresolved identifier %s", expr.ident.name))
            }
            return expr.ident.obj.kind == ast.ObjKind_TYP
        case ast.EXPR_SELECTOR:
            expr = expr.selector.sel
            break
        case ast.EXPR_STAR:
            expr = expr.star.x
            break
        case ast.TYPE_ARRAY, ast.TYPE_ENUM, ast.TYPE_FUNC, ast.TYPE_MAP, ast.TYPE_NATIVE, ast.TYPE_STRUCT:
            return true
        default:
            return false
        }
    }
}

fun getTypeAlias(t *ast.Expr) *ast.Expr {
    for ;; {
        switch t.kind {
        case ast.EXPR_SELECTOR:
            t = t.selector.sel
            break
        case ast.EXPR_IDENT:
            if t.ident.obj.kind == ast.ObjKind_TYP {
                return t
            }
            return nil
        default:
            return nil
        }
    }
}

fun isTypeAlias(t *ast.Expr) bool {
    return getTypeAlias(t) != nil
}

fun makeIdent(name runtime.charstr) *ast.Expr {
    var x = ast.Expr{
        kind: ast.EXPR_IDENT,
        ident: {
            name: runtime.strdup(name),
        },
    }
    return &&x
}

fun makePtr(type *ast.Expr) *ast.Expr {
    var x = ast.Expr{
        kind: ast.EXPR_STAR,
        star: {
            x: type,
        },
    }
    return &&x
}

fun getUnderlyingType(ident *ast.Expr) *ast.Expr {
    if ident.ident.obj == nil {
        panic(C.sprintf("not resolved: %s", typeString(ident)))
    }
    var decl = ident.ident.obj.decl
    if decl.kind != ast.DECL_TYPE {
        panic(C.sprintf("not a type: %s", typeString(ident)))
    }
    return decl.type.type
}

fun getBaseType(type *ast.Expr) *ast.Expr {
    for ;; {
        switch type.kind {
        case ast.EXPR_IDENT:
            type = getUnderlyingType(type)
            break
        case ast.EXPR_SELECTOR:
            type = type.selector.sel
            break
        case ast.EXPR_STAR, ast.TYPE_ARRAY, ast.TYPE_ENUM, ast.TYPE_MAP, ast.TYPE_NATIVE, ast.TYPE_STRUCT:
            return type
        default:
            panic(C.sprintf("not a type: %s", typeString(type)))
        }
    }
}

fun isDynamicArray(t *ast.Expr) bool {
    t = getBaseType(t)
    return t && t.kind == ast.TYPE_ARRAY && t.array_.dynamic
}

fun getType(x *ast.Expr) *ast.Expr {
    switch x.kind {
    case ast.EXPR_PAREN:
        return getType(x.paren.x)
    case ast.EXPR_CAST:
        return x.cast.type
    case ast.EXPR_IDENT:
        switch x.ident.obj.kind {
        case ast.ObjKind_CON, ast.ObjKind_VAL:
            return x.ident.obj.decl.value.type
        default:
            break
        }
        break
    case ast.EXPR_SELECTOR:
        return getType(x.selector.sel)
    case ast.EXPR_STAR:
        {
            var t = getType(x.star.x)
            assert(t.kind == ast.EXPR_STAR)
            return t.star.x
        }
    default:
        break
    }
    panic(exprString(x))
    return nil
}

fun isArithmetic(type *ast.Expr) bool {
    switch type.kind {
    case ast.EXPR_IDENT:
        return isArithmetic(getBaseType(type))
    case ast.EXPR_STAR, ast.TYPE_ENUM:
        return true
    case ast.TYPE_NATIVE:
        return !runtime.streq(type.native.name, "void")
    default:
        return false
    }
}

fun isNative(type *ast.Expr, name runtime.charstr) bool {
    switch type.kind {
    case ast.EXPR_IDENT:
        return runtime.streq(type.ident.name, name)
    case ast.TYPE_NATIVE:
        return true
    default:
        return false
    }
}

fun areIdentical(a *ast.Expr, b *ast.Expr) bool {
    if a == b {
        return true
    }
    if a == nil || b == nil {
        return false
    }
    if a.kind == ast.TYPE_MAP || b.kind == ast.TYPE_MAP {
        return true
    }
    assert(a)
    assert(b)
    if a.kind == ast.EXPR_SELECTOR {
        a = a.selector.sel
    }
    if b.kind == ast.EXPR_SELECTOR {
        b = b.selector.sel
    }
    if a.kind != b.kind {
        return false
    }
    switch a.kind {
    case ast.EXPR_IDENT:
        return b.kind == ast.EXPR_IDENT && a.ident.obj == a.ident.obj
    case ast.EXPR_STAR:
        return areIdentical(a.star.x, b.star.x)
    case ast.TYPE_ARRAY:
        return areIdentical(a.array_.elt, b.array_.elt)
    case ast.TYPE_FUNC:
        {
            if !areIdentical(a.func.result, b.func.result) {
                return false
            }
            var i = 0
            if len(a.func.params) {
                for ; i < len(a.func.params); i++ {
                    var param1 = a.func.params[i]
                    var param2 = b.func.params[i]
                    if param2 == nil {
                        return false
                    }
                    if !areIdentical(param1.field.type, param2.field.type) {
                        return false
                    }
                }
                if b.func.params[i] {
                    return false
                }
            }
        }
        return true
    default:
        panic(C.sprintf("not implemented: %s == %s", typeString(a), typeString(b)))
        return false
    }
}

fun isPointer(t *ast.Expr) bool {
    t = getBaseType(t)
    return t.kind == ast.EXPR_STAR || t.kind == ast.TYPE_ARRAY
}

fun pointerBase(t *ast.Expr) *ast.Expr {
    t = getBaseType(t)
    switch t.kind {
    case ast.EXPR_STAR:
        return t.star.x
    case ast.TYPE_ARRAY:
        return t.array_.elt
    default:
        panic(C.sprintf("not a pointer: %s", typeString(t)))
        return nil
    }
}

fun areAssignable(a *ast.Expr, b *ast.Expr) bool {
    if a.kind == ast.TYPE_ELLIPSIS {
        return true
    }
    if areIdentical(a, b) {
        return true
    }
    if ast.isVoidPtr(a) || ast.isVoidPtr(b) {
        return true
    }
    if isPointer(a) && isPointer(b) {
        return areAssignable(pointerBase(a), pointerBase(b))
    }
    while a.kind == ast.EXPR_IDENT {
        a = getUnderlyingType(a)
    }
    while b.kind == ast.EXPR_IDENT {
        b = getUnderlyingType(b)
    }
    if isNative(a, "bool") && isArithmetic(b) {
        return true
    }
    if b.kind == ast.TYPE_ENUM && isArithmetic(a) {
        return true
    }
    if a.kind == ast.TYPE_ENUM && isArithmetic(a) {
        return true
    }
    return areIdentical(a, b)
}

fun areComparable(a *ast.Expr, b *ast.Expr) bool {
    if areIdentical(a, b) {
        return true
    }
    if isArithmetic(a) && isArithmetic(b) {
        return true
    }
    if a.kind == ast.EXPR_STAR && isNative(b, "int") {
        return true
    }
    return areIdentical(a, b)
}

fun isLhs(expr *ast.Expr) bool {
    switch expr.kind {
    case ast.EXPR_IDENT, ast.EXPR_SELECTOR:
        return true
    case ast.EXPR_CAST:
        return isLhs(expr.cast.expr)
    case ast.EXPR_INDEX:
        return isLhs(expr.index.x)
    case ast.EXPR_PAREN:
        return isLhs(expr.paren.x)
    case ast.EXPR_STAR:
        return isLhs(expr.star.x)
    default:
        return false
    }
}

fun getDeclType(decl *ast.Decl) *ast.Expr {
    assert(decl)
    switch decl.kind {
    case ast.DECL_FIELD:
        return decl.field.type
    case ast.DECL_FUNC:
        return decl.func.type
    case ast.DECL_IMPORT:
        return nil
    case ast.DECL_TYPE:
        return decl.type.type
    case ast.DECL_VALUE:
        return decl.value.type
    default:
        panic(C.sprintf("unhandled decl: %s", declString(decl)))
        return nil
    }
}

fun getStructFieldByName(type *ast.Expr, name *ast.Expr) *ast.Decl {
    var base *ast.Expr = getBaseType(type)
    assert(base.kind == ast.TYPE_STRUCT)
    assert(name.kind == ast.EXPR_IDENT)
    for var i = 0; i < len(base.struct_.fields); i++ {
        var field = base.struct_.fields[i]
        if field.field.name {
            if runtime.streq(name.ident.name, field.field.name.ident.name) {
                base = field.field.type
                return field
            }
        } else {
            var subField = getStructFieldByName(field.field.type, name)
            if subField {
                return subField
            }
        }
    }
    return nil
}

fun getStructField(type *ast.Expr, index int) *ast.Decl {
    var base = getBaseType(type)
    if base.kind != ast.TYPE_STRUCT {
        panic(C.sprintf("not a struct: %s", typeString(type)))
    }
    if len(base.struct_.fields) == 0 {
        panic(C.sprintf("incomplete field defn: %s", typeString(type)))
    }
    if 0 <= index && index < len(base.struct_.fields) {
        return base.struct_.fields[index]
    }
    return nil
}

typ Checker struct {
    conf *Config
    fset *token.FileSet
    pkg *Package
    info *Info
    result *ast.Expr
}

fun Checker_log(c *Checker, fatal bool, pos token.Pos, msg runtime.charstr) {
    var position = token.Position{}
    var file = token.FileSet_file(c.fset, pos)
    if file {
        position = token.File_position(file, pos)
    }
    var errMsg = C.sprintf("%s: %s\n%s", token.Position_string(&position), msg, token.File_lineString(file, position.line))
    if fatal {
        panic(errMsg)
    } else {
        print(errMsg)
    }
    runtime.free(errMsg)
}

fun Checker_warning(c *Checker, pos token.Pos, msg runtime.charstr) {
    Checker_log(c, false, pos, msg)
}

fun Checker_error(c *Checker, pos token.Pos, msg runtime.charstr) {
    Checker_log(c, true, pos, msg)
}

fun Checker_resolve(c *Checker, s *ast.Scope, x *ast.Expr) {
    assert(x.kind == ast.EXPR_IDENT)
    if x.ident.obj {
        Checker_error(c, ast.Expr_pos(x), C.sprintf("already resolved: %s", x.ident.name))
    }
    if ast.resolve(s, x) {
        return
    }
    Checker_error(c, ast.Expr_pos(x), C.sprintf("unresolved: %s", x.ident.name))
}

fun Checker_declare(c *Checker, decl *ast.Decl, data voidptr, scope *ast.Scope, kind ast.ObjKind, ident *ast.Expr) {
    if ident.ident.obj != nil {
        Checker_error(c, decl.pos, C.sprintf("already declared: %s", ident.ident.name))
    }
    var obj = ast.newObject(kind, ident.ident.name)
    obj.decl = decl
    obj.data = data
    obj.scope = scope
    ident.ident.obj = obj
    var alt = ast.Scope_insert(scope, obj)
    if alt != nil {
        Checker_error(c, decl.pos, C.sprintf("incompatible redefinition of `%s`: %s", declString(obj.decl), declString(decl)))
    }
}

fun Checker_openScope(c *Checker) {
    c.pkg.scope = ast.Scope_new(c.pkg.scope)
}

fun Checker_closeScope(c *Checker) {
    c.pkg.scope = c.pkg.scope.outer
}

fun Checker_checkType(c *Checker, t *ast.Expr) {
    assert(t)
    switch t.kind {
    case ast.EXPR_IDENT:
        Checker_resolve(c, c.pkg.scope, t)
        break
    case ast.EXPR_SELECTOR:
        {
            var type = Checker_checkExpr(c, t.selector.x)
            assert(type == nil)
            assert(ast.isIdent(t.selector.x))
            assert(t.selector.x.ident.obj.kind == ast.ObjKind_PKG)
            var oldScope = c.pkg.scope
            c.pkg.scope = t.selector.x.ident.obj.data
            Checker_checkType(c, t.selector.sel)
            c.pkg.scope = oldScope
        }
        break
    case ast.EXPR_STAR:
        Checker_checkType(c, t.star.x)
        break
    case ast.TYPE_ARRAY:
        Checker_checkType(c, t.array_.elt)
        if t.array_.len {
            var len = Checker_checkExpr(c, t.array_.len)
            typ void(len)
        }
        break
    case ast.TYPE_ELLIPSIS:
        break
    case ast.TYPE_ENUM:
        for var i = 0; i < len(t.enum_.enums); i++ {
            var decl = t.enum_.enums[i]
            if t.enum_.name {
                decl.value.type = t.enum_.name
            }
            Checker_declare(c, decl, nil, c.pkg.scope, ast.ObjKind_CON, decl.value.name)
            if decl.value.value {
                Checker_checkExpr(c, decl.value.value)
            }
        }
        break
    case ast.TYPE_FUNC:
        for var i = 0; i < len(t.func.params); i++ {
            var param = t.func.params[i]
            assert(param.kind == ast.DECL_FIELD)
            Checker_checkType(c, param.field.type)
        }
        if t.func.result {
            Checker_checkType(c, t.func.result)
        }
        break
    case ast.TYPE_MAP:
        if t.map_.val {
            Checker_checkType(c, t.map_.val)
        }
        break
    case ast.TYPE_STRUCT:
        if len(t.struct_.fields) > 0 {
            Checker_openScope(c)
            for var i = 0; i < len(t.struct_.fields); i++ {
                var field = t.struct_.fields[i]
                Checker_checkType(c, field.field.type)
                if field.field.name {
                    Checker_declare(c, field, nil, c.pkg.scope, ast.ObjKind_VAL, field.field.name)
                }
            }
            Checker_closeScope(c)
        }
        break
    default:
        Checker_error(c, ast.Expr_pos(t), "unknown type")
        break
    }
}

fun Checker_checkIdent(c *Checker, expr *ast.Expr) *ast.Expr {
    assert(expr.kind == ast.EXPR_IDENT)
    if expr.ident.obj == nil {
        Checker_error(c, ast.Expr_pos(expr), "unresolved identifier")
    }
    return getDeclType(expr.ident.obj.decl)
}

fun isInteger(x *ast.Expr) bool {
    switch x.kind {
    case ast.EXPR_IDENT:
        return isInteger(x.ident.obj.decl.type.type)
    case ast.TYPE_ENUM, ast.TYPE_NATIVE:
        return true
    default:
        return false
    }
}

fun Checker_checkArrayLit(c *Checker, x *ast.Expr) {
    var baseT = getBaseType(x.composite.type)
    for var i = 0; i < len(x.composite.list); i++ {
        var elt = x.composite.list[i]
        if elt.kind == ast.EXPR_KEY_VALUE {
            elt.key_value.isArray = true
            var indexT = Checker_checkExpr(c, elt.key_value.key)
            if !isInteger(indexT) {
                Checker_error(c, ast.Expr_pos(elt), C.sprintf("not a valid index: %s", exprString(elt.key_value.key)))
            }
            elt = elt.key_value.value
        }
        if elt.kind == ast.EXPR_COMPOSITE_LIT {
            if elt.composite.type == nil {
                elt.composite.type = baseT.array_.elt
            } else {
                Checker_checkType(c, elt.composite.type)
            }
            Checker_checkCompositeLit(c, elt)
        } else {
            Checker_checkExpr(c, elt)
        }
    }
}

fun Checker_checkStructLit(c *Checker, x *ast.Expr) {
    assert(x.composite.type)
    var expectKV = false
    for var i = 0; i < len(x.composite.list); i++ {
        var elt = x.composite.list[i]
        var fieldT *ast.Expr = nil
        if elt.kind == ast.EXPR_KEY_VALUE {
            elt.key_value.isArray = false
            expectKV = true
            var key = elt.key_value.key
            if !ast.isIdent(key) {
                Checker_error(c, ast.Expr_pos(x), "key must be an identifier")
            }
            var field = getStructFieldByName(x.composite.type, key)
            if field == nil {
                Checker_error(c, ast.Expr_pos(key),
                    C.sprintf("no member named '%s' in '%s'",
                        exprString(key), typeString(x.composite.type)))
            }
            key.ident.obj = field.field.name.ident.obj
            fieldT = field.field.type
            elt = elt.key_value.value
        } else {
            if expectKV {
                Checker_error(c, ast.Expr_pos(x), "expected a key/value expr")
            }
            var field = getStructField(x.composite.type, i)
            fieldT = field.field.type
        }
        var eltT *ast.Expr = nil
        if elt.kind == ast.EXPR_COMPOSITE_LIT {
            if elt.composite.type == nil {
                elt.composite.type = fieldT
            } else {
                Checker_checkType(c, elt.composite.type)
            }
            eltT = Checker_checkCompositeLit(c, elt)
        } else {
            eltT = Checker_checkExpr(c, elt)
        }
        if !areAssignable(fieldT, eltT) {
            Checker_error(c, ast.Expr_pos(elt), C.sprintf("cannot init field of type `%s` with value of type `%s`", typeString(fieldT), typeString(eltT)))
        }
    }
}

fun Checker_checkCompositeLit(c *Checker, x *ast.Expr) *ast.Expr {
    var t = x.composite.type
    assert(t)
    var baseT = getBaseType(t)
    switch baseT.kind {
    case ast.TYPE_ARRAY:
        Checker_checkArrayLit(c, x)
        break
    case ast.TYPE_STRUCT:
        Checker_checkStructLit(c, x)
        break
    default:
        Checker_error(c, ast.Expr_pos(x), "composite type must be an array or a struct")
        break
    }
    return t
}

fun Checker_lookupIdent(c *Checker, name runtime.charptr) *ast.Expr {
    var obj = ast.Scope_deepLookup(c.pkg.scope, name)
    assert(obj)
    assert(obj.kind == ast.ObjKind_TYP)
    assert(obj.decl.kind == ast.DECL_TYPE)
    var t = obj.decl.type.name
    assert(t.ident.obj)
    return t
}

fun Checker_checkSelector(c *Checker, expr *ast.Expr) *ast.Expr {
    var type *ast.Expr = Checker_checkExpr(c, expr.selector.x) // XXX
    if type == nil {
        // x is a scope
        var x = expr.selector.x
        assert(x.kind == ast.EXPR_IDENT)
        var decl = x.ident.obj.decl
        assert(decl.kind == ast.DECL_IMPORT)
        var oldScope = c.pkg.scope
        c.pkg.scope = x.ident.obj.data
        type = Checker_checkExpr(c, expr.selector.sel)
        c.pkg.scope = oldScope
        expr.selector.tok = token.DOLLAR
        return type
    }
    var isArgPtr = false
    if type.kind == ast.EXPR_STAR {
        expr.selector.tok = token.ARROW
        type = type.star.x
        isArgPtr = true
    } else {
        assert(expr.selector.tok != token.ARROW)
    }
    if var alias = getTypeAlias(type); alias != nil {
        // if type is an alias, check its scope for a method
        if var scope *ast.Scope = alias.ident.obj.data; scope {
            if var obj = ast.Scope_lookup(scope, expr.selector.sel.ident.name); obj {
                Checker_resolve(c, scope, expr.selector.sel)
                assert(obj.kind == ast.ObjKind_FUN)
                expr.selector.tok = token.FUNC
                var recvType = obj.decl.func.recv.field.type
                var isRecvTypePtr = recvType.kind == ast.EXPR_STAR
                if isRecvTypePtr && !isArgPtr {
                    var refer = ast.Expr{
                        kind: ast.EXPR_UNARY,
                        unary: {
                            op: token.AND,
                            x: expr.selector.x,
                        },
                    }
                    expr.selector.x = &&refer
                } else if !isRecvTypePtr && isArgPtr {
                    var deref = ast.Expr{
                        kind: ast.EXPR_STAR,
                        star: {
                            x: expr.selector.x,
                        },
                    }
                    expr.selector.x = &&deref
                }
                return obj.decl.func.type
            }
        }
    }
    if var base = getBaseType(type); base.kind == ast.TYPE_STRUCT {
        if var field = getStructFieldByName(type, expr.selector.sel); field == nil {
            Checker_error(c, ast.Expr_pos(expr),
            C.sprintf("no member named '%s' in '%s'",
            exprString(expr.selector.sel), typeString(type)))
            return nil
        } else {
            expr.selector.sel.ident.obj = field.field.name.ident.obj
            return field.field.type
        }
    }
    Checker_error(c, ast.Expr_pos(expr), "selector on invalid type")
    return nil
}

fun Checker_checkExpr(c *Checker, expr *ast.Expr) *ast.Expr {
    assert(expr)
    switch expr.kind {
    case ast.EXPR_BINARY:
        {
            var typ1 = Checker_checkExpr(c, expr.binary.x)
            var typ2 = Checker_checkExpr(c, expr.binary.y)
            if !areComparable(typ1, typ2) {
                Checker_error(c, ast.Expr_pos(expr), C.sprintf("not compariable: %s and %s", typeString(typ1), typeString(typ2)))
            }
            switch expr.binary.op {
            case token.EQUAL, token.GT, token.GT_EQUAL, token.LAND, token.LOR, token.LT, token.LT_EQUAL, token.NOT_EQUAL:
                return Checker_lookupIdent(c, "bool")
            default:
                return typ1
            }
        }
    case ast.EXPR_BASIC_LIT:
        switch expr.basic.kind {
        case token.CHAR:
            return Checker_lookupIdent(c, "char")
        case token.FLOAT:
            return Checker_lookupIdent(c, "float")
        case token.INT:
            return Checker_lookupIdent(c, "int")
        case token.STRING:
            return makePtr(Checker_lookupIdent(c, "char"))
        default:
            Checker_error(c, ast.Expr_pos(expr), "unreachable")
            return nil
        }
    case ast.EXPR_CALL:
        {
            var func = expr.call.func
            var type = Checker_checkExpr(c, func)
            if type.kind == ast.EXPR_STAR {
                type = type.star.x
            }
            if type.kind == ast.TYPE_BUILTIN {
                var n = len(expr.call.args)
                if type.builtin.variadic {
                    assert(n >= type.builtin.nargs)
                } else {
                    assert(n == type.builtin.nargs)
                }
                switch type.builtin.id {
                case LEN:
                    Checker_checkExpr(c, expr.call.args[0])
                    return Checker_lookupIdent(c, "int")
                case MAKEARRAY:
                    type = expr.call.args[0]
                    Checker_checkType(c, type)
                    if !isType(type) {
                        Checker_error(c, ast.Expr_pos(type), "expected a type")
                    }
                    {
                        var t = ast.Expr{
                            kind: ast.TYPE_ARRAY,
                            array_: {
                                elt: type,
                                dynamic: true,
                            },
                        }
                        type = &&t
                    }
                    return type
                case MAKEMAP:
                    type = expr.call.args[0]
                    Checker_checkType(c, type)
                    if !isType(type) {
                        Checker_error(c, ast.Expr_pos(type), "expected a type")
                    }
                    {
                        var t = ast.Expr{
                            kind: ast.TYPE_MAP,
                            map_: {
                                val: type,
                            },
                        }
                        type = &&t
                    }
                    return type
                default:
                    assert(!type.builtin.isExpr)
                    for var i = 0; i < len(expr.call.args); i++ {
                        Checker_checkExpr(c, expr.call.args[i])
                    }
                    return nil
                }
            } else if type.kind == ast.TYPE_FUNC {
                var j = 0
                for var i = 0; i < len(expr.call.args); i++ {
                    var param = type.func.params[j]
                    if param == nil {
                        Checker_error(c, ast.Expr_pos(expr), "too many args")
                        break
                    }
                    var type = Checker_checkExpr(c, expr.call.args[i])
                    assert(param.kind == ast.DECL_FIELD)
                    if !areAssignable(param.field.type, type) {
                        Checker_error(c, ast.Expr_pos(expr), C.sprintf("not assignable: %s and %s", typeString(param.field.type), typeString(type)))
                    }
                    if param.field.type.kind != ast.TYPE_ELLIPSIS {
                        j++
                    }
                }
                return type.func.result
            } else {
                Checker_error(c, ast.Expr_pos(expr), C.sprintf("`%s` is not a func", exprString(expr.call.func)))
            }
        }
    case ast.EXPR_COMPOSITE_LIT:
        Checker_checkType(c, expr.composite.type)
        Checker_checkCompositeLit(c, expr)
        return expr.composite.type
    case ast.EXPR_CAST:
        Checker_checkType(c, expr.cast.type)
        Checker_checkExpr(c, expr.cast.expr)
        return expr.cast.type
    case ast.EXPR_IDENT:
        Checker_resolve(c, c.pkg.scope, expr)
        return Checker_checkIdent(c, expr)
    case ast.EXPR_INDEX:
        {
            var type = Checker_checkExpr(c, expr.index.x)
            var base = getBaseType(type)
            switch base.kind {
            case ast.TYPE_ARRAY:
                type = base.array_.elt
                break
            case ast.EXPR_STAR:
                type = base.star.x
                break
            default:
                Checker_error(c, ast.Expr_pos(expr), C.sprintf("indexing a non-array or pointer `%s`", typeString(type)))
                break
            }
            var typ2 = Checker_checkExpr(c, expr.index.index)
            typ void(typ2)
            return type
        }
    case ast.EXPR_PAREN:
        return Checker_checkExpr(c, expr.paren.x)
    case ast.EXPR_SELECTOR:
        return Checker_checkSelector(c, expr)
    case ast.EXPR_SIZEOF:
        Checker_checkType(c, expr.sizeof_.x)
        return Checker_lookupIdent(c, "u64")
    case ast.EXPR_STAR:
        {
            var type = Checker_checkExpr(c, expr.star.x)
            var base = getBaseType(type)
            switch base.kind {
            case ast.EXPR_STAR:
                return base.star.x
            case ast.TYPE_ARRAY:
                Checker_warning(c, ast.Expr_pos(expr), C.sprintf("derefencing an array `%s`", typeString(type)))
                return base.array_.elt
            default:
                Checker_error(c, ast.Expr_pos(expr), C.sprintf("derefencing a non-pointer `%s`", typeString(type)))
                return nil
            }
        }
    case ast.EXPR_TERNARY:
        {
            var t1 = Checker_checkExpr(c, expr.ternary.cond)
            assert(isArithmetic(t1))
            var t2 = expr.ternary.x ? Checker_checkExpr(c, expr.ternary.x) : t1
            var t3 = Checker_checkExpr(c, expr.ternary.y)
            if !areComparable(t2, t3) {
                Checker_error(c, ast.Expr_pos(expr), "not comparable")
            }
            return t2
        }
    case ast.EXPR_UNARY:
        {
            var type = Checker_checkExpr(c, expr.unary.x)
            switch expr.unary.op {
            case token.AND:
                if !isLhs(expr.unary.x) {
                    Checker_error(c, ast.Expr_pos(expr), C.sprintf("invalid lvalue `%s`", exprString(expr.unary.x)))
                }
                return makePtr(type)
            case token.LAND:
                return makePtr(type)
            default:
                break
            }
            return type
        }
    default:
        Checker_error(c, ast.Expr_pos(expr), "unknown expr")
        return nil
    }
}

fun Checker_checkStmt(c *Checker, stmt *ast.Stmt) {
    switch stmt.kind {
    case ast.STMT_ASSIGN:
        {
            if !isLhs(stmt.assign.x) {
                Checker_error(c, ast.Stmt_pos(stmt), C.sprintf("invalid lvalue `%s`", exprString(stmt.assign.x)))
            }
            var a = Checker_checkExpr(c, stmt.assign.x)
            if a.is_const {
                Checker_error(c, ast.Stmt_pos(stmt), "cannot assign to const var")
            }
            var b = Checker_checkExpr(c, stmt.assign.y)
            if !areAssignable(a, b) {
                Checker_error(c, ast.Stmt_pos(stmt), C.sprintf("not assignable: `%s` and `%s`", typeString(a), typeString(b)))
            }
        }
        break
    case ast.STMT_BLOCK:
        Checker_openScope(c)
        for var i = 0; i < len(stmt.block.stmts); i++ {
            Checker_checkStmt(c, stmt.block.stmts[i])
        }
        Checker_closeScope(c)
        break
    case ast.STMT_DECL:
        Checker_checkDecl(c, stmt.decl.decl)
        break
    case ast.STMT_EXPR:
        Checker_checkExpr(c, stmt.expr.x)
        break
    case ast.STMT_EMPTY:
        break
    case ast.STMT_IF:
        if stmt.if_.init {
            Checker_openScope(c)
            Checker_checkStmt(c, stmt.if_.init)
        }
        Checker_checkExpr(c, stmt.if_.cond)
        Checker_checkStmt(c, stmt.if_.body)
        if stmt.if_.else_ {
            Checker_checkStmt(c, stmt.if_.else_)
        }
        if stmt.if_.init {
            Checker_closeScope(c)
        }
        break
    case ast.STMT_ITER:
        if stmt.iter.init || stmt.iter.post {
            Checker_openScope(c)
        }
        if stmt.iter.init {
            Checker_checkStmt(c, stmt.iter.init)
        }
        if stmt.iter.cond {
            Checker_checkExpr(c, stmt.iter.cond)
        }
        if stmt.iter.post {
            Checker_checkStmt(c, stmt.iter.post)
        }
        Checker_checkStmt(c, stmt.iter.body)
        if stmt.iter.init || stmt.iter.post {
            Checker_closeScope(c)
        }
        break
    case ast.STMT_JUMP:
        break
    case ast.STMT_LABEL:
        Checker_checkStmt(c, stmt.label.stmt)
        break
    case ast.STMT_POSTFIX:
        Checker_checkExpr(c, stmt.postfix.x)
        break
    case ast.STMT_RETURN:
        if stmt.return_.x {
            var a = c.result
            var b = Checker_checkExpr(c, stmt.return_.x)
            if a == nil {
                Checker_error(c, ast.Stmt_pos(stmt), "returning value in void function")
            }
            if !areAssignable(a, b) {
                Checker_error(c, ast.Stmt_pos(stmt), C.sprintf("not returnable: %s and %s", typeString(a), typeString(b)))
            }
        }
        break
    case ast.STMT_SWITCH:
        {
            var type1 = Checker_checkExpr(c, stmt.switch_.tag)
            for var i = 0; i < len(stmt.switch_.stmts); i++ {
                var clause = stmt.switch_.stmts[i]
                assert(clause.kind == ast.STMT_CASE)
                for var j = 0; j < len(clause.case_.exprs); j++ {
                    var type2 = Checker_checkExpr(c, clause.case_.exprs[j])
                    if !areComparable(type1, type2) {
                        Checker_error(c, ast.Stmt_pos(stmt), C.sprintf("not comparable: %s and %s", typeString(type1), typeString(type2)))
                    }
                }
                for var j = 0; j < len(clause.case_.stmts); j++ {
                    Checker_checkStmt(c, clause.case_.stmts[j])
                }
            }
        }
        break
    default:
        Checker_error(c, ast.Stmt_pos(stmt), "unknown stmt")
    }
}

fun Checker_checkImport(c *Checker, imp *ast.Decl) *Package {
    var path = constant_stringVal(imp.imp.path)
    var pkg *Package = nil
    runtime.Map_get(&c.info.imports, path, &pkg)
    if pkg == nil {
        var files = parser.parseDir(c.fset, path, nil)
        pkg = check(c.conf, path, c.fset, files, c.info)
        assert(runtime.Map_get(&c.info.imports, path, nil))
    }
    imp.imp.name = makeIdent(pkg.scope.pkgName.ident.name)
    Checker_declare(c, imp, pkg.scope, c.pkg.scope, ast.ObjKind_PKG, imp.imp.name)
    return pkg
}

fun Checker_checkDecl(c *Checker, decl *ast.Decl) {
    switch decl.kind {
    case ast.DECL_FUNC:
        {
            Checker_checkType(c, decl.func.type)
            Checker_openScope(c)
            if var recv = decl.func.recv; recv != nil {
                // declare recv in method scope
                Checker_declare(c, recv, nil, c.pkg.scope, ast.ObjKind_VAL, recv.field.name)
            }
            var type = decl.func.type
            for var i = 0; i < len(type.func.params); i++ {
                if var param = type.func.params[i]; param.field.name != nil {
                    Checker_declare(c, param, nil, c.pkg.scope, ast.ObjKind_VAL,
                        param.field.name)
                }
            }
            if var body = decl.func.body; body != nil && !c.conf.ignoreFuncBodies {
                c.result = type.func.result
                for var i = 0; i < len(body.block.stmts); i++ {
                    Checker_checkStmt(c, body.block.stmts[i])
                }
                c.result = nil
            }
            Checker_closeScope(c)
            break
        }
    case ast.DECL_PRAGMA:
        break
    case ast.DECL_TYPE:
        switch decl.type.type.kind {
        case ast.TYPE_ENUM:
            decl.type.type.enum_.name = decl.type.name
            break
        case ast.TYPE_STRUCT:
            decl.type.type.struct_.name = decl.type.name
            break
        default:
            break
        }
        Checker_checkType(c, decl.type.type)
        break
    case ast.DECL_VALUE:
        {
            var valType *ast.Expr = nil
            if decl.value.type != nil {
                Checker_checkType(c, decl.value.type)
            }
            if decl.value.value != nil {
                if decl.value.value.kind == ast.EXPR_COMPOSITE_LIT {
                    if decl.value.value.composite.type == nil {
                        decl.value.value.composite.type = decl.value.type
                    } else {
                        Checker_checkType(c, decl.value.value.composite.type)
                    }
                    valType = Checker_checkCompositeLit(c, decl.value.value)
                } else {
                    valType = Checker_checkExpr(c, decl.value.value)
                }
            }
            if decl.value.type == nil {
                decl.value.type = valType
            }
            if valType != nil {
                var varType = decl.value.type
                if !areAssignable(varType, valType) {
                    Checker_error(c, decl.pos, C.sprintf("not assignable %s and %s", typeString(varType), typeString(valType)))
                }
            }
            Checker_declare(c, decl, nil, c.pkg.scope, ast.ObjKind_VAL, decl.value.name)
            break
        }
    default:
        Checker_error(c, decl.pos, "unreachable")
    }
}

fun Checker_checkFile(c *Checker, file *ast.File) {
    for var i = 0; i < len(file.imports); i++ {
        var pkg = Checker_checkImport(c, file.imports[i])
        append(c.pkg.imports, pkg)
    }
    for var i = 0; i < len(file.decls); i++ {
        var kind = ast.ObjKind_BAD
        var decl = file.decls[i]
        switch decl.kind {
        case ast.DECL_FUNC:
            if var recv = decl.func.recv; recv {
                var type = recv.field.type
                Checker_checkType(c, type)
                if type.kind == ast.EXPR_STAR {
                    type = type.star.x
                }
                if type.kind != ast.EXPR_IDENT {
                    Checker_error(c, ast.Expr_pos(recv.field.type),
                        "can't declare method on non-alias")
                }
                var obj = type.ident.obj
                var typeScope *ast.Scope = obj.data
                if obj.data == nil {
                    typeScope = ast.Scope_new(c.pkg.scope)
                    typeScope.pkgName = type
                    obj.data = typeScope
                }
                assert(obj.data)
                assert(typeScope.pkgName)
                // declare method in pkg scope
                Checker_declare(c, decl, obj.data, typeScope, ast.ObjKind_FUN, decl.func.name)
                continue // don't declare methods
            }
            kind = ast.ObjKind_FUN
            break
        case ast.DECL_TYPE:
            kind = ast.ObjKind_TYP
            break
        default:
            continue
        }
        Checker_declare(c, decl, nil, c.pkg.scope, kind, decl.type.name)
    }
    for var i = 0; i < len(file.decls); i++ {
        Checker_checkDecl(c, file.decls[i])
    }
}

fun newInfo() *Info {
    var info Info = {
        imports: makemap(*Package),
    }
    return &&info
}

fun checkFile(conf *Config, path runtime.charstr, fset *token.FileSet, file *ast.File, info *Info) *Package {
    if info {
        var pkg *Package = nil
        runtime.Map_get(&info.imports, path, &pkg)
        if pkg {
            return pkg
        }
    } else {
        info = newInfo()
    }
    var scope = ast.Scope_new(universe())
    scope.pkgName = file.name
    var pkg Package = {
        path: runtime.strdup(path),
        name: file.name ? runtime.strdup(file.name.ident.name) : nil,
        scope: scope,
        imports: makearray(*Package),
    }
    var c Checker = {
        info: info,
        fset: fset,
        conf: conf,
        pkg: &&pkg,
    }
    runtime.Map_set(&info.imports, path, &c.pkg)
    Checker_checkFile(&c, file)
    return c.pkg
}

fun check(conf *Config, path runtime.charstr, fset *token.FileSet, files []*ast.File, info *Info) *Package {
    assert(len(files) == 1)
    return checkFile(conf, path, fset, files[0], info)
}

var _universe *ast.Scope = nil

var predeclaredTypes [?]const Basic = {
    INVALID: { INVALID, 0, "invalid type", },
    VOID: { VOID, IS_UNTYPED, "void", },
    BOOL: { BOOL, IS_BOOLEAN, "bool", },
    CHAR: { CHAR, IS_INTEGER, "char", },
    INT: { INT, IS_INTEGER, "int", },
    INT8: { INT8, IS_INTEGER, "i8", },
    INT16: { INT16, IS_INTEGER, "i16", },
    INT32: { INT32, IS_INTEGER, "i32", },
    INT64: { INT64, IS_INTEGER, "i64", },
    UINT: { UINT, IS_INTEGER | IS_UNSIGNED, "uint", },
    UINT8: { UINT8, IS_INTEGER | IS_UNSIGNED, "u8", },
    UINT16: { UINT16, IS_INTEGER | IS_UNSIGNED, "u16", },
    UINT32: { UINT32, IS_INTEGER | IS_UNSIGNED, "u32", },
    UINT64: { UINT64, IS_INTEGER | IS_UNSIGNED, "u64", },
    UINTPTR: { UINTPTR, IS_INTEGER | IS_UNSIGNED, "uintptr", },
    FLOAT32: { FLOAT32, IS_FLOAT, "float", },
    FLOAT64: { FLOAT64, IS_FLOAT, "double", },
    VOID_POINTER: { VOID_POINTER, 0, "voidptr", },
}

fun defPredeclaredTypes() {
    for var i = 0; i < UNSAFE_POINTER; i++ {
        if !predeclaredTypes[i].name {
            continue
        }
        var obj = ast.newObject(ast.ObjKind_TYP, predeclaredTypes[i].name)
        var name = ast.Expr{
            kind: ast.EXPR_IDENT,
            ident: {
                name: runtime.strdup(predeclaredTypes[i].name),
                obj: obj,
            },
        }
        var type = ast.Expr{
            kind: ast.TYPE_NATIVE,
            native: {
                kind: predeclaredTypes[i].kind,
                info: predeclaredTypes[i].info,
                name: runtime.strdup(predeclaredTypes[i].name),
            },
        }
        var decl = ast.Decl{
            kind: ast.DECL_TYPE,
            type: {
                name: &&name,
                type: &&type,
            },
        }
        obj.decl = &&decl
        assert(ast.Scope_insert(_universe, obj) == nil)
    }
}

var predeclareFuncs [?]struct {
    name runtime.charptr
    nargs int
    variadic bool
    kind exprKind
} = {
    APPEND: { "append", 2, false, statement, },
    ASSERT: { "assert", 1, false, statement, },
    LEN: { "len", 1, false, expression, },
    MAKEARRAY: { "makearray", 1, false, expression, },
    MAKEMAP: { "makemap", 1, false, expression, },
    PANIC: { "panic", 1, false, statement, },
    PRINT: { "print", 1, false, statement, },
}

fun defPredeclaredFuncs() {
    for var i = 0; i < numBuiltinIds; i++ {
        var name = ast.Expr{
            kind: ast.EXPR_IDENT,
            ident: {
                name: runtime.strdup(predeclareFuncs[i].name),
            },
        }
        var type = ast.Expr{
            kind: ast.TYPE_BUILTIN,
            builtin: {
                name: runtime.strdup(predeclareFuncs[i].name),
                nargs: predeclareFuncs[i].nargs,
                variadic: predeclareFuncs[i].variadic,
                isExpr: predeclareFuncs[i].kind == expression,
                id: i,
            },
        }
        var decl = ast.Decl{
            kind: ast.DECL_FUNC,
            func: {
                name: &&name,
                type: &&type,
            },
        }
        var obj = ast.newObject(ast.ObjKind_FUN, name.ident.name)
        obj.decl = &&decl
        obj.decl.func.name.ident.obj = obj
        assert(ast.Scope_insert(_universe, obj) == nil)
    }
}

var predeclareConsts [?]struct {
    name runtime.charptr
    type runtime.charptr
    value int
} = {
    {"nil", "voidptr", 0},
    {"false", "bool", 0},
    {"true", "bool", 1},
    {nil},
}

fun defPredeclaredConsts() {
    for var i = 0; predeclareConsts[i].name; i++ {
        var obj = ast.Scope_lookup(_universe, predeclareConsts[i].type)
        var name = ast.Expr{
            kind: ast.EXPR_IDENT,
            ident: {
                name: runtime.strdup(predeclareConsts[i].name),
            },
        }
        var expr = ast.Expr{
            kind: ast.EXPR_CONST,
            const_: {
                name: runtime.strdup(predeclareConsts[i].name),
                type: obj.decl.type.name,
                value: predeclareConsts[i].value,
            },
        }
        var decl = ast.Decl{
            kind: ast.DECL_VALUE,
            value: {
                name: &&name,
                type: obj.decl.type.name,
                value: &&expr,
            },
        }
        obj = ast.newObject(ast.ObjKind_CON, name.ident.name)
        obj.decl = &&decl
        obj.decl.value.name.ident.obj = obj
        assert(ast.Scope_insert(_universe, obj) == nil)
    }
}

fun universe() *ast.Scope {
    if _universe == nil {
        _universe = ast.Scope_new(nil)
        defPredeclaredTypes()
        defPredeclaredConsts()
        defPredeclaredFuncs()
    }
    return _universe
}
