package types

import "C"
import "bling/ast"
import "bling/emitter"
import "bling/token"
import "runtime"

typ Config struct {
    strict bool
    cMode bool
    ignoreFuncBodies bool
}

typ Package struct {
    path runtime.charptr
    name runtime.charptr
    scope *ast.Scope
    imports []*Package
}

typ Info struct {
    imports map *Package
}

fun constant_stringVal(x *ast.Expr) runtime.charptr {
    assert(x.kind == ast.EXPR_BASIC_LIT)
    var lit runtime.charstr = x.basic.value
    var n = runtime.strlen(lit) - 2
    var val runtime.charptr = runtime.malloc(n + 1)
    for var i = 0; i < n; i++ {
        val[i] = lit[i + 1]
    }
    val[n] = '\0'
    return val
}

fun declString(decl *ast.Decl) runtime.charptr {
    var e = emitter.Emitter{}
    emitter.emitDecl(&e, decl)
    return emitter.Emitter_string(&e)
}

fun exprString(expr *ast.Expr) runtime.charptr {
    var e = emitter.Emitter{}
    emitter.emitExpr(&e, expr)
    return emitter.Emitter_string(&e)
}

fun stmtString(stmt *ast.Stmt) runtime.charptr {
    var e = emitter.Emitter{}
    emitter.emitStmt(&e, stmt)
    return emitter.Emitter_string(&e)
}

fun typeString(expr *ast.Expr) runtime.charptr {
    var e = emitter.Emitter{}
    emitter.emitType(&e, expr)
    return emitter.Emitter_string(&e)
}

fun isType(expr *ast.Expr) bool {
    for ;; {
        switch expr.kind {
        case ast.EXPR_IDENT:
            if expr.ident.obj == nil {
                panic(C.sprintf("unresolved identifier %s", expr.ident.name))
            }
            return expr.ident.obj.kind == ast.ObjKind_TYP
        case ast.EXPR_SELECTOR:
            expr = expr.selector.sel
            break
        case ast.EXPR_STAR:
            expr = expr.star.x
            break
        case ast.TYPE_ARRAY, ast.TYPE_ENUM, ast.TYPE_FUNC, ast.TYPE_MAP, ast.TYPE_NATIVE, ast.TYPE_STRUCT:
            return true
        default:
            return false
        }
    }
}

fun getTypeAlias(t *ast.Expr) *ast.Expr {
    for ;; {
        switch t.kind {
        case ast.EXPR_SELECTOR:
            t = t.selector.sel
            break
        case ast.EXPR_IDENT:
            if t.ident.obj.kind == ast.ObjKind_TYP {
                return t
            }
            return nil
        default:
            return nil
        }
    }
}

fun isTypeAlias(t *ast.Expr) bool {
    return getTypeAlias(t) != nil
}

fun makeIdent(name runtime.charstr) *ast.Expr {
    var x = ast.Expr{
        kind: ast.EXPR_IDENT,
        ident: {
            name: runtime.strdup(name),
        },
    }
    return &&x
}

fun makePtr(type *ast.Expr) *ast.Expr {
    var x = ast.Expr{
        kind: ast.EXPR_STAR,
        star: {
            x: type,
        },
    }
    return &&x
}

fun getUnderlyingType(ident *ast.Expr) *ast.Expr {
    for ;; {
        switch ident.kind {
        case ast.EXPR_IDENT:
            if ident.ident.obj == nil {
                panic(C.sprintf("not resolved: %s", typeString(ident)))
            }
            var decl = ident.ident.obj.decl
            if decl.kind != ast.DECL_TYPE {
                panic(C.sprintf("not a type: %s", typeString(ident)))
            }
            return decl.type.type
        default:
            panic(C.sprintf("not an alias: %s", typeString(ident)))
            return nil
        }
    }
}

fun getBaseType(type *ast.Expr) *ast.Expr {
    for ;; {
        switch type.kind {
        case ast.EXPR_IDENT:
            type = getUnderlyingType(type)
            break
        case ast.EXPR_SELECTOR:
            type = type.selector.sel
            break
        case ast.EXPR_STAR, ast.TYPE_ARRAY, ast.TYPE_ENUM, ast.TYPE_MAP, ast.TYPE_NATIVE, ast.TYPE_STRUCT:
            return type
        default:
            panic(C.sprintf("not a type: %s", typeString(type)))
        }
    }
}

fun isDynamicArray(t *ast.Expr) bool {
    t = getBaseType(t)
    return t && t.kind == ast.TYPE_ARRAY && t.array_.dynamic
}

fun getType(x *ast.Expr) *ast.Expr {
    switch x.kind {
    case ast.EXPR_PAREN:
        return getType(x.paren.x)
    case ast.EXPR_CAST:
        return x.cast.type
    case ast.EXPR_IDENT:
        switch x.ident.obj.kind {
        case ast.ObjKind_CON, ast.ObjKind_VAL:
            return x.ident.obj.decl.value.type
        default:
            break
        }
        break
    case ast.EXPR_SELECTOR:
        return getType(x.selector.sel)
    case ast.EXPR_STAR:
        var t = getType(x.star.x)
        assert(t.kind == ast.EXPR_STAR)
        return t.star.x
    default:
        break
    }
    panic(exprString(x))
    return nil
}

fun isArithmetic(type *ast.Expr) bool {
    switch type.kind {
    case ast.EXPR_IDENT:
        return isArithmetic(getBaseType(type))
    case ast.EXPR_STAR, ast.TYPE_ENUM:
        return true
    case ast.TYPE_NATIVE:
        return !runtime.streq(type.native.name, "void")
    default:
        return false
    }
}

fun isNative(type *ast.Expr, name runtime.charstr) bool {
    switch type.kind {
    case ast.EXPR_IDENT:
        return runtime.streq(type.ident.name, name)
    case ast.TYPE_NATIVE:
        return true
    default:
        return false
    }
}

fun areIdentical(a *ast.Expr, b *ast.Expr) bool {
    if a == b {
        return true
    }
    if a == nil || b == nil {
        return false
    }
    if a.kind == ast.TYPE_MAP || b.kind == ast.TYPE_MAP {
        return true
    }
    assert(a)
    assert(b)
    if a.kind == ast.EXPR_SELECTOR {
        a = a.selector.sel
    }
    if b.kind == ast.EXPR_SELECTOR {
        b = b.selector.sel
    }
    if a.kind != b.kind {
        return false
    }
    switch a.kind {
    case ast.EXPR_IDENT:
        return b.kind == ast.EXPR_IDENT && a.ident.obj == a.ident.obj
    case ast.EXPR_STAR:
        return areIdentical(a.star.x, b.star.x)
    case ast.TYPE_ARRAY:
        return areIdentical(a.array_.elt, b.array_.elt)
    case ast.TYPE_FUNC:
        if !areIdentical(a.func.result, b.func.result) {
            return false
        }
        var i = 0
        if len(a.func.params) {
            for ; i < len(a.func.params); i++ {
                var param1 = a.func.params[i]
                var param2 = b.func.params[i]
                if param2 == nil {
                    return false
                }
                if !areIdentical(param1.field.type, param2.field.type) {
                    return false
                }
            }
            if b.func.params[i] {
                return false
            }
        }
        return true
    default:
        panic(C.sprintf("not implemented: %s == %s", typeString(a), typeString(b)))
        return false
    }
}

fun isPointer(t *ast.Expr) bool {
    t = getBaseType(t)
    return t.kind == ast.EXPR_STAR || (t.kind == ast.TYPE_ARRAY && !t.array_.dynamic)
}

fun pointerBase(t *ast.Expr) *ast.Expr {
    t = getBaseType(t)
    switch t.kind {
    case ast.EXPR_STAR:
        return t.star.x
    case ast.TYPE_ARRAY:
        return t.array_.elt
    default:
        panic(C.sprintf("not a pointer: %s", typeString(t)))
        return nil
    }
}

fun areAssignable(a *ast.Expr, b *ast.Expr) bool {
    if a.kind == ast.TYPE_ELLIPSIS {
        return true
    }
    if areIdentical(a, b) {
        return true
    }
    a = getBaseType(a)
    b = getBaseType(b)
    if ast.isVoidPtr(a) || ast.isVoidPtr(b) {
        return true
    }
    if isPointer(a) && isPointer(b) {
        return areAssignable(pointerBase(a), pointerBase(b))
    }
    if isNative(a, "bool") && isArithmetic(b) {
        return true
    }
    if b.kind == ast.TYPE_ENUM && isArithmetic(a) {
        return true
    }
    if a.kind == ast.TYPE_ENUM && isArithmetic(b) {
        return true
    }
    return areIdentical(a, b)
}

fun areComparable(a *ast.Expr, b *ast.Expr) bool {
    if areIdentical(a, b) {
        return true
    }
    if isArithmetic(a) && isArithmetic(b) {
        return true
    }
    if a.kind == ast.EXPR_STAR && isNative(b, "int") {
        return true
    }
    return areIdentical(a, b)
}

fun isLhs(expr *ast.Expr) bool {
    switch expr.kind {
    case ast.EXPR_IDENT, ast.EXPR_SELECTOR:
        return true
    case ast.EXPR_CAST:
        return isLhs(expr.cast.expr)
    case ast.EXPR_INDEX:
        return isLhs(expr.index.x)
    case ast.EXPR_PAREN:
        return isLhs(expr.paren.x)
    case ast.EXPR_STAR:
        return isLhs(expr.star.x)
    default:
        return false
    }
}

fun getDeclType(decl *ast.Decl) *ast.Expr {
    assert(decl)
    switch decl.kind {
    case ast.DECL_FIELD:
        return decl.field.type
    case ast.DECL_FUNC:
        return decl.func.type
    case ast.DECL_IMPORT:
        return nil
    case ast.DECL_TYPE:
        return decl.type.type
    case ast.DECL_VALUE:
        return decl.value.type
    default:
        panic(C.sprintf("unhandled decl: %s", declString(decl)))
        return nil
    }
}

fun getStructFieldByName(type *ast.Expr, name *ast.Expr) *ast.Decl {
    var base *ast.Expr = getBaseType(type)
    assert(base.kind == ast.TYPE_STRUCT)
    assert(name.kind == ast.EXPR_IDENT)
    for var i = 0; i < len(base.struct_.fields); i++ {
        var field = base.struct_.fields[i]
        if field.field.name {
            if runtime.streq(name.ident.name, field.field.name.ident.name) {
                base = field.field.type
                return field
            }
        } else {
            var subField = getStructFieldByName(field.field.type, name)
            if subField {
                return subField
            }
        }
    }
    return nil
}

fun getStructField(type *ast.Expr, index int) *ast.Decl {
    var base = getBaseType(type)
    if base.kind != ast.TYPE_STRUCT {
        panic(C.sprintf("not a struct: %s", typeString(type)))
    }
    if len(base.struct_.fields) == 0 {
        panic(C.sprintf("incomplete field defn: %s", typeString(type)))
    }
    if 0 <= index && index < len(base.struct_.fields) {
        return base.struct_.fields[index]
    }
    return nil
}

fun isInteger(x *ast.Expr) bool {
    switch x.kind {
    case ast.EXPR_IDENT:
        return isInteger(x.ident.obj.decl.type.type)
    case ast.TYPE_ENUM, ast.TYPE_NATIVE:
        return true
    default:
        return false
    }
}

fun newInfo() *Info {
    var info Info = {
        imports: makemap(*Package),
    }
    return &&info
}

fun checkFiles(conf *Config, path runtime.charstr, fset *token.FileSet,
        files []*ast.File, info *Info) *Package {
    var file = files[0]
    if info {
        var pkg *Package = nil
        runtime.Map_get(&info.imports, path, &pkg)
        if pkg {
            return pkg
        }
    } else {
        info = newInfo()
    }
    var scope = ast.newScope(universe())
    scope.pkgName = file.name
    var pkg Package = {
        path: runtime.strdup(path),
        name: file.name ? runtime.strdup(file.name.ident.name) : nil,
        scope: scope,
        imports: makearray(*Package),
    }
    var c Checker = {
        info: info,
        fset: fset,
        conf: conf,
        pkg: &&pkg,
    }
    runtime.Map_set(&info.imports, path, &c.pkg)
    c.checkFiles(files)
    return c.pkg
}

fun check(conf *Config, path runtime.charstr, fset *token.FileSet,
        files []*ast.File, info *Info) *Package {
    return checkFiles(conf, path, fset, files, info)
}
