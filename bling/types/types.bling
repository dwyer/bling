package types

import "bling/ast"
import "bling/emitter"
import "bling/parser"
import "bling/token"
import "paths"
import "sys"
import "utils"

typedef Config struct {
    strict bool
    cMode bool
}

fun constant_stringVal(x *ast.Expr) *char {
    assert(x.kind == ast.EXPR_BASIC_LIT)
    var lit *const char = x.basic.value
    var n int = strlen(lit) - 2
    var val *char = malloc(n + 1)
    for var i int = 0; i < n; i++ {
        val[i] = lit[i + 1]
    }
    val[n] = '\0'
    return val
}

var natives []struct {
    name *char
    size int
    arith bool
} = {
    {
        "char",
        sizeof(char),
        true,
    },
    {
        "double",
        sizeof(double),
        true,
    },
    {
        "float",
        sizeof(float),
        true,
    },
    {
        "int",
        sizeof(int),
        true,
    },
    {
        "void",
        sizeof(void),
    },
    {
        "int16_t",
        sizeof(int16_t),
        true,
    },
    {
        "int32_t",
        sizeof(int32_t),
        true,
    },
    {
        "int64_t",
        sizeof(int64_t),
        true,
    },
    {
        "int8_t",
        sizeof(int8_t),
        true,
    },
    {
        "size_t",
        sizeof(size_t),
        true,
    },
    {
        "uint16_t",
        sizeof(uint16_t),
        true,
    },
    {
        "uint32_t",
        sizeof(uint32_t),
        true,
    },
    {
        "uint64_t",
        sizeof(uint64_t),
        true,
    },
    {
        "uint8_t",
        sizeof(uint8_t),
        true,
    },
    {
        "uintptr_t",
        sizeof(uintptr_t),
        true,
    },
    {
        NULL,
    },
}

fun declString(decl *ast.Decl) *char {
    var e emitter.Emitter = {}
    emitter.emitDecl(&e, decl)
    return emitter.Emitter_string(&e)
}

fun exprString(expr *ast.Expr) *char {
    var e emitter.Emitter = {}
    emitter.emitExpr(&e, expr)
    return emitter.Emitter_string(&e)
}

fun stmtString(stmt *ast.Stmt) *char {
    var e emitter.Emitter = {}
    emitter.emitStmt(&e, stmt)
    return emitter.Emitter_string(&e)
}

fun typeString(expr *ast.Expr) *char {
    var e emitter.Emitter = {}
    emitter.emitType(&e, expr)
    return emitter.Emitter_string(&e)
}

fun isType(expr *ast.Expr) bool {
    switch expr.kind {
    case ast.EXPR_IDENT:
        if expr.ident.obj == NULL {
            panic("types$isType: unresolved identifier %s", expr.ident.name)
        }
        return expr.ident.obj.decl.kind == ast.DECL_TYPEDEF
    case ast.EXPR_STAR: return isType(expr.star.x)
    case ast.TYPE_ARRAY, ast.TYPE_ENUM, ast.TYPE_FUNC, ast.TYPE_NATIVE, ast.TYPE_STRUCT: return true
    default: return false
    }
}

fun makeIdent(name *const char) *ast.Expr {
    var x ast.Expr = {
        kind: ast.EXPR_IDENT,
        ident: {
            name: strdup(name),
        },
    }
    return esc(x)
}

fun makePtr(type *ast.Expr) *ast.Expr {
    var x ast.Expr = {
        kind: ast.EXPR_STAR,
        star: {
            x: type,
        },
    }
    return esc(x)
}

fun getUnderlyingType(ident *ast.Expr) *ast.Expr {
    var decl *ast.Decl = ident.ident.obj.decl
    if decl.kind != ast.DECL_TYPEDEF {
        panic("not a type: %s", typeString(ident))
    }
    return decl.typedef_.type
}

fun getBaseType(type *ast.Expr) *ast.Expr {
    for ;; {
        switch type.kind {
        case ast.EXPR_IDENT:
            type = getUnderlyingType(type)
            break
        case ast.EXPR_SELECTOR:
            type = type.selector.sel
            break
        case ast.TYPE_ARRAY, ast.TYPE_ENUM, ast.TYPE_NATIVE, ast.TYPE_STRUCT: return type
        default:
            panic("not a type: %s", typeString(type))
        }
    }
}

fun isArithmetic(type *ast.Expr) bool {
    switch type.kind {
    case ast.EXPR_IDENT: return isArithmetic(getBaseType(type))
    case ast.EXPR_STAR, ast.TYPE_ENUM: return true
    case ast.TYPE_NATIVE: return !streq(type.native.name, "void")
    default: return false
    }
}

fun isNative(type *ast.Expr, name *const char) bool {
    switch type.kind {
    case ast.EXPR_IDENT: return streq(type.ident.name, name)
    case ast.TYPE_NATIVE: return true
    default: return false
    }
}

fun areIdentical(a *ast.Expr, b *ast.Expr) bool {
    if a == b {
        return true
    }
    if a == NULL || b == NULL {
        return false
    }
    assert(a)
    assert(b)
    if a.kind == ast.EXPR_SELECTOR {
        a = a.selector.sel
    }
    if b.kind == ast.EXPR_SELECTOR {
        b = b.selector.sel
    }
    if a.kind != b.kind {
        return false
    }
    switch a.kind {
    case ast.EXPR_IDENT: return b.kind == ast.EXPR_IDENT && a.ident.obj == a.ident.obj
    case ast.EXPR_STAR: return areIdentical(a.star.x, b.star.x)
    case ast.TYPE_ARRAY: return areIdentical(a.array.elt, b.array.elt)
    case ast.TYPE_FUNC:
        {
            if !areIdentical(a.func.result, b.func.result) {
                return false
            }
            var i int = 0
            if a.func.params {
                for ; a.func.params[i]; i++ {
                    var param1 *ast.Decl = a.func.params[i]
                    var param2 *ast.Decl = b.func.params[i]
                    if param2 == NULL {
                        return false
                    }
                    if !areIdentical(param1.field.type, param2.field.type) {
                        return false
                    }
                }
                if b.func.params[i] {
                    return false
                }
            }
        }
        return true
    default:
        panic("not implemented: %s == %s", typeString(a), typeString(b))
        return false
    }
}

fun isPointer(t *ast.Expr) bool {
    return t.kind == ast.EXPR_STAR || t.kind == ast.TYPE_ARRAY
}

fun pointerBase(t *ast.Expr) *ast.Expr {
    switch t.kind {
    case ast.EXPR_STAR: return t.star.x
    case ast.TYPE_ARRAY: return t.array.elt
    default:
        panic("not a pointer: %s", typeString(t))
        return NULL
    }
}

fun areAssignable(a *ast.Expr, b *ast.Expr) bool {
    if areIdentical(a, b) {
        return true
    }
    if ast.isVoidPtr(a) || ast.isVoidPtr(b) {
        return true
    }
    if isPointer(a) && isPointer(b) {
        return areAssignable(pointerBase(a), pointerBase(b))
    }
    while a.kind == ast.EXPR_IDENT {
        a = getUnderlyingType(a)
    }
    while b.kind == ast.EXPR_IDENT {
        b = getUnderlyingType(b)
    }
    if isNative(a, "bool") && isArithmetic(b) {
        return true
    }
    if b.kind == ast.TYPE_ENUM && isArithmetic(a) {
        return true
    }
    if a.kind == ast.TYPE_ENUM && isArithmetic(a) {
        return true
    }
    return areIdentical(a, b)
}

fun areComparable(a *ast.Expr, b *ast.Expr) bool {
    if areIdentical(a, b) {
        return true
    }
    if isArithmetic(a) && isArithmetic(b) {
        return true
    }
    if a.kind == ast.EXPR_STAR && isNative(b, "int") {
        return true
    }
    return areIdentical(a, b)
}

fun getDeclKind(decl *ast.Decl) ast.ObjKind {
    switch decl.kind {
    case ast.DECL_FIELD, ast.DECL_VALUE: return ast.ObjKind_VALUE
    case ast.DECL_FUNC: return ast.ObjKind_FUNC
    case ast.DECL_IMPORT: return ast.ObjKind_PKG
    case ast.DECL_TYPEDEF: return ast.ObjKind_TYPE
    default: return ast.ObjKind_BAD
    }
}

fun getDeclName(decl *ast.Decl) *ast.Expr {
    switch decl.kind {
    case ast.DECL_FIELD: return decl.field.name
    case ast.DECL_FUNC: return decl.func.name
    case ast.DECL_IMPORT: return decl.imp.name
    case ast.DECL_TYPEDEF: return decl.typedef_.name
    case ast.DECL_VALUE: return decl.value.name
    default:
        panic("bad decl: %s", declString(decl))
        return NULL
    }
}

fun declareBuiltins(s *ast.Scope) {
    for var i int = 0; natives[i].name != NULL; i++ {
        var _name ast.Expr = {
            kind: ast.EXPR_IDENT,
            ident: {
                name: strdup(natives[i].name),
            },
        }
        var name *ast.Expr = esc(_name)
        var type ast.Expr = {
            kind: ast.TYPE_NATIVE,
            native: {
                name: strdup(natives[i].name),
                size: natives[i].size,
            },
        }
        var decl ast.Decl = {
            kind: ast.DECL_TYPEDEF,
            typedef_: {
                name: name,
                type: esc(type),
            },
        }
        var obj *ast.Object = ast.newObject(ast.ObjKind_TYPE, name.ident.name)
        obj.decl = esc(decl)
        name.ident.obj = obj
        assert(ast.Scope_insert(s, obj) == NULL)
    }
}

var _universe *ast.Scope = NULL

fun universe() *ast.Scope {
    if _universe == NULL {
        _universe = ast.Scope_new(NULL)
        declareBuiltins(_universe)
        var fset *token.FileSet = token.newFileSet()
        var file *ast.File = parser.parseFile(fset, "builtin/builtin.bling", _universe)
        _universe = file.scope
        var conf Config = {
            strict: true,
        }
        checkFile(&conf, fset, file)
        free(file.decls)
        free(file)
    }
    return _universe
}

fun isLhs(expr *ast.Expr) bool {
    switch expr.kind {
    case ast.EXPR_IDENT, ast.EXPR_SELECTOR: return true
    case ast.EXPR_CAST: return isLhs(expr.cast.expr)
    case ast.EXPR_INDEX: return isLhs(expr.index.x)
    case ast.EXPR_PAREN: return isLhs(expr.paren.x)
    case ast.EXPR_STAR: return isLhs(expr.star.x)
    default: return false
    }
}

fun getDeclType(decl *ast.Decl) *ast.Expr {
    assert(decl)
    switch decl.kind {
    case ast.DECL_FIELD: return decl.field.type
    case ast.DECL_FUNC: return decl.func.type
    case ast.DECL_IMPORT: return NULL
    case ast.DECL_TYPEDEF: return decl.typedef_.type
    case ast.DECL_VALUE: return decl.value.type
    default:
        panic("unhandled decl: %s", declString(decl))
        return NULL
    }
}

fun getStructFieldByName(type *ast.Expr, name *ast.Expr) *ast.Decl {
    type = getBaseType(type)
    assert(type.kind == ast.TYPE_STRUCT)
    assert(name.kind == ast.EXPR_IDENT)
    for var i int = 0; type.struct_.fields && type.struct_.fields[i]; i++ {
        var field *ast.Decl = type.struct_.fields[i]
        var fieldName *ast.Expr = field.field.name
        if fieldName {
            if streq(name.ident.name, fieldName.ident.name) {
                type = field.field.type
                return field
            }
        } else {
            var subField *ast.Decl = getStructFieldByName(field.field.type, name)
            if subField {
                return subField
            }
        }
    }
    return NULL
}

fun getStructField(type *ast.Expr, index int) *ast.Decl {
    assert(type.kind == ast.TYPE_STRUCT)
    if type.struct_.fields == NULL {
        panic("incomplete field defn: %s", typeString(type))
    }
    for var i int = 0; type.struct_.fields[i]; i++ {
        if i == index {
            return type.struct_.fields[i]
        }
    }
    return NULL
}

typedef Checker struct {
    fset *token.FileSet
    conf *Config
    pkg ast.Package
    result *ast.Expr
    files utils.Slice
    typedefName *ast.Expr
    scopes utils.Map
}

fun Checker_error(c *Checker, pos token.Pos, msg *const char) {
    token.FileSet_print(c.fset)
    var position token.Position = {}
    var file *token.File = token.FileSet_file(c.fset, pos)
    if file {
        position = token.File_position(file, pos)
    }
    panic(sys.sprintf("%s: %s\n%s", token.Position_string(&position), msg, token.File_lineString(file, position.line)))
}

fun Checker_resolve(c *Checker, s *ast.Scope, x *ast.Expr) {
    assert(x.kind == ast.EXPR_IDENT)
    if x.ident.obj {
        Checker_error(c, ast.Expr_pos(x), "already resolved")
    }
    if ast.resolve(s, x) {
        return
    }
    Checker_error(c, ast.Expr_pos(x), sys.sprintf("unresolved: %s", x.ident.name))
}

fun Checker_declare(c *Checker, s *ast.Scope, decl *ast.Decl) {
    var ident *ast.Expr = getDeclName(decl)
    if ident.ident.obj != NULL {
        Checker_error(c, decl.pos, sys.sprintf("already declared: %s", ident.ident.name))
    }
    var kind ast.ObjKind = getDeclKind(decl)
    var obj *ast.Object = ast.newObject(kind, ident.ident.name)
    obj.decl = decl
    obj.scope = s
    obj.pkg = s.pkg
    ident.ident.obj = obj
    var alt *ast.Object = ast.Scope_insert(s, obj)
    if alt != NULL {
        var redecl bool = false
        if alt.kind == kind {
            switch kind {
            case ast.ObjKind_BAD:
                panic("unreachable")
                break
            case ast.ObjKind_FUNC:
                redecl = (alt.decl.func.body == NULL || decl.func.body == NULL) && areIdentical(alt.decl.func.type, decl.func.type)
                break
            case ast.ObjKind_PKG:
                redecl = true
                break
            case ast.ObjKind_TYPE:
                if alt.decl.typedef_.type.kind == ast.TYPE_STRUCT {
                    redecl = alt.decl.typedef_.type.struct_.fields == NULL
                }
                if c.conf.cMode {
                    redecl = true
                }
                break
            case ast.ObjKind_VALUE:
                redecl = alt.decl.value.value == NULL && !areIdentical(alt.decl.value.type, decl.value.value)
                break
            }
        }
        if !redecl {
            Checker_error(c, decl.pos, sys.sprintf("incompatible redefinition of `%s`: %s", declString(obj.decl), declString(decl)))
        }
        alt.decl = decl
    }
}

fun Checker_openScope(c *Checker) {
    c.pkg.scope = ast.Scope_new(c.pkg.scope)
}

fun Checker_closeScope(c *Checker) {
    c.pkg.scope = c.pkg.scope.outer
}

fun Checker_checkType(c *Checker, t *ast.Expr) {
    assert(t)
    switch t.kind {
    case ast.EXPR_IDENT:
        Checker_resolve(c, c.pkg.scope, t)
        break
    case ast.EXPR_SELECTOR:
        {
            var type *ast.Expr = Checker_checkExpr(c, t.selector.x)
            assert(type == NULL)
            assert(ast.isIdent(t.selector.x))
            assert(t.selector.x.ident.obj.kind == ast.ObjKind_PKG)
            var oldScope *ast.Scope = c.pkg.scope
            c.pkg.scope = t.selector.x.ident.obj.decl.imp.scope
            Checker_checkType(c, t.selector.sel)
            c.pkg.scope = oldScope
        }
        break
    case ast.TYPE_ARRAY:
        Checker_checkType(c, t.array.elt)
        if t.array.len {
            var len *ast.Expr = Checker_checkExpr(c, t.array.len)
            <void> len
        }
        break
    case ast.TYPE_ENUM:
        if t.enum_.name == NULL {
            t.enum_.name = c.typedefName
        }
        for var i int = 0; t.enum_.enums[i]; i++ {
            var decl *ast.Decl = t.enum_.enums[i]
            if c.typedefName {
                decl.value.type = c.typedefName
            }
            Checker_declare(c, c.pkg.scope, decl)
        }
        break
    case ast.TYPE_FUNC:
        for var i int = 0; t.func.params && t.func.params[i]; i++ {
            var param *ast.Decl = t.func.params[i]
            if param.kind == ast.DECL_ELLIPSIS {
                continue
            }
            assert(param.kind == ast.DECL_FIELD)
            Checker_checkType(c, param.field.type)
        }
        if t.func.result {
            Checker_checkType(c, t.func.result)
        }
        break
    case ast.EXPR_STAR:
        Checker_checkType(c, t.star.x)
        break
    case ast.TYPE_STRUCT:
        if t.enum_.name == NULL {
            t.enum_.name = c.typedefName
        }
        if t.struct_.fields {
            Checker_openScope(c)
            for var i int = 0; t.struct_.fields[i]; i++ {
                var field *ast.Decl = t.struct_.fields[i]
                Checker_checkType(c, field.field.type)
                if field.field.name {
                    Checker_declare(c, c.pkg.scope, field)
                }
            }
            Checker_closeScope(c)
        }
        break
    default:
        Checker_error(c, ast.Expr_pos(t), "unknown type")
        break
    }
}

fun Checker_checkIdent(c *Checker, expr *ast.Expr) *ast.Expr {
    assert(expr.kind == ast.EXPR_IDENT)
    if expr.ident.obj == NULL {
        Checker_error(c, ast.Expr_pos(expr), "unresolved identifier")
    }
    return getDeclType(expr.ident.obj.decl)
}

fun isInteger(x *ast.Expr) bool {
    switch x.kind {
    case ast.EXPR_IDENT: return isInteger(x.ident.obj.decl.typedef_.type)
    case ast.TYPE_ENUM, ast.TYPE_NATIVE: return true
    default: return false
    }
}

fun Checker_checkArrayLit(c *Checker, x *ast.Expr) {
    var baseT *ast.Expr = getBaseType(x.composite.type)
    for var i int = 0; x.composite.list[i]; i++ {
        var elt *ast.Expr = x.composite.list[i]
        if elt.kind == ast.EXPR_KEY_VALUE {
            elt.key_value.isArray = true
            var indexT *ast.Expr = Checker_checkExpr(c, elt.key_value.key)
            if !isInteger(indexT) {
                Checker_error(c, ast.Expr_pos(elt), sys.sprintf("not a valid index: %s", exprString(elt.key_value.key)))
            }
            elt = elt.key_value.value
        }
        if elt.kind == ast.EXPR_COMPOSITE_LIT {
            if elt.composite.type == NULL {
                elt.composite.type = baseT.array.elt
            } else {
                Checker_checkType(c, elt.composite.type)
            }
            Checker_checkCompositeLit(c, elt)
        } else {
            Checker_checkExpr(c, elt)
        }
    }
}

fun Checker_checkStructLit(c *Checker, x *ast.Expr) {
    assert(x.composite.type)
    var expectKV bool = false
    for var i int = 0; x.composite.list[i]; i++ {
        var elt *ast.Expr = x.composite.list[i]
        var fieldT *ast.Expr = NULL
        if elt.kind == ast.EXPR_KEY_VALUE {
            elt.key_value.isArray = false
            expectKV = true
            var key *ast.Expr = elt.key_value.key
            if !ast.isIdent(key) {
                Checker_error(c, ast.Expr_pos(x), "key must be an identifier")
            }
            var field *ast.Decl = getStructFieldByName(x.composite.type, key)
            if field == NULL {
                Checker_error(c, ast.Expr_pos(key), sys.sprintf("no member named '%s' in '%s'", exprString(key), typeString(x.composite.type)))
            }
            key.ident.obj = field.field.name.ident.obj
            fieldT = field.field.type
            elt = elt.key_value.value
        } else {
            if expectKV {
                Checker_error(c, ast.Expr_pos(x), "expected a key/value expr")
            }
            var field *ast.Decl = getStructField(x.composite.type, i)
            fieldT = field.field.type
        }
        var eltT *ast.Expr = NULL
        if elt.kind == ast.EXPR_COMPOSITE_LIT {
            if elt.composite.type == NULL {
                elt.composite.type = fieldT
            } else {
                Checker_checkType(c, elt.composite.type)
            }
            eltT = Checker_checkCompositeLit(c, elt)
        } else {
            eltT = Checker_checkExpr(c, elt)
        }
        if !areAssignable(fieldT, eltT) {
            Checker_error(c, ast.Expr_pos(elt), sys.sprintf("cannot init field of type `%s` with value of type `%s`", typeString(fieldT), typeString(eltT)))
        }
    }
}

fun Checker_checkCompositeLit(c *Checker, x *ast.Expr) *ast.Expr {
    var t *ast.Expr = x.composite.type
    assert(t)
    var baseT *ast.Expr = getBaseType(t)
    switch baseT.kind {
    case ast.TYPE_ARRAY:
        Checker_checkArrayLit(c, x)
        break
    case ast.TYPE_STRUCT:
        Checker_checkStructLit(c, x)
        break
    default:
        Checker_error(c, ast.Expr_pos(x), "composite type must be an array or a struct")
        break
    }
    return t
}

fun Checker_checkExpr(c *Checker, expr *ast.Expr) *ast.Expr {
    assert(expr)
    switch expr.kind {
    case ast.EXPR_BINARY: {
        var typ1 *ast.Expr = Checker_checkExpr(c, expr.binary.x)
        var typ2 *ast.Expr = Checker_checkExpr(c, expr.binary.y)
        if !areComparable(typ1, typ2) {
            Checker_error(c, ast.Expr_pos(expr), sys.sprintf("not compariable: %s and %s", typeString(typ1), typeString(typ2)))
        }
        switch expr.binary.op {
        case token.EQUAL, token.GT, token.GT_EQUAL, token.LAND, token.LOR, token.LT, token.LT_EQUAL, token.NOT_EQUAL:
            typ1 = makeIdent("bool")
            Checker_checkType(c, typ1)
        default: return typ1
        }
    }
    case ast.EXPR_BASIC_LIT: {
        var kind token.Token = expr.basic.kind
        var type *ast.Expr = NULL
        switch kind {
        case token.CHAR:
            type = makeIdent("char")
            break
        case token.FLOAT:
            type = makeIdent("float")
            break
        case token.INT:
            type = makeIdent("int")
            break
        case token.STRING:
            type = makePtr(makeIdent("char"))
            break
        default:
            Checker_error(c, ast.Expr_pos(expr), "unreachable")
            break
        }
        Checker_checkType(c, type)
        return type
    }
    case ast.EXPR_CALL: {
        var func *ast.Expr = expr.call.func
        var type *ast.Expr = Checker_checkExpr(c, func)
        if func.kind == ast.EXPR_IDENT {
            if streq(func.ident.name, "esc") {
                assert(expr.call.args[0] && !expr.call.args[1])
                var type *ast.Expr = Checker_checkExpr(c, expr.call.args[0])
                return makePtr(type)
            }
        }
        if type.kind == ast.EXPR_STAR {
            type = type.star.x
        }
        if type.kind != ast.TYPE_FUNC {
            Checker_error(c, ast.Expr_pos(expr), sys.sprintf("`%s` is not a func", exprString(expr.call.func)))
        }
        var j int = 0
        for var i int = 0; expr.call.args[i]; i++ {
            var param *ast.Decl = type.func.params[j]
            var type *ast.Expr = Checker_checkExpr(c, expr.call.args[i])
            if param.kind == ast.DECL_FIELD {
                if !areAssignable(param.field.type, type) {
                    Checker_error(c, ast.Expr_pos(expr), sys.sprintf("not assignable: %s and %s", typeString(param.field.type), typeString(type)))
                }
                j++
            } else {
                assert(param.kind == ast.DECL_ELLIPSIS)
            }
        }
        return type.func.result
    }
    case ast.EXPR_COMPOSITE_LIT:
        Checker_checkType(c, expr.composite.type)
        Checker_checkCompositeLit(c, expr)
        return expr.composite.type
    case ast.EXPR_CAST:
        Checker_checkType(c, expr.cast.type)
        Checker_checkExpr(c, expr.cast.expr)
        return expr.cast.type
    case ast.EXPR_IDENT:
        Checker_resolve(c, c.pkg.scope, expr)
        return Checker_checkIdent(c, expr)
    case ast.EXPR_INDEX: {
        var type *ast.Expr = Checker_checkExpr(c, expr.index.x)
        switch type.kind {
        case ast.TYPE_ARRAY:
            type = type.array.elt
            break
        case ast.EXPR_STAR:
            type = type.star.x
            break
        default:
            Checker_error(c, ast.Expr_pos(expr), sys.sprintf("indexing a non-array or pointer `%s`", typeString(type)))
            break
        }
        var typ2 *ast.Expr = Checker_checkExpr(c, expr.index.index)
        <void> typ2
        return type
    }
    case ast.EXPR_PAREN: return Checker_checkExpr(c, expr.paren.x)
    case ast.EXPR_SELECTOR: {
        var type *ast.Expr = Checker_checkExpr(c, expr.selector.x)
        if type == NULL {
            var x *ast.Expr = expr.selector.x
            assert(x.kind == ast.EXPR_IDENT)
            var decl *ast.Decl = x.ident.obj.decl
            assert(decl.kind == ast.DECL_IMPORT)
            var oldScope *ast.Scope = c.pkg.scope
            c.pkg.scope = decl.imp.scope
            type = Checker_checkExpr(c, expr.selector.sel)
            c.pkg.scope = oldScope
            expr.selector.tok = token.DOLLAR
            return type
        }
        if type.kind == ast.EXPR_STAR {
            expr.selector.tok = token.ARROW
            type = type.star.x
        } else {
            assert(expr.selector.tok != token.ARROW)
        }
        var field *ast.Decl = getStructFieldByName(type, expr.selector.sel)
        if field == NULL {
            Checker_error(c, ast.Expr_pos(expr), sys.sprintf("no member named '%s' in '%s'", exprString(expr.selector.sel), typeString(type)))
        }
        expr.selector.sel.ident.obj = field.field.name.ident.obj
        return field.field.type
    }
    case ast.EXPR_SIZEOF: {
        Checker_checkType(c, expr.sizeof_.x)
        var ident *ast.Expr = makeIdent("size_t")
        Checker_resolve(c, c.pkg.scope, ident)
        return ident
    }
    case ast.EXPR_STAR: {
        var type *ast.Expr = Checker_checkExpr(c, expr.star.x)
        switch type.kind {
        case ast.EXPR_STAR: return type.star.x
        case ast.TYPE_ARRAY: return type.array.elt
        default:
            Checker_error(c, ast.Expr_pos(expr), sys.sprintf("derefencing a non-pointer `%s`", typeString(type)))
            return NULL
        }
    }
    case ast.EXPR_TERNARY: {
        var t1 *ast.Expr = Checker_checkExpr(c, expr.ternary.cond)
        assert(isArithmetic(t1))
        var t2 *ast.Expr = Checker_checkExpr(c, expr.ternary.x)
        var t3 *ast.Expr = Checker_checkExpr(c, expr.ternary.y)
        assert(areIdentical(t2, t3))
        return t2
    }
    case ast.EXPR_UNARY: {
        var type *ast.Expr = Checker_checkExpr(c, expr.unary.x)
        if expr.unary.op == token.AND {
            if !isLhs(expr.unary.x) {
                Checker_error(c, ast.Expr_pos(expr), sys.sprintf("invalid lvalue `%s`", exprString(expr.unary.x)))
            }
            return makePtr(type)
        }
        return type
    }
    default:
        Checker_error(c, ast.Expr_pos(expr), "unknown expr")
        return NULL
    }
}

fun Checker_checkStmt(c *Checker, stmt *ast.Stmt) {
    switch stmt.kind {
    case ast.STMT_ASSIGN:
        {
            if !isLhs(stmt.assign.x) {
                Checker_error(c, ast.Stmt_pos(stmt), sys.sprintf("invalid lvalue `%s`", exprString(stmt.assign.x)))
            }
            var a *ast.Expr = Checker_checkExpr(c, stmt.assign.x)
            if a.is_const {
                Checker_error(c, ast.Stmt_pos(stmt), "cannot assign to const var")
            }
            var b *ast.Expr = Checker_checkExpr(c, stmt.assign.y)
            if !areAssignable(a, b) {
                Checker_error(c, ast.Stmt_pos(stmt), sys.sprintf("not assignable: `%s` and `%s`", typeString(a), typeString(b)))
            }
        }
        break
    case ast.STMT_BLOCK:
        Checker_openScope(c)
        for var i int = 0; stmt.block.stmts[i]; i++ {
            Checker_checkStmt(c, stmt.block.stmts[i])
        }
        Checker_closeScope(c)
        break
    case ast.STMT_DECL:
        Checker_checkDecl(c, stmt.decl.decl)
        break
    case ast.STMT_EXPR:
        Checker_checkExpr(c, stmt.expr.x)
        break
    case ast.STMT_EMPTY: break
    case ast.STMT_IF:
        Checker_checkExpr(c, stmt.if_.cond)
        Checker_checkStmt(c, stmt.if_.body)
        if stmt.if_.else_ {
            Checker_checkStmt(c, stmt.if_.else_)
        }
        break
    case ast.STMT_ITER:
        if stmt.iter.init || stmt.iter.post {
            Checker_openScope(c)
        }
        if stmt.iter.init {
            Checker_checkStmt(c, stmt.iter.init)
        }
        if stmt.iter.cond {
            Checker_checkExpr(c, stmt.iter.cond)
        }
        if stmt.iter.post {
            Checker_checkStmt(c, stmt.iter.post)
        }
        Checker_checkStmt(c, stmt.iter.body)
        if stmt.iter.init || stmt.iter.post {
            Checker_closeScope(c)
        }
        break
    case ast.STMT_JUMP: break
    case ast.STMT_LABEL:
        Checker_checkStmt(c, stmt.label.stmt)
        break
    case ast.STMT_POSTFIX:
        Checker_checkExpr(c, stmt.postfix.x)
        break
    case ast.STMT_RETURN:
        if stmt.return_.x {
            var a *ast.Expr = c.result
            var b *ast.Expr = Checker_checkExpr(c, stmt.return_.x)
            if a == NULL {
                Checker_error(c, ast.Stmt_pos(stmt), "returning value in void function")
            }
            if !areAssignable(a, b) {
                Checker_error(c, ast.Stmt_pos(stmt), sys.sprintf("not returnable: %s and %s", typeString(a), typeString(b)))
            }
        }
        break
    case ast.STMT_SWITCH:
        {
            var type1 *ast.Expr = Checker_checkExpr(c, stmt.switch_.tag)
            for var i int = 0; stmt.switch_.stmts[i]; i++ {
                var clause *ast.Stmt = stmt.switch_.stmts[i]
                assert(clause.kind == ast.STMT_CASE)
                for var j int = 0; clause.case_.exprs && clause.case_.exprs[j]; j++ {
                    var type2 *ast.Expr = Checker_checkExpr(c, clause.case_.exprs[j])
                    if !areComparable(type1, type2) {
                        Checker_error(c, ast.Stmt_pos(stmt), sys.sprintf("not comparable: %s and %s", typeString(type1), typeString(type2)))
                    }
                }
                for var j int = 0; clause.case_.stmts[j]; j++ {
                    Checker_checkStmt(c, clause.case_.stmts[j])
                }
            }
        }
        break
    default:
        Checker_error(c, ast.Stmt_pos(stmt), "unknown stmt")
    }
}

fun Checker_checkImport(c *Checker, imp *ast.Decl) {
    if c.conf.cMode {
        return
    }
    var path *char = constant_stringVal(imp.imp.path)
    var oldScope *ast.Scope = NULL
    utils.Map_get(&c.scopes, path, &oldScope)
    if oldScope {
        imp.imp.scope = oldScope
        imp.imp.name = makeIdent(imp.imp.scope.pkg)
        Checker_declare(c, c.pkg.scope, imp)
        free(path)
        return
    }
    imp.imp.scope = ast.Scope_new(universe())
    utils.Map_set(&c.scopes, path, &imp.imp.scope)
    oldScope = c.pkg.scope
    c.pkg.scope = imp.imp.scope
    var err *utils.Error = NULL
    var files **ast.File = parser.parseDir(c.fset, path, c.pkg.scope, &err)
    if err {
        Checker_error(c, imp.pos, sys.sprintf("%s: %s", path, err.error))
    }
    assert(files[0] && !files[1])
    Checker_checkFile(c, files[0])
    c.pkg.scope = oldScope
    imp.imp.name = makeIdent(imp.imp.scope.pkg)
    Checker_declare(c, c.pkg.scope, imp)
}

fun Checker_checkDecl(c *Checker, decl *ast.Decl) {
    switch decl.kind {
    case ast.DECL_FUNC:
        Checker_checkType(c, decl.func.type)
        break
    case ast.DECL_PRAGMA: break
    case ast.DECL_TYPEDEF:
        c.typedefName = decl.typedef_.name
        Checker_checkType(c, decl.typedef_.type)
        c.typedefName = NULL
        break
    case ast.DECL_VALUE: {
        var valType *ast.Expr = NULL
        if decl.value.type != NULL {
            Checker_checkType(c, decl.value.type)
        }
        if decl.value.value != NULL {
            if decl.value.value.kind == ast.EXPR_COMPOSITE_LIT {
                if decl.value.value.composite.type == NULL {
                    decl.value.value.composite.type = decl.value.type
                } else {
                    Checker_checkType(c, decl.value.value.composite.type)
                }
                valType = Checker_checkCompositeLit(c, decl.value.value)
            } else {
                valType = Checker_checkExpr(c, decl.value.value)
            }
        }
        if decl.value.type == NULL {
            decl.value.type = valType
        }
        if valType != NULL {
            var varType *ast.Expr = decl.value.type
            if !areAssignable(varType, valType) {
                Checker_error(c, decl.pos, sys.sprintf("not assignable %s and %s", typeString(varType), typeString(valType)))
            }
        }
        Checker_declare(c, c.pkg.scope, decl)
        break
    }
    default:
        Checker_error(c, decl.pos, "unreachable")
    }
}

fun Checker_checkFunc(c *Checker, decl *ast.Decl) {
    if decl.kind == ast.DECL_FUNC && decl.func.body {
        Checker_openScope(c)
        var type *ast.Expr = decl.func.type
        for var i int = 0; type.func.params && type.func.params[i]; i++ {
            var param *ast.Decl = type.func.params[i]
            assert(param.kind == ast.DECL_FIELD)
            if param.field.name {
                Checker_declare(c, c.pkg.scope, param)
            }
        }
        c.result = decl.func.type.func.result
        for var i int = 0; decl.func.body.block.stmts[i]; i++ {
            Checker_checkStmt(c, decl.func.body.block.stmts[i])
        }
        c.result = NULL
        Checker_closeScope(c)
    }
}

fun Checker_checkFile(c *Checker, file *ast.File) {
    if file.name {
        c.pkg.scope.pkg = file.name.ident.name
    }
    for var i int = 0; file.imports[i] != NULL; i++ {
        Checker_checkImport(c, file.imports[i])
    }
    utils.Slice_append(&c.files, &file)
    if c.conf.strict {
        for var i int = 0; file.decls[i] != NULL; i++ {
            if file.decls[i].kind == ast.DECL_TYPEDEF {
                Checker_declare(c, c.pkg.scope, file.decls[i])
            }
        }
        for var i int = 0; file.decls[i] != NULL; i++ {
            if file.decls[i].kind == ast.DECL_FUNC {
                Checker_declare(c, c.pkg.scope, file.decls[i])
            }
        }
        for var i int = 0; file.decls[i] != NULL; i++ {
            Checker_checkDecl(c, file.decls[i])
        }
        for var i int = 0; file.decls[i] != NULL; i++ {
            Checker_checkFunc(c, file.decls[i])
        }
    }
}

fun checkFile(conf *Config, fset *token.FileSet, file *ast.File) ast.Package {
    if file.scope == NULL {
        file.scope = ast.Scope_new(universe())
    }
    var c Checker = {
        fset: fset,
        conf: conf,
        pkg: {
            scope: file.scope,
        },
        files: utils.Slice_init(sizeof(*ast.File)),
        scopes: utils.Map_init(sizeof(*ast.Scope)),
    }
    Checker_checkFile(&c, file)
    c.pkg.files = utils.Slice_to_nil_array(c.files)
    return c.pkg
}
