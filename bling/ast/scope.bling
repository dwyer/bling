package ast

import "C"
import "bytes"
import "runtime"

typ ObjKind enum {
    ObjKind_BAD
    ObjKind_CON
    ObjKind_FUN
    ObjKind_PKG
    ObjKind_TYP
    ObjKind_VAL
}

typ Object struct {
    kind ObjKind
    name string
    decl *Decl
    data voidptr
    scope *Scope
}

fun newObject(kind ObjKind, name string) *Object {
    let obj = Object{
        kind: kind,
        name: name,
    }
    return &&obj
}

typ Scope struct {
    outer *Scope
    objects map *Object
    keys []string
    pkgName *Expr
}

fun newScope(outer *Scope) *Scope {
    let s = Scope{
        outer: outer,
        objects: makemap(*Object),
        keys: []string{},
    }
    return &&s
}

fun (s *Scope) delete() {
    delete(s.objects)
    delete(s.keys)
    delete(s)
}

fun (s *Scope) insert(obj *Object) *Object {
    let alt = s.objects[obj.name]
    if alt == nil {
        s.objects[obj.name] = obj
        append(s.keys, obj.name)
    }
    return alt
}

fun (s *Scope) lookup(name string) *Object {
    return s.objects[name]
}

fun (s *Scope) print() {
    let buf = bytes.Buffer{}
    while s {
        let key string = nil
        for let iter = runtime.newMapIter(&s.objects); runtime.MapIter_next(&iter, &key); {
            let s = C.sprintf("%s- %s", buf.string(), key)
            print(s)
            delete(s)
        }
        s = s.outer
        buf.writeByte('\t', nil)
    }
}

fun (s *Scope) deepLookup(name string) *Object {
    for ; s != nil; s = s.outer {
        let obj = s.lookup(name)
        if obj != nil {
            return obj
        }
    }
    return nil
}
