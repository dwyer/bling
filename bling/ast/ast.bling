package ast

import "bling/token"
import "bytes"
import "sys"
import "utils"

#pragma once

#include "bling/token/token.h"

#include "utils/utils.h"

typedef NodeKind enum {
    NODE_ILLEGAL = 0,
    _DECL_START,
    DECL_ELLIPSIS,
    DECL_FIELD,
    DECL_FUNC,
    DECL_IMPORT,
    DECL_PRAGMA,
    DECL_TYPEDEF,
    DECL_VALUE,
    _DECL_END,
    _EXPR_START,
    EXPR_BASIC_LIT,
    EXPR_BINARY,
    EXPR_CALL,
    EXPR_CAST,
    EXPR_COMPOSITE_LIT,
    EXPR_IDENT,
    EXPR_INDEX,
    EXPR_KEY_VALUE,
    EXPR_PAREN,
    EXPR_SELECTOR,
    EXPR_SIZEOF,
    EXPR_STAR,
    EXPR_TERNARY,
    EXPR_UNARY,
    _EXPR_END,
    _STMT_START,
    STMT_ASSIGN,
    STMT_BLOCK,
    STMT_CASE,
    STMT_DECL,
    STMT_EMPTY,
    STMT_EXPR,
    STMT_IF,
    STMT_ITER,
    STMT_JUMP,
    STMT_LABEL,
    STMT_POSTFIX,
    STMT_RETURN,
    STMT_SWITCH,
    _STMT_END,
    _TYPE_START,
    TYPE_ARRAY,
    TYPE_ENUM,
    TYPE_NATIVE,
    TYPE_FUNC,
    TYPE_STRUCT,
    _TYPE_END,
}

typedef Node struct {
    kind NodeKind
}

typedef Decl struct Decl

typedef Expr struct Expr

typedef Stmt struct Stmt

typedef Scope struct Scope

typedef ObjKind enum {
    ObjKind_BAD,
    ObjKind_FUNC,
    ObjKind_PKG,
    ObjKind_TYPE,
    ObjKind_VALUE,
}

typedef Object struct {
    kind ObjKind
    name *char
    decl *Decl
    pkg *char
    scope *Scope
}

typedef Array struct {
    pos token.Pos
    len *Expr
    elt *Expr
}

typedef BasicLit struct {
    pos token.Pos
    kind token.Token
    value *char
}

typedef BinaryExpr struct {
    op token.Token
    x *Expr
    y *Expr
}

typedef CallExpr struct {
    func *Expr
    args **Expr
}

typedef CastExpr struct {
    pos token.Pos
    type *Expr
    expr *Expr
}

typedef CompositeLit struct {
    pos token.Pos
    type *Expr
    list **Expr
}

typedef Enum struct {
    pos token.Pos
    name *Expr
    enums **Decl
}

typedef FuncExpr struct {
    pos token.Pos
    result *Expr
    params **Decl
}

typedef Ident struct {
    pos token.Pos
    name *char
    obj *Object
}

typedef IndexExpr struct {
    x *Expr
    index *Expr
}

typedef KeyValue struct {
    key *Expr
    value *Expr
    isArray bool
}

typedef NativeType struct {
    name *char
    size int
}

typedef ParenExpr struct {
    pos token.Pos
    x *Expr
}

typedef SelectorExpr struct {
    x *Expr
    tok token.Token
    sel *Expr
}

typedef SizeofExpr struct {
    pos token.Pos
    x *Expr
}

typedef StarExpr struct {
    pos token.Pos
    x *Expr
}

typedef Struct struct {
    pos token.Pos
    tok token.Token
    name *Expr
    fields **Decl
    scope *Scope
}

typedef TernaryExpr struct {
    cond *Expr
    x *Expr
    y *Expr
}

typedef UnaryExpr struct {
    pos token.Pos
    op token.Token
    x *Expr
}

typedef Expr struct Expr {
    Node
    is_const bool
    union {
        array Array
        basic BasicLit
        binary BinaryExpr
        call CallExpr
        cast CastExpr
        composite CompositeLit
        enum_ Enum
        func FuncExpr
        ident Ident
        index IndexExpr
        key_value KeyValue
        native NativeType
        paren ParenExpr
        selector SelectorExpr
        sizeof_ SizeofExpr
        star StarExpr
        struct_ Struct
        ternary TernaryExpr
        unary UnaryExpr
    }
}

typedef ImportDecl struct {
    name *Expr
    path *Expr
    scope *Scope
}

typedef PragmaDecl struct {
    lit *char
}

typedef TypeDecl struct {
    name *Expr
    type *Expr
}

typedef ValueDecl struct {
    name *Expr
    type *Expr
    value *Expr
    kind token.Token
}

typedef FuncDecl struct {
    name *Expr
    type *Expr
    body *Stmt
}

typedef Field struct {
    name *Expr
    type *Expr
}

typedef Decl struct Decl {
    Node
    pos token.Pos
    union {
        imp ImportDecl
        pragma PragmaDecl
        typedef_ TypeDecl
        value ValueDecl
        func FuncDecl
        field Field
    }
}

typedef AssignStmt struct {
    x *Expr
    op token.Token
    y *Expr
}

typedef BlockStmt struct {
    pos token.Pos
    stmts **Stmt
}

typedef CaseStmt struct {
    pos token.Pos
    exprs **Expr
    stmts **Stmt
}

typedef EmptyStmt struct {
    pos token.Pos
}

typedef ExprStmt struct {
    x *Expr
}

typedef DeclStmt struct {
    decl *Decl
}

typedef IfStmt struct {
    pos token.Pos
    cond *Expr
    body *Stmt
    else_ *Stmt
}

typedef IterStmt struct {
    pos token.Pos
    kind token.Token
    init *Stmt
    cond *Expr
    post *Stmt
    body *Stmt
}

typedef JumpStmt struct {
    pos token.Pos
    keyword token.Token
    label *Expr
}

typedef LabelStmt struct {
    label *Expr
    stmt *Stmt
}

typedef PostfixStmt struct {
    x *Expr
    op token.Token
}

typedef ReturnStmt struct {
    pos token.Pos
    x *Expr
}

typedef SwitchStmt struct {
    pos token.Pos
    tag *Expr
    stmts **Stmt
}

typedef Stmt struct Stmt {
    Node
    union {
        assign AssignStmt
        block BlockStmt
        case_ CaseStmt
        decl DeclStmt
        empty EmptyStmt
        expr ExprStmt
        iter IterStmt
        if_ IfStmt
        jump JumpStmt
        label LabelStmt
        postfix PostfixStmt
        return_ ReturnStmt
        switch_ SwitchStmt
    }
}

fun newObject(kind ObjKind, name *char) *Object

typedef Scope struct Scope {
    outer *Scope
    objects utils.Map
    pkg *char
}

fun isExprType(x *Expr) bool

fun Scope_new(outer *Scope) *Scope

fun Scope_deinit(s *Scope)

fun Scope_insert(s *Scope, obj *Object) *Object

fun Scope_lookup(s *Scope, name *char) *Object

typedef File struct {
    filename *const char
    name *Expr
    imports **Decl
    decls **Decl
    scope *Scope
}

typedef Package struct {
    name *char
    scope *Scope
    files **File
}

fun Scope_free(s *Scope)

fun Scope_print(s *Scope)

fun resolve(scope *Scope, ident *Expr) bool

fun isIdent(x *Expr) bool

fun isIdentNamed(x *Expr, name *const char) bool

fun isNil(x *Expr) bool

fun isVoid(x *Expr) bool

fun isVoidPtr(x *Expr) bool

fun Decl_pos(x *Decl) token.Pos

fun Expr_pos(x *Expr) token.Pos

fun Stmt_pos(x *Stmt) token.Pos

#include "bling/ast/ast.h"

#include "bytes/bytes.h"

#include "sys/sys.h"

fun isExprType(x *Expr) bool {
    return _TYPE_START < x.kind && x.kind < _DECL_END
}

fun newObject(kind ObjKind, name *char) *Object {
    var obj Object = {
        kind: kind,
        name: name,
    }
    return esc(obj)
}

fun Scope_new(outer *Scope) *Scope {
    var s Scope = {
        outer: outer,
        objects: utils.Map_init(sizeof(*Object)),
    }
    return esc(s)
}

fun Scope_deinit(s *Scope) {
    utils.Map_deinit(&s.objects)
}

fun Scope_insert(s *Scope, obj *Object) *Object {
    var alt *Object = NULL
    utils.Map_get(&s.objects, obj.name, &alt)
    if alt == NULL {
        utils.Map_set(&s.objects, obj.name, &obj)
    }
    return alt
}

fun Scope_lookup(s *Scope, name *char) *Object {
    var obj *Object = NULL
    utils.Map_get(&s.objects, name, &obj)
    return obj
}

fun Scope_print(s *Scope) {
    var buf bytes.Buffer = {}
    while s {
        var iter utils.MapIter = utils.NewMapIter(&s.objects)
        var key *char = NULL
        while utils.MapIter_next(&iter, &key, NULL) {
            var s *char = sys.sprintf("%s- %s", bytes.Buffer_string(&buf), key)
            print(s)
            free(s)
        }
        s = s.outer
        bytes.Buffer_writeByte(&buf, '\t', NULL)
    }
}

fun resolve(scope *Scope, ident *Expr) bool {
    for ; scope != NULL; scope = scope.outer {
        var obj *Object = Scope_lookup(scope, ident.ident.name)
        if obj != NULL {
            ident.ident.obj = obj
            return true
        }
    }
    return false
}

fun Scope_free(s *Scope) {
    utils.Map_deinit(&s.objects)
    free(s)
}

fun isIdent(x *Expr) bool {
    return x.kind == EXPR_IDENT
}

fun isIdentNamed(x *Expr, name *const char) bool {
    return isIdent(x) && streq(x.ident.name, name)
}

fun isNil(x *Expr) bool {
    return isIdentNamed(x, "NULL")
}

fun isVoid(x *Expr) bool {
    return isIdent(x) && streq(x.ident.name, "void")
}

fun isVoidPtr(x *Expr) bool {
    if x.kind == EXPR_STAR {
        return isVoid(x.star.x)
    }
    return false
}

fun Decl_pos(d *Decl) token.Pos {
    return d.pos
}

fun Expr_pos(x *Expr) token.Pos {
    switch x.kind {
    case EXPR_BASIC_LIT: return x.basic.pos
    case EXPR_BINARY: return Expr_pos(x.binary.x)
    case EXPR_CALL: return Expr_pos(x.call.func)
    case EXPR_CAST: return x.cast.pos
    case EXPR_COMPOSITE_LIT: return x.composite.pos
    case EXPR_IDENT: return x.ident.pos
    case EXPR_INDEX: return Expr_pos(x.index.x)
    case EXPR_KEY_VALUE: return Expr_pos(x.key_value.key)
    case EXPR_PAREN: return x.paren.pos
    case EXPR_SELECTOR: return Expr_pos(x.selector.x)
    case EXPR_SIZEOF: return x.sizeof_.pos
    case EXPR_STAR: return x.star.pos
    case EXPR_TERNARY: return Expr_pos(x.ternary.cond)
    case EXPR_UNARY: return x.unary.pos
    case TYPE_ARRAY: return x.array.pos
    case TYPE_ENUM: return x.enum_.pos
    case TYPE_NATIVE: return 0
    case TYPE_FUNC: return x.func.pos
    case TYPE_STRUCT: return x.struct_.pos
    default: return 0
    }
}

fun Stmt_pos(s *Stmt) token.Pos {
    switch s.kind {
    case STMT_ASSIGN: return Expr_pos(s.assign.x)
    case STMT_BLOCK: return s.block.pos
    case STMT_CASE: return s.case_.pos
    case STMT_DECL: return Decl_pos(s.decl.decl)
    case STMT_EMPTY: return s.empty.pos
    case STMT_EXPR: return Expr_pos(s.expr.x)
    case STMT_IF: return s.if_.pos
    case STMT_ITER: return s.iter.pos
    case STMT_JUMP: return s.jump.pos
    case STMT_LABEL: return Expr_pos(s.label.label)
    case STMT_POSTFIX: return Expr_pos(s.postfix.x)
    case STMT_RETURN: return s.return_.pos
    case STMT_SWITCH: return s.switch_.pos
    default: return 0
    }
}
