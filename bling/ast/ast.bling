package ast

import "C"
import "bling/token"
import "bytes"
import "runtime"

typ NodeKind enum {
    NODE_ILLEGAL = 0

    _DECL_START
    DECL_BUILTIN
    DECL_FIELD
    DECL_FUNC
    DECL_IMPORT
    DECL_PRAGMA
    DECL_TYPE
    DECL_VALUE
    _DECL_END

    _EXPR_START
    EXPR_BASIC_LIT
    EXPR_BINARY
    EXPR_CALL
    EXPR_CAST
    EXPR_COMPOSITE_LIT
    EXPR_CONST
    EXPR_IDENT
    EXPR_INDEX
    EXPR_KEY_VALUE
    EXPR_PAREN
    EXPR_SELECTOR
    EXPR_SIZEOF
    EXPR_STAR
    EXPR_TERNARY
    EXPR_UNARY
    _EXPR_END

    _STMT_START
    STMT_ASSIGN
    STMT_BLOCK
    STMT_CASE
    STMT_DECL
    STMT_EMPTY
    STMT_EXPR
    STMT_IF
    STMT_ITER
    STMT_JUMP
    STMT_LABEL
    STMT_POSTFIX
    STMT_RETURN
    STMT_SWITCH
    _STMT_END

    _TYPE_START
    TYPE_ARRAY
    TYPE_BUILTIN
    TYPE_ELLIPSIS
    TYPE_ENUM
    TYPE_MAP
    TYPE_NATIVE
    TYPE_FUNC
    TYPE_STRUCT
    _TYPE_END
}

typ Node struct {
    kind NodeKind
}

typ ObjKind enum {
    ObjKind_BAD
    ObjKind_CON
    ObjKind_FUN
    ObjKind_PKG
    ObjKind_TYP
    ObjKind_VAL
}

typ Object struct {
    kind ObjKind
    name runtime.charptr
    decl *Decl
    data *void
    scope *Scope
}

typ ArrayType struct {
    pos token.Pos
    len *Expr
    elt *Expr
    dynamic bool
}

typ BasicLit struct {
    pos token.Pos
    kind token.Token
    value runtime.charptr
}

typ BinaryExpr struct {
    op token.Token
    x *Expr
    y *Expr
}

typ BuiltinType struct {
    name runtime.charptr
    nargs int
    variadic bool
    isExpr bool
    id int
}

typ CallExpr struct {
    func *Expr
    args []*Expr
}

typ CastExpr struct {
    pos token.Pos
    type *Expr
    expr *Expr
}

typ CompositeLit struct {
    pos token.Pos
    type *Expr
    list []*Expr
}

typ ConstExpr struct {
    name runtime.charptr
    type *Expr
    value int
}

typ EllipsisType struct {
    pos token.Pos
}

typ EnumType struct {
    pos token.Pos
    name *Expr
    enums []*Decl
}

typ FuncExpr struct {
    pos token.Pos
    result *Expr
    params []*Decl
}

typ Ident struct {
    pos token.Pos
    name runtime.charptr
    obj *Object
}

typ IndexExpr struct {
    x *Expr
    index *Expr
}

typ KeyValueExpr struct {
    key *Expr
    value *Expr
    isArray bool
}

typ MapType struct {
    pos token.Pos
    val *Expr
}

typ NativeType struct {
    kind int
    info int
    name runtime.charptr
}

typ ParenExpr struct {
    pos token.Pos
    x *Expr
}

typ SelectorExpr struct {
    x *Expr
    tok token.Token
    sel *Expr
}

typ SizeofExpr struct {
    pos token.Pos
    x *Expr
}

typ StarExpr struct {
    pos token.Pos
    x *Expr
}

typ StructType struct {
    pos token.Pos
    tok token.Token
    name *Expr
    fields []*Decl
    scope *Scope
}

typ TernaryExpr struct {
    cond *Expr
    x *Expr
    y *Expr
}

typ UnaryExpr struct {
    pos token.Pos
    op token.Token
    x *Expr
}

typ Expr struct {
    Node
    is_const bool
    union {
        array_ ArrayType
        basic BasicLit
        binary BinaryExpr
        builtin BuiltinType
        call CallExpr
        cast CastExpr
        composite CompositeLit
        const_ ConstExpr
        ellipsis EllipsisType
        enum_ EnumType
        func FuncExpr
        ident Ident
        index IndexExpr
        key_value KeyValueExpr
        map_ MapType
        native NativeType
        paren ParenExpr
        selector SelectorExpr
        sizeof_ SizeofExpr
        star StarExpr
        struct_ StructType
        ternary TernaryExpr
        unary UnaryExpr
    }
}

typ ImportDecl struct {
    name *Expr
    path *Expr
}

typ PragmaDecl struct {
    lit runtime.charptr
}

typ TypeDecl struct {
    name *Expr
    type *Expr
}

typ ValueDecl struct {
    name *Expr
    type *Expr
    value *Expr
    kind token.Token
}

typ FuncDecl struct {
    name *Expr
    recv *Decl
    type *Expr
    body *Stmt
}

typ Field struct {
    name *Expr
    type *Expr
}

typ Decl struct {
    Node
    pos token.Pos
    union {
        imp ImportDecl
        pragma PragmaDecl
        type TypeDecl
        value ValueDecl
        func FuncDecl
        field Field
    }
}

typ AssignStmt struct {
    x *Expr
    op token.Token
    y *Expr
}

typ BlockStmt struct {
    pos token.Pos
    stmts []*Stmt
}

typ CaseStmt struct {
    pos token.Pos
    exprs []*Expr
    stmts []*Stmt
}

typ EmptyStmt struct {
    pos token.Pos
}

typ ExprStmt struct {
    x *Expr
}

typ DeclStmt struct {
    decl *Decl
}

typ IfStmt struct {
    pos token.Pos
    init *Stmt
    cond *Expr
    body *Stmt
    else_ *Stmt
}

typ IterStmt struct {
    pos token.Pos
    kind token.Token
    init *Stmt
    cond *Expr
    post *Stmt
    body *Stmt
}

typ JumpStmt struct {
    pos token.Pos
    keyword token.Token
    label *Expr
}

typ LabelStmt struct {
    label *Expr
    stmt *Stmt
}

typ PostfixStmt struct {
    x *Expr
    op token.Token
}

typ ReturnStmt struct {
    pos token.Pos
    x *Expr
}

typ SwitchStmt struct {
    pos token.Pos
    tag *Expr
    stmts []*Stmt
}

typ Stmt struct {
    Node
    union {
        assign AssignStmt
        block BlockStmt
        case_ CaseStmt
        decl DeclStmt
        empty EmptyStmt
        expr ExprStmt
        iter IterStmt
        if_ IfStmt
        jump JumpStmt
        label LabelStmt
        postfix PostfixStmt
        return_ ReturnStmt
        switch_ SwitchStmt
    }
}

typ Scope struct {
    outer *Scope
    objects map *Object
    keys []runtime.charptr
    pkgName *Expr
}

typ File struct {
    filename runtime.charstr
    name *Expr
    imports []*Decl
    decls []*Decl
}

typ Package struct {
    name runtime.charptr
    scope *Scope
    files []*File
}

fun isExprType(x *Expr) bool {
    return _TYPE_START < x.kind && x.kind < _TYPE_END
}

fun newObject(kind ObjKind, name runtime.charptr) *Object {
    var obj = Object{
        kind: kind,
        name: name,
    }
    return &&obj
}

fun Scope_new(outer *Scope) *Scope {
    var s = Scope{
        outer: outer,
        objects: runtime.Map_make(sizeof(*Object)),
        keys: makearray(runtime.charptr),
    }
    return &&s
}

fun Scope_unmake(s *Scope) {
    if s {
        runtime.Map_unmake(&s.objects)
        runtime.Slice_unmake(&s.keys)
    }
}

fun Scope_insert(s *Scope, obj *Object) *Object {
    var alt *Object = nil
    runtime.Map_get(&s.objects, obj.name, &alt)
    if alt == nil {
        runtime.Map_set(&s.objects, obj.name, &obj)
        append(s.keys, obj.name)
    }
    return alt
}

fun Scope_lookup(s *Scope, name runtime.charptr) *Object {
    var obj *Object = nil
    runtime.Map_get(&s.objects, name, &obj)
    return obj
}

fun Scope_print(s *Scope) {
    var buf = bytes.Buffer{}
    while s {
        var iter = runtime.NewMapIter(&s.objects)
        var key runtime.charptr = nil
        while runtime.MapIter_next(&iter, &key, nil) {
            var s = C.sprintf("%s- %s", bytes.Buffer_string(&buf), key)
            print(s)
            runtime.free(s)
        }
        s = s.outer
        bytes.Buffer_writeByte(&buf, '\t', nil)
    }
}

fun Scope_deepLookup(s *Scope, name runtime.charptr) *Object {
    for ; s != nil; s = s.outer {
        var obj = Scope_lookup(s, name)
        if obj != nil {
            return obj
        }
    }
    return nil
}

fun resolve(scope *Scope, ident *Expr) bool {
    var obj = Scope_deepLookup(scope, ident.ident.name)
    if obj != nil {
        ident.ident.obj = obj
        return true
    }
    return false
}

fun Scope_free(s *Scope) {
    runtime.Map_unmake(&s.objects)
    runtime.free(s)
}

fun isIdent(x *Expr) bool {
    return x.kind == EXPR_IDENT
}

fun isIdentNamed(x *Expr, name runtime.charstr) bool {
    return isIdent(x) && runtime.streq(x.ident.name, name)
}

fun isNil(x *Expr) bool {
    return isIdentNamed(x, "nil")
}

fun isVoid(x *Expr) bool {
    return isIdent(x) && runtime.streq(x.ident.name, "void")
}

fun isVoidPtr(x *Expr) bool {
    for ;; {
        switch x.kind {
        case EXPR_IDENT:
            if x.ident.obj == nil {
                return false
            }
            assert(x.ident.obj.kind == ObjKind_TYP)
            x = x.ident.obj.decl.type.type
            continue
        case EXPR_STAR:
            return isVoid(x.star.x)
        case TYPE_NATIVE:
            return x.native.info == 0
        default:
            return false
        }
    }
}

fun Decl_pos(d *Decl) token.Pos {
    return d.pos
}

fun Expr_pos(x *Expr) token.Pos {
    switch x.kind {
    case EXPR_BASIC_LIT:
        return x.basic.pos
    case EXPR_BINARY:
        return Expr_pos(x.binary.x)
    case EXPR_CALL:
        return Expr_pos(x.call.func)
    case EXPR_CAST:
        return x.cast.pos
    case EXPR_COMPOSITE_LIT:
        return x.composite.pos
    case EXPR_IDENT:
        return x.ident.pos
    case EXPR_INDEX:
        return Expr_pos(x.index.x)
    case EXPR_KEY_VALUE:
        return Expr_pos(x.key_value.key)
    case EXPR_PAREN:
        return x.paren.pos
    case EXPR_SELECTOR:
        return Expr_pos(x.selector.x)
    case EXPR_SIZEOF:
        return x.sizeof_.pos
    case EXPR_STAR:
        return x.star.pos
    case EXPR_TERNARY:
        return Expr_pos(x.ternary.cond)
    case EXPR_UNARY:
        return x.unary.pos
    case TYPE_ARRAY:
        return x.array_.pos
    case TYPE_ENUM:
        return x.enum_.pos
    case TYPE_NATIVE:
        return 0
    case TYPE_FUNC:
        return x.func.pos
    case TYPE_STRUCT:
        return x.struct_.pos
    default:
        return 0
    }
}

fun Stmt_pos(s *Stmt) token.Pos {
    switch s.kind {
    case STMT_ASSIGN:
        return Expr_pos(s.assign.x)
    case STMT_BLOCK:
        return s.block.pos
    case STMT_CASE:
        return s.case_.pos
    case STMT_DECL:
        return Decl_pos(s.decl.decl)
    case STMT_EMPTY:
        return s.empty.pos
    case STMT_EXPR:
        return Expr_pos(s.expr.x)
    case STMT_IF:
        return s.if_.pos
    case STMT_ITER:
        return s.iter.pos
    case STMT_JUMP:
        return s.jump.pos
    case STMT_LABEL:
        return Expr_pos(s.label.label)
    case STMT_POSTFIX:
        return Expr_pos(s.postfix.x)
    case STMT_RETURN:
        return s.return_.pos
    case STMT_SWITCH:
        return s.switch_.pos
    default:
        return 0
    }
}
