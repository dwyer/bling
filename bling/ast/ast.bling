package ast

import "bling/token"
import "bytes"
import "sys"
import "utils"

typedef NodeKind enum {
    NODE_ILLEGAL = 0
    _DECL_START
    DECL_FIELD
    DECL_FUNC
    DECL_IMPORT
    DECL_PRAGMA
    DECL_TYPEDEF
    DECL_VALUE
    _DECL_END
    _EXPR_START
    EXPR_BASIC_LIT
    EXPR_BINARY
    EXPR_CALL
    EXPR_CAST
    EXPR_COMPOSITE_LIT
    EXPR_IDENT
    EXPR_INDEX
    EXPR_KEY_VALUE
    EXPR_PAREN
    EXPR_SELECTOR
    EXPR_SIZEOF
    EXPR_STAR
    EXPR_TERNARY
    EXPR_UNARY
    _EXPR_END
    _STMT_START
    STMT_ASSIGN
    STMT_BLOCK
    STMT_CASE
    STMT_DECL
    STMT_EMPTY
    STMT_EXPR
    STMT_IF
    STMT_ITER
    STMT_JUMP
    STMT_LABEL
    STMT_POSTFIX
    STMT_RETURN
    STMT_SWITCH
    _STMT_END
    _TYPE_START
    TYPE_ARRAY
    TYPE_BUILTIN_FUNC
    TYPE_ELLIPSIS
    TYPE_ENUM
    TYPE_NATIVE
    TYPE_FUNC
    TYPE_STRUCT
    _TYPE_END
}

typedef Node struct {
    kind NodeKind
}

typedef ObjKind enum {
    ObjKind_BAD
    ObjKind_CON
    ObjKind_FUN
    ObjKind_PKG
    ObjKind_TYP
    ObjKind_VAL
}

typedef Object struct {
    kind ObjKind
    name *char
    decl *Decl
    data *void
    type *void
    scope *Scope
}

typedef ArrayType struct {
    pos token.Pos
    len *Expr
    elt *Expr
}

typedef BasicLit struct {
    pos token.Pos
    kind token.Token
    value *char
}

typedef BinaryExpr struct {
    op token.Token
    x *Expr
    y *Expr
}

typedef CallExpr struct {
    func *Expr
    args **Expr
}

typedef CastExpr struct {
    pos token.Pos
    type *Expr
    expr *Expr
}

typedef CompositeLit struct {
    pos token.Pos
    type *Expr
    list **Expr
}

typedef EllipsisType struct {
    pos token.Pos
}

typedef EnumType struct {
    pos token.Pos
    name *Expr
    enums **Decl
}

typedef FuncExpr struct {
    pos token.Pos
    result *Expr
    params **Decl
}

typedef Ident struct {
    pos token.Pos
    name *char
    obj *Object
}

typedef IndexExpr struct {
    x *Expr
    index *Expr
}

typedef KeyValueExpr struct {
    key *Expr
    value *Expr
    isArray bool
}

typedef NativeType struct {
    name *char
    size int
}

typedef ParenExpr struct {
    pos token.Pos
    x *Expr
}

typedef SelectorExpr struct {
    x *Expr
    tok token.Token
    sel *Expr
}

typedef SizeofExpr struct {
    pos token.Pos
    x *Expr
}

typedef StarExpr struct {
    pos token.Pos
    x *Expr
}

typedef StructType struct {
    pos token.Pos
    tok token.Token
    name *Expr
    fields **Decl
    scope *Scope
}

typedef TernaryExpr struct {
    cond *Expr
    x *Expr
    y *Expr
}

typedef UnaryExpr struct {
    pos token.Pos
    op token.Token
    x *Expr
}

typedef Expr struct {
    Node
    is_const bool
    union {
        array ArrayType
        basic BasicLit
        binary BinaryExpr
        call CallExpr
        cast CastExpr
        composite CompositeLit
        ellipsis EllipsisType
        enum_ EnumType
        func FuncExpr
        ident Ident
        index IndexExpr
        key_value KeyValueExpr
        native NativeType
        paren ParenExpr
        selector SelectorExpr
        sizeof_ SizeofExpr
        star StarExpr
        struct_ StructType
        ternary TernaryExpr
        unary UnaryExpr
    }
}

typedef ImportDecl struct {
    name *Expr
    path *Expr
}

typedef PragmaDecl struct {
    lit *char
}

typedef TypeDecl struct {
    name *Expr
    type *Expr
}

typedef ValueDecl struct {
    name *Expr
    type *Expr
    value *Expr
    kind token.Token
}

typedef FuncDecl struct {
    name *Expr
    type *Expr
    body *Stmt
}

typedef Field struct {
    name *Expr
    type *Expr
}

typedef Decl struct {
    Node
    pos token.Pos
    union {
        imp ImportDecl
        pragma PragmaDecl
        typedef_ TypeDecl
        value ValueDecl
        func FuncDecl
        field Field
    }
}

typedef AssignStmt struct {
    x *Expr
    op token.Token
    y *Expr
}

typedef BlockStmt struct {
    pos token.Pos
    stmts **Stmt
}

typedef CaseStmt struct {
    pos token.Pos
    exprs **Expr
    stmts **Stmt
}

typedef EmptyStmt struct {
    pos token.Pos
}

typedef ExprStmt struct {
    x *Expr
}

typedef DeclStmt struct {
    decl *Decl
}

typedef IfStmt struct {
    pos token.Pos
    cond *Expr
    body *Stmt
    else_ *Stmt
}

typedef IterStmt struct {
    pos token.Pos
    kind token.Token
    init *Stmt
    cond *Expr
    post *Stmt
    body *Stmt
}

typedef JumpStmt struct {
    pos token.Pos
    keyword token.Token
    label *Expr
}

typedef LabelStmt struct {
    label *Expr
    stmt *Stmt
}

typedef PostfixStmt struct {
    x *Expr
    op token.Token
}

typedef ReturnStmt struct {
    pos token.Pos
    x *Expr
}

typedef SwitchStmt struct {
    pos token.Pos
    tag *Expr
    stmts **Stmt
}

typedef Stmt struct {
    Node
    union {
        assign AssignStmt
        block BlockStmt
        case_ CaseStmt
        decl DeclStmt
        empty EmptyStmt
        expr ExprStmt
        iter IterStmt
        if_ IfStmt
        jump JumpStmt
        label LabelStmt
        postfix PostfixStmt
        return_ ReturnStmt
        switch_ SwitchStmt
    }
}

typedef Scope struct {
    outer *Scope
    objects utils.Map
    keys utils.Slice
    pkg *char
}

typedef File struct {
    filename *const char
    name *Expr
    imports **Decl
    decls **Decl
    scope *Scope
}

typedef Package struct {
    name *char
    scope *Scope
    files **File
}

fun isExprType(x *Expr) bool {
    return _TYPE_START < x.kind && x.kind < _DECL_END
}

fun newObject(kind ObjKind, name *char) *Object {
    var obj Object = {
        kind: kind,
        name: name,
    }
    return &&obj
}

fun Scope_new(outer *Scope) *Scope {
    var s Scope = {
        outer: outer,
        objects: utils.Map_init(sizeof(*Object)),
        keys: utils.Slice_init(sizeof(*char)),
    }
    return &&s
}

fun Scope_deinit(s *Scope) {
    if s {
        utils.Map_deinit(&s.objects)
        utils.Slice_deinit(&s.keys)
    }
}

fun Scope_insert(s *Scope, obj *Object) *Object {
    var alt *Object = NULL
    utils.Map_get(&s.objects, obj.name, &alt)
    if alt == NULL {
        utils.Map_set(&s.objects, obj.name, &obj)
        utils.Slice_append(&s.keys, &obj.name)
    }
    return alt
}

fun Scope_lookup(s *Scope, name *char) *Object {
    var obj *Object = NULL
    utils.Map_get(&s.objects, name, &obj)
    return obj
}

fun Scope_print(s *Scope) {
    var buf bytes.Buffer = {}
    while s {
        var iter utils.MapIter = utils.NewMapIter(&s.objects)
        var key *char = NULL
        while utils.MapIter_next(&iter, &key, NULL) {
            var s *char = sys.sprintf("%s- %s", bytes.Buffer_string(&buf), key)
            print(s)
            free(s)
        }
        s = s.outer
        bytes.Buffer_writeByte(&buf, '\t', NULL)
    }
}

fun resolve(scope *Scope, ident *Expr) bool {
    for ; scope != NULL; scope = scope.outer {
        var obj *Object = Scope_lookup(scope, ident.ident.name)
        if obj != NULL {
            ident.ident.obj = obj
            return true
        }
    }
    return false
}

fun Scope_free(s *Scope) {
    utils.Map_deinit(&s.objects)
    free(s)
}

fun isIdent(x *Expr) bool {
    return x.kind == EXPR_IDENT
}

fun isIdentNamed(x *Expr, name *const char) bool {
    return isIdent(x) && streq(x.ident.name, name)
}

fun isNil(x *Expr) bool {
    return isIdentNamed(x, "NULL")
}

fun isVoid(x *Expr) bool {
    return isIdent(x) && streq(x.ident.name, "void")
}

fun isVoidPtr(x *Expr) bool {
    if x.kind == EXPR_STAR {
        return isVoid(x.star.x)
    }
    return false
}

fun Decl_pos(d *Decl) token.Pos {
    return d.pos
}

fun Expr_pos(x *Expr) token.Pos {
    switch x.kind {
    case EXPR_BASIC_LIT:
        return x.basic.pos
    case EXPR_BINARY:
        return Expr_pos(x.binary.x)
    case EXPR_CALL:
        return Expr_pos(x.call.func)
    case EXPR_CAST:
        return x.cast.pos
    case EXPR_COMPOSITE_LIT:
        return x.composite.pos
    case EXPR_IDENT:
        return x.ident.pos
    case EXPR_INDEX:
        return Expr_pos(x.index.x)
    case EXPR_KEY_VALUE:
        return Expr_pos(x.key_value.key)
    case EXPR_PAREN:
        return x.paren.pos
    case EXPR_SELECTOR:
        return Expr_pos(x.selector.x)
    case EXPR_SIZEOF:
        return x.sizeof_.pos
    case EXPR_STAR:
        return x.star.pos
    case EXPR_TERNARY:
        return Expr_pos(x.ternary.cond)
    case EXPR_UNARY:
        return x.unary.pos
    case TYPE_ARRAY:
        return x.array.pos
    case TYPE_ENUM:
        return x.enum_.pos
    case TYPE_NATIVE:
        return 0
    case TYPE_FUNC:
        return x.func.pos
    case TYPE_STRUCT:
        return x.struct_.pos
    default:
        return 0
    }
}

fun Stmt_pos(s *Stmt) token.Pos {
    switch s.kind {
    case STMT_ASSIGN:
        return Expr_pos(s.assign.x)
    case STMT_BLOCK:
        return s.block.pos
    case STMT_CASE:
        return s.case_.pos
    case STMT_DECL:
        return Decl_pos(s.decl.decl)
    case STMT_EMPTY:
        return s.empty.pos
    case STMT_EXPR:
        return Expr_pos(s.expr.x)
    case STMT_IF:
        return s.if_.pos
    case STMT_ITER:
        return s.iter.pos
    case STMT_JUMP:
        return s.jump.pos
    case STMT_LABEL:
        return Expr_pos(s.label.label)
    case STMT_POSTFIX:
        return Expr_pos(s.postfix.x)
    case STMT_RETURN:
        return s.return_.pos
    case STMT_SWITCH:
        return s.switch_.pos
    default:
        return 0
    }
}
