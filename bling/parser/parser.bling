package parser

import "bling/ast"
import "bling/scanner"
import "bling/token"
import "bytes"
import "io/ioutil"
import "os"
import "paths"
import "utils"
import "sys"

typedef Parser struct {
    file *token.File
    scanner scanner.Scanner
    pos token.Pos
    tok token.Token
    lit *char
    pkgScope *ast.Scope
    topScope *ast.Scope
    c_mode bool
    pkgName *char
    exprLev int
    inRhs bool
    unresolved utils.Slice
    numIdents int
}

fun isTypeName(x *ast.Expr) bool {
    switch x.kind {
    case ast.EXPR_IDENT:
        return true
    case ast.EXPR_SELECTOR:
        return x.selector.x.kind == ast.EXPR_IDENT
    default:
        return false
    }
}

fun isLiteralType(x *ast.Expr) bool {
    switch x.kind {
    case ast.EXPR_IDENT, ast.TYPE_ARRAY, ast.TYPE_STRUCT:
        return true
    case ast.EXPR_SELECTOR:
        return x.selector.x.kind == ast.EXPR_IDENT
    default:
        return false
    }
}

fun unparen(x *ast.Expr) *ast.Expr {
    while x.kind == ast.EXPR_PAREN {
        x = x.paren.x
    }
    return x
}

fun openScope(p *Parser) {
    p.topScope = ast.Scope_new(p.topScope)
}

fun closeScope(p *Parser) {
    p.topScope = p.topScope.outer
}

fun tryResolve(p *Parser, x *ast.Expr, collectUnresolved bool) {
    return
    if x.kind != ast.EXPR_IDENT {
        return
    }
    assert(x.ident.obj == NULL)
    for var s *ast.Scope = p.topScope; s != NULL; s = s.outer {
        var obj *ast.Object = ast.Scope_lookup(s, x.ident.name)
        if obj != NULL {
            x.ident.obj = obj
            return
        }
    }
    if collectUnresolved {
        utils.Slice_append(&p.unresolved, &x)
    }
}

fun resolve(p *Parser, x *ast.Expr) {
    tryResolve(p, x, true)
}

fun next(p *Parser) {
    p.tok = scanner.scan(&p.scanner, &p.pos, &p.lit)
}

fun init(p *Parser, fset *token.FileSet, filename *const char, src *char) {
    assert(fset)
    p.file = token.FileSet_addFile(fset, filename, -1, strlen(src))
    p.lit = NULL
    scanner.init(&p.scanner, p.file, src)
    p.scanner.dontInsertSemis = !bytes.hasSuffix(filename, ".bling")
    p.exprLev = 0
    p.unresolved = utils.Slice_init(sizeof(*ast.Expr))
    next(p)
}

fun error(p *Parser, pos token.Pos, msg *char) {
    var position token.Position = token.File_position(p.file, pos)
    assert(p.topScope)
    assert(p.pkgScope)
    panic(sys.sprintf("%s: %s\n%s", token.Position_string(&position), msg, token.File_lineString(p.file, position.line)))
}

fun errorExpected(p *Parser, pos token.Pos, msg *char) {
    var buf bytes.Buffer = {}
    bytes.Buffer_write(&buf, "expected ", -1, NULL)
    bytes.Buffer_write(&buf, msg, -1, NULL)
    if pos == p.pos {
        if p.lit {
            bytes.Buffer_write(&buf, ", found ", -1, NULL)
            bytes.Buffer_write(&buf, p.lit, -1, NULL)
        } else {
            bytes.Buffer_write(&buf, ", found '", -1, NULL)
            bytes.Buffer_write(&buf, token.string(p.tok), -1, NULL)
            bytes.Buffer_writeByte(&buf, '\'', NULL)
        }
    }
    msg = bytes.Buffer_string(&buf)
    error(p, pos, msg)
    free(msg)
}

fun accept(p *Parser, tok0 token.Token) bool {
    if p.tok == tok0 {
        next(p)
        return true
    }
    return false
}

fun expect(p *Parser, tok token.Token) token.Pos {
    var pos token.Pos = p.pos
    if p.tok != tok {
        var lit *char = p.lit
        if lit == NULL {
            lit = token.string(p.tok)
        }
        errorExpected(p, pos, token.string(tok))
    }
    next(p)
    return pos
}

fun checkExpr(p *Parser, x *ast.Expr) *ast.Expr {
    switch unparen(x).kind {
    case ast.EXPR_IDENT, ast.EXPR_BASIC_LIT, ast.EXPR_BINARY, ast.EXPR_CALL, ast.EXPR_CAST, ast.EXPR_COMPOSITE_LIT, ast.EXPR_INDEX, ast.EXPR_SELECTOR, ast.EXPR_SIZEOF, ast.EXPR_STAR, ast.EXPR_TERNARY, ast.EXPR_UNARY:
        break
    case ast.EXPR_PAREN:
        panic("unreachable")
        break
    default:
        errorExpected(p, ast.Expr_pos(x), "expression")
        break
    }
    return x
}

fun checkExprOrType(p *Parser, x *ast.Expr) *ast.Expr {
    return x
}

fun declare(p *Parser, decl *ast.Decl, data *void, scope *ast.Scope, kind ast.ObjKind, ident *ast.Expr) {
    return
    if ident.ident.obj != NULL {
        error(p, decl.pos, sys.sprintf("identifier already declared or resolved: %s", ident.ident.name))
    }
    var obj *ast.Object = ast.newObject(kind, ident.ident.name)
    obj.decl = decl
    obj.data = NULL
    obj.scope = scope
    ident.ident.obj = obj
    var alt *ast.Object = ast.Scope_insert(scope, obj)
    if alt != NULL {
        error(p, ast.Expr_pos(ident), sys.sprintf("%s redeclared in this block", ident.ident.name))
    }
}

var LHS const bool = false

fun parseRhs(p *Parser) *ast.Expr {
    var old bool = p.inRhs
    p.inRhs = true
    var x *ast.Expr = checkExpr(p, parseExpr(p, false))
    p.inRhs = old
    return x
}

fun parseRhsOrType(p *Parser) *ast.Expr {
    var old bool = p.inRhs
    p.inRhs = true
    var x *ast.Expr = checkExprOrType(p, parseExpr(p, false))
    p.inRhs = old
    return x
}

fun parseBasicLit(p *Parser, kind token.Token) *ast.Expr {
    var value *char = p.lit
    p.lit = NULL
    var pos token.Pos = expect(p, kind)
    var x ast.Expr = {
        kind: ast.EXPR_BASIC_LIT,
        basic: {
            pos: pos,
            kind: kind,
            value: value,
        },
    }
    return esc(x)
}

fun parseIdent(p *Parser) *ast.Expr {
    var x ast.Expr = {
        kind: ast.EXPR_IDENT,
        ident: {
            pos: p.pos,
        },
    }
    if p.tok == token.IDENT {
        x.ident.name = p.lit
        p.lit = NULL
    }
    expect(p, token.IDENT)
    p.numIdents++
    return esc(x)
}

fun parseOperand(p *Parser, lhs bool) *ast.Expr {
    switch p.tok {
    case token.IDENT:
        {
            var x *ast.Expr = parseIdent(p)
            resolve(p, x)
            return x
        }
    case token.CHAR, token.FLOAT, token.INT, token.STRING:
        return parseBasicLit(p, p.tok)
    case token.LPAREN:
        if p.c_mode {
            error(p, p.pos, "unreachable")
        } else {
            var pos token.Pos = p.pos
            expect(p, token.LPAREN)
            p.exprLev++
            var x ast.Expr = {
                kind: ast.EXPR_PAREN,
                paren: {
                    pos: pos,
                    x: parseRhsOrType(p),
                },
            }
            p.exprLev--
            expect(p, token.RPAREN)
            return esc(x)
        }
    default:
        break
    }
    var t *ast.Expr = tryIdentOrType(p)
    if t {
        assert(t.kind != ast.EXPR_IDENT)
        return t
    }
    errorExpected(p, p.pos, "operand")
    return NULL
}

fun parseValue(p *Parser, keyOk bool) *ast.Expr {
    if p.tok == token.LBRACE {
        return parseLiteralValue(p, NULL)
    }
    var x *ast.Expr = checkExpr(p, parseExpr(p, keyOk))
    if keyOk {
        if p.tok != token.COLON {
            resolve(p, x)
        }
    }
    return x
}

fun parseElement(p *Parser) *ast.Expr {
    var value *ast.Expr = parseValue(p, true)
    if value.kind == ast.EXPR_IDENT && accept(p, token.COLON) {
        var key *ast.Expr = value
        var x ast.Expr = {
            kind: ast.EXPR_KEY_VALUE,
            key_value: {
                key: key,
                value: parseValue(p, false),
            },
        }
        value = esc(x)
    }
    return value
}

fun parseElementList(p *Parser) **ast.Expr {
    var list utils.Slice = {
        size: sizeof(*ast.Expr),
    }
    while p.tok != token.RBRACE && p.tok != token.EOF {
        var value *ast.Expr = parseElement(p)
        utils.Slice_append(&list, &value)
        if !accept(p, token.COMMA) {
            break
        }
    }
    return utils.Slice_to_nil_array(list)
}

fun parseLiteralValue(p *Parser, type *ast.Expr) *ast.Expr {
    var pos token.Pos = expect(p, token.LBRACE)
    if type {
        pos = ast.Expr_pos(type)
    }
    p.exprLev++
    var list **ast.Expr = parseElementList(p)
    p.exprLev--
    expect(p, token.RBRACE)
    var expr ast.Expr = {
        kind: ast.EXPR_COMPOSITE_LIT,
        composite: {
            pos: pos,
            type: type,
            list: list,
        },
    }
    return esc(expr)
}

fun parseIndexExpr(p *Parser, x *ast.Expr) *ast.Expr {
    expect(p, token.LBRACK)
    p.exprLev++
    var y ast.Expr = {
        kind: ast.EXPR_INDEX,
        index: {
            x: x,
            index: parseRhs(p),
        },
    }
    p.exprLev--
    expect(p, token.RBRACK)
    return esc(y)
}

fun parseCallExpr(p *Parser, x *ast.Expr) *ast.Expr {
    var args utils.Slice = {
        size: sizeof(*ast.Expr),
    }
    expect(p, token.LPAREN)
    p.exprLev++
    while p.tok != token.RPAREN {
        var x *ast.Expr = parseRhsOrType(p)
        utils.Slice_append(&args, &x)
        if !accept(p, token.COMMA) {
            break
        }
    }
    p.exprLev--
    expect(p, token.RPAREN)
    var call ast.Expr = {
        kind: ast.EXPR_CALL,
        call: {
            func: x,
            args: utils.Slice_to_nil_array(args),
        },
    }
    return esc(call)
}

fun parseSelector(p *Parser, x *ast.Expr) *ast.Expr {
    var y ast.Expr = {
        kind: ast.EXPR_SELECTOR,
        selector: {
            x: x,
            tok: token.PERIOD,
            sel: parseIdent(p),
        },
    }
    return esc(y)
}

fun parsePrimaryExpr(p *Parser, lhs bool) *ast.Expr {
    var x *ast.Expr = parseOperand(p, lhs)
    for ;; {
        switch p.tok {
        case token.PERIOD:
            next(p)
            if lhs {
                resolve(p, x)
            }
            x = parseSelector(p, checkExprOrType(p, x))
            break
        case token.LBRACK:
            if lhs {
                resolve(p, x)
            }
            x = parseIndexExpr(p, checkExpr(p, x))
            break
        case token.LPAREN:
            if lhs {
                resolve(p, x)
            }
            x = parseCallExpr(p, checkExprOrType(p, x))
            break
        case token.LBRACE:
            if isLiteralType(x) && (p.exprLev >= 0 || !isTypeName(x)) {
                if lhs {
                    resolve(p, x)
                }
                x = parseLiteralValue(p, x)
                break
            } else {
                return x
            }
        default:
            return x
        }
    }
}

fun parseUnaryExpr(p *Parser, lhs bool) *ast.Expr {
    switch p.tok {
    case token.ADD, token.AND, token.BITWISE_NOT, token.NOT, token.SUB:
        {
            var pos token.Pos = p.pos
            var op token.Token = p.tok
            next(p)
            var x ast.Expr = {
                kind: ast.EXPR_UNARY,
                unary: {
                    pos: pos,
                    op: op,
                    x: checkExpr(p, parseUnaryExpr(p, false)),
                },
            }
            return esc(x)
        }
    case token.MUL:
        {
            var pos token.Pos = p.pos
            next(p)
            var x ast.Expr = {
                kind: ast.EXPR_STAR,
                star: {
                    pos: pos,
                    x: checkExprOrType(p, parseUnaryExpr(p, false)),
                },
            }
            return esc(x)
        }
    case token.SIZEOF:
        {
            var pos token.Pos = p.pos
            next(p)
            expect(p, token.LPAREN)
            var x ast.Expr = {
                kind: ast.EXPR_SIZEOF,
                sizeof_: {
                    pos: pos,
                    x: parseType(p),
                },
            }
            expect(p, token.RPAREN)
            return esc(x)
        }
    case token.LT:
        {
            var pos token.Pos = p.pos
            expect(p, token.LT)
            var type *ast.Expr = parseType(p)
            expect(p, token.GT)
            if p.tok == token.LBRACE {
                return parseLiteralValue(p, type)
            }
            var y ast.Expr = {
                kind: ast.EXPR_CAST,
                cast: {
                    pos: pos,
                    type: type,
                    expr: parseUnaryExpr(p, false),
                },
            }
            return esc(y)
        }
    default:
        return parsePrimaryExpr(p, lhs)
    }
}

fun parseBinaryExpr(p *Parser, lhs bool, prec1 int) *ast.Expr {
    var x *ast.Expr = parseUnaryExpr(p, lhs)
    for ;; {
        var op token.Token = p.tok
        var oprec int = token.precedence(op)
        if oprec < prec1 {
            return x
        }
        expect(p, op)
        if lhs {
            resolve(p, x)
            lhs = false
        }
        var y *ast.Expr = parseBinaryExpr(p, false, oprec + 1)
        var z ast.Expr = {
            kind: ast.EXPR_BINARY,
            binary: {
                x: checkExpr(p, x),
                op: op,
                y: checkExpr(p, y),
            },
        }
        x = esc(z)
    }
}

fun parseTernaryExpr(p *Parser, lhs bool) *ast.Expr {
    var x *ast.Expr = parseBinaryExpr(p, lhs, token.lowest_prec + 1)
    if accept(p, token.QUESTION_MARK) {
        var consequence *ast.Expr = NULL
        if p.tok != token.COLON {
            consequence = parseExpr(p, false)
        }
        expect(p, token.COLON)
        var alternative *ast.Expr = parseTernaryExpr(p, false)
        var y ast.Expr = {
            kind: ast.EXPR_TERNARY,
            ternary: {
                cond: x,
                x: consequence,
                y: alternative,
            },
        }
        x = esc(y)
    }
    return x
}

fun parseExpr(p *Parser, lhs bool) *ast.Expr {
    return parseTernaryExpr(p, lhs)
}

fun parseTypeName(p *Parser) *ast.Expr {
    var x *ast.Expr = parseIdent(p)
    if accept(p, token.PERIOD) {
        resolve(p, x)
        var y ast.Expr = {
            kind: ast.EXPR_SELECTOR,
            selector: {
                x: x,
                tok: token.DOLLAR,
                sel: parseIdent(p),
            },
        }
        x = esc(y)
    }
    return x
}

fun parseArrayType(p *Parser) *ast.Expr {
    var pos token.Pos = expect(p, token.LBRACK)
    p.exprLev++
    var len *ast.Expr = NULL
    if p.tok != token.RBRACK {
        len = parseRhs(p)
    }
    p.exprLev--
    expect(p, token.RBRACK)
    var type ast.Expr = {
        kind: ast.TYPE_ARRAY,
        array: {
            pos: pos,
            elt: parseType(p),
            len: len,
        },
    }
    return esc(type)
}

fun parseFieldDecl(p *Parser, scope *ast.Scope) *ast.Decl {
    var decl ast.Decl = {
        kind: ast.DECL_FIELD,
        pos: p.pos,
    }
    if p.tok == token.UNION {
        decl.field.type = parseType(p)
    } else {
        decl.field.name = parseIdent(p)
        if p.tok == token.SEMICOLON {
            decl.field.type = decl.field.name
            decl.field.name = NULL
        } else {
            decl.field.type = parseType(p)
        }
    }
    var d *ast.Decl = esc(decl)
    if decl.field.name {
        declare(p, d, NULL, scope, ast.ObjKind_VAL, decl.field.name)
    }
    resolve(p, decl.field.type)
    expect(p, token.SEMICOLON)
    return d
}

fun parseStructOrUnionType(p *Parser, keyword token.Token) *ast.Expr {
    var pos token.Pos = p.pos
    expect(p, keyword)
    openScope(p)
    var fields **ast.Decl = NULL
    if accept(p, token.LBRACE) {
        var scope *ast.Scope = ast.Scope_new(p.topScope)
        var fieldSlice utils.Slice = {
            size: sizeof(*ast.Decl),
        }
        for ;; {
            var field *ast.Decl = parseFieldDecl(p, scope)
            utils.Slice_append(&fieldSlice, &field)
            if p.tok == token.RBRACE {
                break
            }
        }
        expect(p, token.RBRACE)
        fields = utils.Slice_to_nil_array(fieldSlice)
    }
    var x ast.Expr = {
        kind: ast.TYPE_STRUCT,
        struct_: {
            pos: pos,
            tok: keyword,
            fields: fields,
        },
    }
    closeScope(p)
    return esc(x)
}

fun parsePointerType(p *Parser) *ast.Expr {
    var pos token.Pos = p.pos
    expect(p, token.MUL)
    var x ast.Expr = {
        kind: ast.EXPR_STAR,
        star: {
            pos: pos,
            x: parseType(p),
        },
    }
    return esc(x)
}

fun parseParam(p *Parser, scope *ast.Scope, anon bool) *ast.Decl {
    var decl ast.Decl = {
        kind: ast.DECL_FIELD,
        pos: p.pos,
    }
    if p.tok == token.IDENT {
        decl.field.name = parseIdent(p)
    }
    if decl.field.name != NULL && (p.tok == token.COMMA || p.tok == token.RPAREN) {
        decl.field.type = decl.field.name
        decl.field.name = NULL
    } else {
        decl.field.type = parseType(p)
    }
    var d *ast.Decl = esc(decl)
    if d.field.name {
        declare(p, d, NULL, scope, ast.ObjKind_VAL, d.field.name)
    }
    resolve(p, d.field.type)
    return d
}

fun parseParameterList(p *Parser, scope *ast.Scope, anon bool) **ast.Decl {
    var params utils.Slice = utils.Slice_init(sizeof(*ast.Decl))
    for ;; {
        var param *ast.Decl = parseParam(p, scope, false)
        utils.Slice_append(&params, &param)
        if !accept(p, token.COMMA) {
            break
        }
        if p.tok == token.ELLIPSIS {
            var pos token.Pos = expect(p, token.ELLIPSIS)
            var type ast.Expr = {
                kind: ast.TYPE_ELLIPSIS,
                ellipsis: {
                    pos: pos,
                },
            }
            var decl ast.Decl = {
                kind: ast.DECL_FIELD,
                pos: pos,
                field: {
                    type: esc(type),
                },
            }
            var param *ast.Decl = esc(decl)
            utils.Slice_append(&params, &param)
            break
        }
    }
    return utils.Slice_to_nil_array(params)
}

fun parseParameters(p *Parser, scope *ast.Scope, anon bool) **ast.Decl {
    var params **ast.Decl = NULL
    expect(p, token.LPAREN)
    if p.tok != token.RPAREN {
        params = parseParameterList(p, scope, anon)
    }
    expect(p, token.RPAREN)
    return params
}

fun parseFuncType(p *Parser) *ast.Expr {
    var pos token.Pos = expect(p, token.FUNC)
    var scope *ast.Scope = ast.Scope_new(p.topScope)
    var params **ast.Decl = parseParameters(p, scope, false)
    var result *ast.Expr = NULL
    if p.tok != token.SEMICOLON {
        result = parseType(p)
    }
    var type ast.Expr = {
        kind: ast.TYPE_FUNC,
        func: {
            pos: pos,
            params: params,
            result: result,
        },
    }
    var ptr ast.Expr = {
        kind: ast.EXPR_STAR,
        star: {
            pos: pos,
            x: esc(type),
        },
    }
    return esc(ptr)
}

fun parseEnumType(p *Parser) *ast.Expr {
    var pos token.Pos = p.pos
    expect(p, token.ENUM)
    var enums **ast.Decl = NULL
    if accept(p, token.LBRACE) {
        var list utils.Slice = {
            size: sizeof(*ast.Decl),
        }
        while p.tok != token.RBRACE {
            var decl ast.Decl = {
                kind: ast.DECL_VALUE,
                pos: p.pos,
                value: {
                    name: parseIdent(p),
                },
            }
            if accept(p, token.ASSIGN) {
                decl.value.value = parseRhs(p)
            }
            var enumerator *ast.Decl = esc(decl)
            utils.Slice_append(&list, &enumerator)
            expect(p, token.SEMICOLON)
        }
        enums = utils.Slice_to_nil_array(list)
        expect(p, token.RBRACE)
    }
    var x ast.Expr = {
        kind: ast.TYPE_ENUM,
        enum_: {
            pos: pos,
            enums: enums,
        },
    }
    return esc(x)
}

fun parseQualifiedType(p *Parser, tok token.Token) *ast.Expr {
    expect(p, tok)
    var type *ast.Expr = parseType(p)
    type.is_const = true
    return type
}

fun tryIdentOrType(p *Parser) *ast.Expr {
    switch p.tok {
    case token.IDENT:
        return parseTypeName(p)
    case token.LBRACK:
        return parseArrayType(p)
    case token.STRUCT, token.UNION:
        return parseStructOrUnionType(p, p.tok)
    case token.MUL:
        return parsePointerType(p)
    case token.FUNC:
        return parseFuncType(p)
    case token.ENUM:
        return parseEnumType(p)
    case token.CONST:
        return parseQualifiedType(p, p.tok)
    default:
        return NULL
    }
}

fun tryType(p *Parser) *ast.Expr {
    var t *ast.Expr = tryIdentOrType(p)
    if t != NULL {
        resolve(p, t)
    }
    return t
}

fun parseType(p *Parser) *ast.Expr {
    var t *ast.Expr = tryType(p)
    if t == NULL {
        errorExpected(p, p.pos, "type")
    }
    return t
}

fun parseSimpleStmt(p *Parser, labelOk bool) *ast.Stmt {
    var x *ast.Expr = parseExpr(p, true)
    var op token.Token = p.tok
    switch op {
    case token.ADD_ASSIGN, token.ASSIGN, token.DIV_ASSIGN, token.MOD_ASSIGN, token.MUL_ASSIGN, token.SHL_ASSIGN, token.SHR_ASSIGN, token.SUB_ASSIGN, token.XOR_ASSIGN:
        {
            next(p)
            var y *ast.Expr = parseRhs(p)
            var stmt ast.Stmt = {
                kind: ast.STMT_ASSIGN,
                assign: {
                    x: x,
                    op: op,
                    y: y,
                },
            }
            return esc(stmt)
        }
    case token.INC, token.DEC:
        {
            next(p)
            var stmt ast.Stmt = {
                kind: ast.STMT_POSTFIX,
                postfix: {
                    x: x,
                    op: op,
                },
            }
            return esc(stmt)
        }
    default:
        break
    }
    if labelOk && x.kind == ast.EXPR_IDENT {
        if accept(p, token.COLON) {
            var stmt ast.Stmt = {
                kind: ast.STMT_LABEL,
                label: {
                    label: x,
                    stmt: parseStmt(p),
                },
            }
            return esc(stmt)
        }
    }
    var stmt ast.Stmt = {
        kind: ast.STMT_EXPR,
        expr: {
            x: x,
        },
    }
    return esc(stmt)
}

fun parseForStmt(p *Parser) *ast.Stmt {
    var pos token.Pos = expect(p, token.FOR)
    var prevLev int = p.exprLev
    p.exprLev = -1
    var init *ast.Stmt = NULL
    if !accept(p, token.SEMICOLON) {
        init = parseStmt(p)
    }
    var cond *ast.Expr = NULL
    if p.tok != token.SEMICOLON {
        cond = parseRhs(p)
    }
    expect(p, token.SEMICOLON)
    var post *ast.Stmt = NULL
    if p.tok != token.LBRACE {
        post = parseSimpleStmt(p, false)
    }
    p.exprLev = prevLev
    var body *ast.Stmt = parseBlockStmt(p)
    var stmt ast.Stmt = {
        kind: ast.STMT_ITER,
        iter: {
            pos: pos,
            kind: token.FOR,
            init: init,
            cond: cond,
            post: post,
            body: body,
        },
    }
    return esc(stmt)
}

fun parseIfStmt(p *Parser) *ast.Stmt {
    var pos token.Pos = expect(p, token.IF)
    var outer int = p.exprLev
    p.exprLev = -1
    var cond *ast.Expr = parseExpr(p, true)
    p.exprLev = outer
    if p.tok != token.LBRACE {
        error(p, p.pos, "`if` must be followed by a compound_statement")
    }
    var body *ast.Stmt = parseBlockStmt(p)
    var else_ *ast.Stmt = NULL
    if accept(p, token.ELSE) {
        if p.tok == token.IF {
            else_ = parseStmt(p)
        } else if p.tok == token.LBRACE {
            else_ = parseBlockStmt(p)
        } else {
            error(p, p.pos, "`else` must be followed by an if_statement or compound_statement")
        }
    }
    var stmt ast.Stmt = {
        kind: ast.STMT_IF,
        if_: {
            pos: pos,
            cond: cond,
            body: body,
            else_: else_,
        },
    }
    return esc(stmt)
}

fun parseReturnStmt(p *Parser) *ast.Stmt {
    var pos token.Pos = expect(p, token.RETURN)
    var x *ast.Expr = NULL
    if p.tok != token.SEMICOLON {
        x = parseRhs(p)
    }
    expect(p, token.SEMICOLON)
    var stmt ast.Stmt = {
        kind: ast.STMT_RETURN,
        return_: {
            pos: pos,
            x: x,
        },
    }
    return esc(stmt)
}

fun parseSwitchStmt(p *Parser) *ast.Stmt {
    var pos token.Pos = expect(p, token.SWITCH)
    var prevLev int = p.exprLev
    p.exprLev = -1
    var tag *ast.Expr = parseExpr(p, true)
    p.exprLev = prevLev
    expect(p, token.LBRACE)
    openScope(p)
    var clauses utils.Slice = {
        size: sizeof(*ast.Stmt),
    }
    while p.tok == token.CASE || p.tok == token.DEFAULT {
        var exprs utils.Slice = {
            size: sizeof(*ast.Expr),
        }
        var pos token.Pos = p.pos
        if accept(p, token.CASE) {
            for ;; {
                var expr *ast.Expr = parseRhs(p)
                utils.Slice_append(&exprs, &expr)
                if !accept(p, token.COMMA) {
                    break
                }
            }
        } else {
            expect(p, token.DEFAULT)
        }
        expect(p, token.COLON)
        var stmts utils.Slice = {
            size: sizeof(*ast.Stmt),
        }
        var loop bool = true
        while loop {
            switch p.tok {
            case token.CASE, token.DEFAULT, token.RBRACE:
                loop = false
                break
            default:
                break
            }
            if loop {
                var stmt *ast.Stmt = parseStmt(p)
                utils.Slice_append(&stmts, &stmt)
            }
        }
        var stmt ast.Stmt = {
            kind: ast.STMT_CASE,
            case_: {
                pos: pos,
                exprs: utils.Slice_to_nil_array(exprs),
                stmts: utils.Slice_to_nil_array(stmts),
            },
        }
        var clause *ast.Stmt = esc(stmt)
        utils.Slice_append(&clauses, &clause)
    }
    closeScope(p)
    expect(p, token.RBRACE)
    accept(p, token.SEMICOLON)
    var stmt ast.Stmt = {
        kind: ast.STMT_SWITCH,
        switch_: {
            pos: pos,
            tag: tag,
            stmts: utils.Slice_to_nil_array(clauses),
        },
    }
    return esc(stmt)
}

fun parseWhileStmt(p *Parser) *ast.Stmt {
    var pos token.Pos = expect(p, token.WHILE)
    var prevLev int = p.exprLev
    p.exprLev = -1
    var cond *ast.Expr = parseExpr(p, true)
    p.exprLev = prevLev
    var body *ast.Stmt = parseBlockStmt(p)
    var stmt ast.Stmt = {
        kind: ast.STMT_ITER,
        iter: {
            pos: pos,
            kind: token.WHILE,
            cond: cond,
            body: body,
        },
    }
    return esc(stmt)
}

fun parseJumpStmt(p *Parser, keyword token.Token) *ast.Stmt {
    var pos token.Pos = expect(p, keyword)
    var label *ast.Expr = NULL
    if keyword == token.GOTO {
        label = parseIdent(p)
    }
    expect(p, token.SEMICOLON)
    var stmt ast.Stmt = {
        kind: ast.STMT_JUMP,
        jump: {
            pos: pos,
            keyword: keyword,
            label: label,
        },
    }
    return esc(stmt)
}

fun parseDeclStmt(p *Parser) *ast.Stmt {
    var stmt ast.Stmt = {
        kind: ast.STMT_DECL,
        decl: {
            decl: parseDecl(p),
        },
    }
    return esc(stmt)
}

fun parseStmt(p *Parser) *ast.Stmt {
    switch p.tok {
    case token.VAR:
        return parseDeclStmt(p)
    case token.FOR:
        return parseForStmt(p)
    case token.IF:
        return parseIfStmt(p)
    case token.RETURN:
        return parseReturnStmt(p)
    case token.SWITCH:
        return parseSwitchStmt(p)
    case token.WHILE:
        return parseWhileStmt(p)
    case token.BREAK, token.CONTINUE, token.GOTO:
        return parseJumpStmt(p, p.tok)
    case token.LBRACE:
        return parseBlockStmt(p)
    default:
        break
    }
    var pos token.Pos = p.pos
    if accept(p, token.SEMICOLON) {
        var stmt ast.Stmt = {
            kind: ast.STMT_EMPTY,
            empty: {
                pos: pos,
            },
        }
        return esc(stmt)
    }
    var stmt *ast.Stmt = parseSimpleStmt(p, true)
    if stmt.kind != ast.STMT_LABEL {
        expect(p, token.SEMICOLON)
    }
    return stmt
}

fun parseStmtList(p *Parser) **ast.Stmt {
    var stmts utils.Slice = {
        size: sizeof(*ast.Stmt),
    }
    while p.tok != token.RBRACE {
        var stmt *ast.Stmt = parseStmt(p)
        utils.Slice_append(&stmts, &stmt)
    }
    return utils.Slice_to_nil_array(stmts)
}

fun parseBody(p *Parser, scope *ast.Scope) *ast.Stmt {
    var pos token.Pos = expect(p, token.LBRACE)
    assert(p.topScope == scope.outer)
    p.topScope = scope
    var list **ast.Stmt = parseStmtList(p)
    closeScope(p)
    expect(p, token.RBRACE)
    accept(p, token.SEMICOLON)
    var stmt ast.Stmt = {
        kind: ast.STMT_BLOCK,
        block: {
            pos: pos,
            stmts: list,
        },
    }
    return esc(stmt)
}

fun parseBlockStmt(p *Parser) *ast.Stmt {
    var pos token.Pos = expect(p, token.LBRACE)
    openScope(p)
    var list **ast.Stmt = parseStmtList(p)
    closeScope(p)
    expect(p, token.RBRACE)
    accept(p, token.SEMICOLON)
    var stmt ast.Stmt = {
        kind: ast.STMT_BLOCK,
        block: {
            pos: pos,
            stmts: list,
        },
    }
    return esc(stmt)
}

fun parsePragma(p *Parser) *ast.Decl {
    var pos token.Pos = p.pos
    var lit *char = p.lit
    p.lit = NULL
    expect(p, token.HASH)
    var decl ast.Decl = {
        kind: ast.DECL_PRAGMA,
        pos: pos,
        pragma: {
            lit: lit,
        },
    }
    return esc(decl)
}

fun parseValueDecl(p *Parser) *ast.Decl {
    var keyword token.Token = p.tok
    var pos token.Pos = expect(p, keyword)
    var ident *ast.Expr = parseIdent(p)
    var type *ast.Expr = NULL
    if p.tok != token.ASSIGN {
        type = parseType(p)
    }
    var value *ast.Expr = NULL
    if accept(p, token.ASSIGN) {
        if p.tok == token.LBRACE {
            value = parseLiteralValue(p, NULL)
        } else {
            value = parseRhs(p)
        }
    }
    expect(p, token.SEMICOLON)
    var decl ast.Decl = {
        kind: ast.DECL_VALUE,
        pos: pos,
        value: {
            name: ident,
            type: type,
            value: value,
            kind: keyword,
        },
    }
    var d *ast.Decl = esc(decl)
    declare(p, d, NULL, p.topScope, ast.ObjKind_VAL, d.value.name)
    return d
}

fun parseTypeDecl(p *Parser) *ast.Decl {
    var keyword token.Token = p.tok
    var pos token.Pos = expect(p, keyword)
    var ident *ast.Expr = parseIdent(p)
    var type *ast.Expr = parseType(p)
    expect(p, token.SEMICOLON)
    var decl ast.Decl = {
        kind: ast.DECL_TYPEDEF,
        pos: pos,
        typedef_: {
            name: ident,
            type: type,
        },
    }
    var d *ast.Decl = esc(decl)
    declare(p, d, NULL, p.topScope, ast.ObjKind_TYP, ident)
    return d
}

fun parseFuncDecl(p *Parser) *ast.Decl {
    var pos token.Pos = expect(p, token.FUNC)
    var decl ast.Decl = {
        kind: ast.DECL_FUNC,
        pos: pos,
        func: {
            name: parseIdent(p),
        },
    }
    var scope *ast.Scope = ast.Scope_new(p.topScope)
    var type ast.Expr = {
        kind: ast.TYPE_FUNC,
        func: {
            pos: pos,
            params: parseParameters(p, scope, false),
        },
    }
    if p.tok != token.LBRACE && p.tok != token.SEMICOLON {
        type.func.result = parseType(p)
    }
    decl.func.type = esc(type)
    if p.tok == token.LBRACE {
        decl.func.body = parseBody(p, scope)
    } else {
        expect(p, token.SEMICOLON)
    }
    var d *ast.Decl = esc(decl)
    declare(p, d, NULL, p.topScope, ast.ObjKind_FUN, d.func.name)
    return d
}

fun parseDecl(p *Parser) *ast.Decl {
    switch p.tok {
    case token.HASH:
        return parsePragma(p)
    case token.TYPEDEF:
        return parseTypeDecl(p)
    case token.CONST, token.VAR:
        return parseValueDecl(p)
    case token.FUNC:
        return parseFuncDecl(p)
    default:
        error(p, p.pos, sys.sprintf("cant handle it: %s", token.string(p.tok)))
        return NULL
    }
}

fun isBlingFile(name *const char) bool {
    return bytes.hasSuffix(name, ".bling")
}

fun isTestFile(name *const char) bool {
    return paths.match("*_test.bling", name)
}

fun parseDir(fset *token.FileSet, path *const char, scope *ast.Scope, first **utils.Error) **ast.File {
    var err *utils.Error = NULL
    var infos **os.FileInfo = ioutil.readDir(path, &err)
    if err {
        utils.Error_move(err, first)
        return NULL
    }
    var files utils.Slice = utils.Slice_init(sizeof(uintptr_t))
    for var i int = 0; infos[i]; i++ {
        var name *char = os.FileInfo_name(infos[i])
        if isBlingFile(name) && !isTestFile(name) {
            var file *ast.File = parseFile(fset, name, scope)
            utils.Slice_append(&files, &file)
        }
    }
    free(infos)
    return utils.Slice_to_nil_array(files)
}

fun _parseFile(p *Parser, scope *ast.Scope) *ast.File {
    var name *ast.Expr = NULL
    var imports utils.Slice = utils.Slice_init(sizeof(uintptr_t))
    var decls utils.Slice = utils.Slice_init(sizeof(*ast.Decl))
    while p.tok == token.HASH {
        var lit *ast.Decl = parsePragma(p)
        utils.Slice_append(&decls, &lit)
    }
    if accept(p, token.PACKAGE) {
        name = parseIdent(p)
        expect(p, token.SEMICOLON)
    }
    assert(p.topScope == NULL)
    p.topScope = scope
    openScope(p)
    p.pkgScope = p.topScope
    if name {
        p.pkgScope.pkg = name.ident.name
    }
    while p.tok == token.IMPORT {
        var pos token.Pos = expect(p, token.IMPORT)
        var path *ast.Expr = parseBasicLit(p, token.STRING)
        expect(p, token.SEMICOLON)
        var decl ast.Decl = {
            kind: ast.DECL_IMPORT,
            pos: pos,
            imp: {
                path: path,
            },
        }
        var declp *ast.Decl = esc(decl)
        utils.Slice_append(&imports, &declp)
    }
    while p.tok != token.EOF {
        var decl *ast.Decl = parseDecl(p)
        utils.Slice_append(&decls, &decl)
    }
    closeScope(p)
    assert(p.topScope == scope)
    var file ast.File = {
        filename: p.file.name,
        name: name,
        imports: utils.Slice_to_nil_array(imports),
        decls: utils.Slice_to_nil_array(decls),
        scope: p.pkgScope,
    }
    return esc(file)
}

fun parseFile(fset *token.FileSet, filename *const char, scope *ast.Scope) *ast.File {
    var err *utils.Error = NULL
    var src *char = ioutil.readFile(filename, &err)
    if err {
        panic(sys.sprintf("%s: %s", filename, err.error))
    }
    var p Parser = {}
    init(&p, fset, filename, src)
    free(src)
    var file *ast.File = _parseFile(&p, scope)
    return file
}
