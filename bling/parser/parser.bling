package parser
import "bling/ast"
import "bling/scanner"
import "bling/token"
import "bytes"
import "io/ioutil"
import "os"
import "paths"
import "utils"
import "sys"

#pragma once

#include "io/ioutil/ioutil.h"

#include "bling/ast/ast.h"

#include "bling/scanner/scanner.h"

#include "bling/token/token.h"

fun parseFile(fset *token.FileSet, filename *const char) *ast.File

fun parseDir(fset *token.FileSet, path *const char, first **utils.Error) **ast.File

typedef Parser struct {
    file *token.File
    scanner scanner.Scanner
    pos token.Pos
    tok token.Token
    lit *char
    pkg_scope *ast.Scope
    c_mode bool
    pkgName *char
    exprLev int
}

fun declare(p *Parser, s *ast.Scope, decl *ast.Decl, kind ast.ObjKind, name *ast.Expr)

fun next(p *Parser)

fun init(p *Parser, fset *token.FileSet, filename *const char, src *char)

fun error(p *Parser, pos token.Pos, msg *char)

fun errorExpected(p *Parser, pos token.Pos, msg *char)

fun accept(p *Parser, tok token.Token) bool

fun expect(p *Parser, tok token.Token) token.Pos

fun parseBasicLit(p *Parser, kind token.Token) *ast.Expr

fun parseIdent(p *Parser) *ast.Expr

fun parseOperand(p *Parser) *ast.Expr

fun parsePragma(p *Parser) *ast.Decl

#include "bling/parser/parser.h"

#include "bytes/bytes.h"

#include "paths/paths.h"

#include "sys/sys.h"

fun isTypeName(x *ast.Expr) bool {
    switch x.kind {
    case ast.EXPR_IDENT: return true
    case ast.EXPR_SELECTOR: return x.selector.x.kind == ast.EXPR_IDENT
    default: return false
    }
}

fun isLiteralType(x *ast.Expr) bool {
    switch x.kind {
    case ast.EXPR_IDENT, ast.TYPE_ARRAY, ast.TYPE_STRUCT: return true
    case ast.EXPR_SELECTOR: return x.selector.x.kind == ast.EXPR_IDENT
    default: return false
    }
}

fun next(p *Parser) {
    p.tok = scanner.scan(&p.scanner, &p.pos, &p.lit)
}

fun init(p *Parser, fset *token.FileSet, filename *const char, src *char) {
    assert(fset)
    p.file = token.FileSet_addFile(fset, filename, -1, strlen(src))
    p.lit = NULL
    scanner.init(&p.scanner, p.file, src)
    p.scanner.dontInsertSemis = !bytes.hasSuffix(filename, ".bling")
    p.exprLev = 0
    next(p)
}

fun error(p *Parser, pos token.Pos, msg *char) {
    var position token.Position = token.File_position(p.file, pos)
    panic(sys.sprintf("%s: %s\n%s", token.Position_string(&position), msg, token.File_lineString(p.file, position.line)))
}

fun errorExpected(p *Parser, pos token.Pos, msg *char) {
    var buf bytes.Buffer = bytes.Buffer{}
    bytes.Buffer_write(&buf, "expected ", -1, NULL)
    bytes.Buffer_write(&buf, msg, -1, NULL)
    if pos == p.pos {
        if p.lit {
            bytes.Buffer_write(&buf, ", found ", -1, NULL)
            bytes.Buffer_write(&buf, p.lit, -1, NULL)
        } else {
            bytes.Buffer_write(&buf, ", found '", -1, NULL)
            bytes.Buffer_write(&buf, token.string(p.tok), -1, NULL)
            bytes.Buffer_writeByte(&buf, '\'', NULL)
        }
    }
    msg = bytes.Buffer_string(&buf)
    error(p, pos, msg)
    free(msg)
}

fun accept(p *Parser, tok0 token.Token) bool {
    if p.tok == tok0 {
        next(p)
        return true
    }
    return false
}

fun expect(p *Parser, tok token.Token) token.Pos {
    var pos token.Pos = p.pos
    if p.tok != tok {
        var lit *char = p.lit
        if lit == NULL {
            lit = token.string(p.tok)
        }
        errorExpected(p, pos, token.string(tok))
    }
    next(p)
    return pos
}

fun declare(p *Parser, s *ast.Scope, decl *ast.Decl, kind ast.ObjKind, name *ast.Expr) {
    assert(name.kind == ast.EXPR_IDENT)
    var obj *ast.Object = ast.newObject(kind, name.ident.name)
    obj.decl = decl
    obj.scope = s
    ast.Scope_insert(s, obj)
}

fun parseLiteralValue(p *Parser, type *ast.Expr) *ast.Expr

fun parseExpr(p *Parser) *ast.Expr

fun tryIdentOrType(p *Parser) *ast.Expr

fun tryType(p *Parser) *ast.Expr

fun parseType(p *Parser) *ast.Expr

fun parse_stmt(p *Parser) *ast.Stmt

fun parse_block_stmt(p *Parser) *ast.Stmt

fun parseDecl(p *Parser) *ast.Decl

fun parseBasicLit(p *Parser, kind token.Token) *ast.Expr {
    var value *char = p.lit
    p.lit = NULL
    var pos token.Pos = expect(p, kind)
    var x ast.Expr = ast.Expr{
        kind: ast.EXPR_BASIC_LIT,
        basic: ast.BasicLit{
            pos: pos,
            kind: kind,
            value: value,
        },
    }
    return esc(x)
}

fun parseIdent(p *Parser) *ast.Expr {
    var x ast.Expr = ast.Expr{
        kind: ast.EXPR_IDENT,
        ident: ast.Ident{
            pos: p.pos,
        },
    }
    if p.tok == token.IDENT {
        x.ident.name = p.lit
        p.lit = NULL
    }
    expect(p, token.IDENT)
    return esc(x)
}

fun parseOperand(p *Parser) *ast.Expr {
    switch p.tok {
    case token.IDENT: return parseIdent(p)
    case token.CHAR, token.FLOAT, token.INT, token.STRING: return parseBasicLit(p, p.tok)
    case token.LPAREN:
        if p.c_mode {
            error(p, p.pos, "unreachable")
        } else {
            var pos token.Pos = p.pos
            expect(p, token.LPAREN)
            p.exprLev++
            var x ast.Expr = ast.Expr{
                kind: ast.EXPR_PAREN,
                paren: ast.ParenExpr{
                    pos: pos,
                    x: parseExpr(p),
                },
            }
            p.exprLev--
            expect(p, token.RPAREN)
            return esc(x)
        }
    default: break
    }
    var t *ast.Expr = tryIdentOrType(p)
    if t {
        assert(t.kind != ast.EXPR_IDENT)
        return t
    }
    errorExpected(p, p.pos, "operand")
    return NULL
}

fun parseValue(p *Parser) *ast.Expr {
    if p.tok == token.LBRACE {
        return parseLiteralValue(p, NULL)
    }
    return parseExpr(p)
}

fun parseElement(p *Parser) *ast.Expr {
    var value *ast.Expr = parseValue(p)
    if value.kind == ast.EXPR_IDENT && accept(p, token.COLON) {
        var key *ast.Expr = value
        var x ast.Expr = ast.Expr{
            kind: ast.EXPR_KEY_VALUE,
            key_value: ast.KeyValue{
                key: key,
                value: parseValue(p),
            },
        }
        value = esc(x)
    }
    return value
}

fun parseElementList(p *Parser) **ast.Expr {
    var list utils.Slice = utils.Slice{
        size: sizeof(*ast.Expr),
    }
    while p.tok != token.RBRACE && p.tok != token.EOF {
        var value *ast.Expr = parseElement(p)
        utils.Slice_append(&list, &value)
        if !accept(p, token.COMMA) {
            break
        }
    }
    return utils.Slice_to_nil_array(list)
}

fun parseLiteralValue(p *Parser, type *ast.Expr) *ast.Expr {
    var pos token.Pos = expect(p, token.LBRACE)
    p.exprLev++
    var list **ast.Expr = parseElementList(p)
    p.exprLev--
    expect(p, token.RBRACE)
    var expr ast.Expr = ast.Expr{
        kind: ast.EXPR_COMPOSITE_LIT,
        composite: ast.CompositeLit{
            pos: pos,
            type: type,
            list: list,
        },
    }
    return esc(expr)
}

fun parseIndexExpr(p *Parser, x *ast.Expr) *ast.Expr {
    expect(p, token.LBRACK)
    p.exprLev++
    var y ast.Expr = ast.Expr{
        kind: ast.EXPR_INDEX,
        index: ast.IndexExpr{
            x: x,
            index: parseExpr(p),
        },
    }
    p.exprLev--
    expect(p, token.RBRACK)
    return esc(y)
}

fun parseCallExpr(p *Parser, x *ast.Expr) *ast.Expr {
    var args utils.Slice = utils.Slice{
        size: sizeof(*ast.Expr),
    }
    expect(p, token.LPAREN)
    p.exprLev++
    while p.tok != token.RPAREN {
        var x *ast.Expr = parseExpr(p)
        utils.Slice_append(&args, &x)
        if !accept(p, token.COMMA) {
            break
        }
    }
    p.exprLev--
    expect(p, token.RPAREN)
    var call ast.Expr = ast.Expr{
        kind: ast.EXPR_CALL,
        call: ast.CallExpr{
            func: x,
            args: utils.Slice_to_nil_array(args),
        },
    }
    return esc(call)
}

fun parsePrimaryExpr(p *Parser) *ast.Expr {
    var x *ast.Expr = parseOperand(p)
    for ;; {
        switch p.tok {
        case token.PERIOD:
            {
                var tok token.Token = p.tok
                next(p)
                var y ast.Expr = ast.Expr{
                    kind: ast.EXPR_SELECTOR,
                    selector: ast.SelectorExpr{
                        x: x,
                        tok: tok,
                        sel: parseIdent(p),
                    },
                }
                x = esc(y)
            }
            break
        case token.LBRACK:
            x = parseIndexExpr(p, x)
            break
        case token.LPAREN:
            x = parseCallExpr(p, x)
            break
        case token.LBRACE:
            if isLiteralType(x) && (p.exprLev >= 0 || !isTypeName(x)) {
                x = parseLiteralValue(p, x)
                break
            } else {
                return x
            }
        default: return x
        }
    }
}

fun parseUnaryExpr(p *Parser) *ast.Expr {
    switch p.tok {
    case token.ADD, token.AND, token.BITWISE_NOT, token.NOT, token.SUB: {
        var pos token.Pos = p.pos
        var op token.Token = p.tok
        next(p)
        var x ast.Expr = ast.Expr{
            kind: ast.EXPR_UNARY,
            unary: ast.UnaryExpr{
                pos: pos,
                op: op,
                x: parseUnaryExpr(p),
            },
        }
        return esc(x)
    }
    case token.MUL: {
        var pos token.Pos = p.pos
        next(p)
        var x ast.Expr = ast.Expr{
            kind: ast.EXPR_STAR,
            star: ast.StarExpr{
                pos: pos,
                x: parseUnaryExpr(p),
            },
        }
        return esc(x)
    }
    case token.SIZEOF: {
        var pos token.Pos = p.pos
        next(p)
        expect(p, token.LPAREN)
        var x ast.Expr = ast.Expr{
            kind: ast.EXPR_SIZEOF,
            sizeof_: ast.SizeofExpr{
                pos: pos,
                x: parseType(p),
            },
        }
        expect(p, token.RPAREN)
        return esc(x)
    }
    case token.LT: {
        var pos token.Pos = p.pos
        expect(p, token.LT)
        var type *ast.Expr = parseType(p)
        expect(p, token.GT)
        if p.tok == token.LBRACE {
            return parseLiteralValue(p, type)
        }
        var y ast.Expr = ast.Expr{
            kind: ast.EXPR_CAST,
            cast: ast.CastExpr{
                pos: pos,
                type: type,
                expr: parseUnaryExpr(p),
            },
        }
        return esc(y)
    }
    default: return parsePrimaryExpr(p)
    }
}

fun parseBinaryExpr(p *Parser, prec1 int) *ast.Expr {
    var x *ast.Expr = parseUnaryExpr(p)
    for ;; {
        var op token.Token = p.tok
        var oprec int = token.precedence(op)
        if oprec < prec1 {
            return x
        }
        expect(p, op)
        var y *ast.Expr = parseBinaryExpr(p, oprec + 1)
        var z ast.Expr = ast.Expr{
            kind: ast.EXPR_BINARY,
            binary: ast.BinaryExpr{
                x: x,
                op: op,
                y: y,
            },
        }
        x = esc(z)
    }
}

fun parseTernaryExpr(p *Parser) *ast.Expr {
    var x *ast.Expr = parseBinaryExpr(p, token.lowest_prec + 1)
    if accept(p, token.QUESTION_MARK) {
        var consequence *ast.Expr = parseExpr(p)
        expect(p, token.COLON)
        var alternative *ast.Expr = parseTernaryExpr(p)
        var y ast.Expr = ast.Expr{
            kind: ast.EXPR_TERNARY,
            ternary: ast.TernaryExpr{
                cond: x,
                x: consequence,
                y: alternative,
            },
        }
        x = esc(y)
    }
    return x
}

fun parseExpr(p *Parser) *ast.Expr {
    return parseTernaryExpr(p)
}

#pragma mark - types

fun parseTypeName(p *Parser) *ast.Expr {
    var x *ast.Expr = parseIdent(p)
    if accept(p, token.PERIOD) {
        var y ast.Expr = ast.Expr{
            kind: ast.EXPR_SELECTOR,
            selector: ast.SelectorExpr{
                x: x,
                tok: token.DOLLAR,
                sel: parseIdent(p),
            },
        }
        x = esc(y)
    }
    return x
}

fun parseArrayType(p *Parser) *ast.Expr {
    var pos token.Pos = expect(p, token.LBRACK)
    p.exprLev++
    var len *ast.Expr = NULL
    if p.tok != token.RBRACK {
        len = parseExpr(p)
    }
    p.exprLev--
    expect(p, token.RBRACK)
    var type ast.Expr = ast.Expr{
        kind: ast.TYPE_ARRAY,
        array: ast.Array{
            pos: pos,
            elt: parseType(p),
            len: len,
        },
    }
    return esc(type)
}

fun parseFieldDecl(p *Parser) *ast.Decl {
    var decl ast.Decl = ast.Decl{
        kind: ast.DECL_FIELD,
        pos: p.pos,
    }
    if p.tok == token.UNION {
        decl.field.type = parseType(p)
    } else {
        decl.field.name = parseIdent(p)
        if p.tok == token.SEMICOLON {
            decl.field.type = decl.field.name
            decl.field.name = NULL
        } else {
            decl.field.type = parseType(p)
        }
    }
    expect(p, token.SEMICOLON)
    return esc(decl)
}

fun parseStructOrUnionType(p *Parser, keyword token.Token) *ast.Expr {
    var pos token.Pos = p.pos
    expect(p, keyword)
    var name *ast.Expr = p.tok == token.IDENT ? parseIdent(p) : NULL
    var fields **ast.Decl = NULL
    if accept(p, token.LBRACE) {
        var fieldSlice utils.Slice = utils.Slice{
            size: sizeof(*ast.Decl),
        }
        for ;; {
            var field *ast.Decl = parseFieldDecl(p)
            utils.Slice_append(&fieldSlice, &field)
            if p.tok == token.RBRACE {
                break
            }
        }
        expect(p, token.RBRACE)
        fields = utils.Slice_to_nil_array(fieldSlice)
    }
    var x ast.Expr = ast.Expr{
        kind: ast.TYPE_STRUCT,
        struct_: ast.Struct{
            pos: pos,
            tok: keyword,
            name: name,
            fields: fields,
        },
    }
    return esc(x)
}

fun parsePointerType(p *Parser) *ast.Expr {
    var pos token.Pos = p.pos
    expect(p, token.MUL)
    var x ast.Expr = ast.Expr{
        kind: ast.EXPR_STAR,
        star: ast.StarExpr{
            pos: pos,
            x: parseType(p),
        },
    }
    return esc(x)
}

fun parseParam(p *Parser, anon bool) *ast.Decl {
    var decl ast.Decl = ast.Decl{
        kind: ast.DECL_FIELD,
        pos: p.pos,
    }
    if p.tok == token.IDENT {
        decl.field.name = parseIdent(p)
    }
    if decl.field.name != NULL && (p.tok == token.COMMA || p.tok == token.RPAREN) {
        decl.field.type = decl.field.name
        decl.field.name = NULL
    } else {
        decl.field.type = parseType(p)
    }
    return esc(decl)
}

fun parseParameterList(p *Parser, anon bool) **ast.Decl {
    var params utils.Slice = utils.Slice_init(sizeof(*ast.Decl))
    for ;; {
        var param *ast.Decl = parseParam(p, false)
        utils.Slice_append(&params, &param)
        if !accept(p, token.COMMA) {
            break
        }
        if p.tok == token.ELLIPSIS {
            var decl ast.Decl = ast.Decl{
                kind: ast.DECL_ELLIPSIS,
                pos: p.pos,
            }
            next(p)
            var param *ast.Decl = esc(decl)
            utils.Slice_append(&params, &param)
            break
        }
    }
    return utils.Slice_to_nil_array(params)
}

fun parseParameters(p *Parser, anon bool) **ast.Decl {
    var params **ast.Decl = NULL
    expect(p, token.LPAREN)
    if p.tok != token.RPAREN {
        params = parseParameterList(p, anon)
    }
    expect(p, token.RPAREN)
    return params
}

fun parseFuncType(p *Parser) *ast.Expr {
    var pos token.Pos = expect(p, token.FUNC)
    var params **ast.Decl = parseParameters(p, false)
    var result *ast.Expr = NULL
    if p.tok != token.SEMICOLON {
        result = parseType(p)
    }
    var type ast.Expr = ast.Expr{
        kind: ast.TYPE_FUNC,
        func: ast.FuncExpr{
            pos: pos,
            params: params,
            result: result,
        },
    }
    var ptr ast.Expr = ast.Expr{
        kind: ast.EXPR_STAR,
        star: ast.StarExpr{
            pos: pos,
            x: esc(type),
        },
    }
    return esc(ptr)
}

fun parseEnumType(p *Parser) *ast.Expr {
    var name *ast.Expr = NULL
    var pos token.Pos = p.pos
    expect(p, token.ENUM)
    if p.tok == token.IDENT {
        name = parseIdent(p)
    }
    var enums **ast.Decl = NULL
    if accept(p, token.LBRACE) {
        var list utils.Slice = utils.Slice{
            size: sizeof(*ast.Decl),
        }
        for ;; {
            var decl ast.Decl = ast.Decl{
                kind: ast.DECL_VALUE,
                pos: p.pos,
                value: ast.ValueDecl{
                    name: parseIdent(p),
                },
            }
            if accept(p, token.ASSIGN) {
                decl.value.value = parseExpr(p)
            }
            var enumerator *ast.Decl = esc(decl)
            utils.Slice_append(&list, &enumerator)
            if !accept(p, token.COMMA) || p.tok == token.RBRACE {
                break
            }
        }
        enums = utils.Slice_to_nil_array(list)
        expect(p, token.RBRACE)
    }
    var x ast.Expr = ast.Expr{
        kind: ast.TYPE_ENUM,
        enum_: ast.Enum{
            pos: pos,
            name: name,
            enums: enums,
        },
    }
    return esc(x)
}

fun parseQualifiedType(p *Parser, tok token.Token) *ast.Expr {
    expect(p, tok)
    var type *ast.Expr = parseType(p)
    type.is_const = true
    return type
}

fun tryIdentOrType(p *Parser) *ast.Expr {
    switch p.tok {
    case token.IDENT: return parseTypeName(p)
    case token.LBRACK: return parseArrayType(p)
    case token.STRUCT, token.UNION: return parseStructOrUnionType(p, p.tok)
    case token.MUL: return parsePointerType(p)
    case token.FUNC: return parseFuncType(p)
    case token.ENUM: return parseEnumType(p)
    case token.CONST: return parseQualifiedType(p, p.tok)
    default: return NULL
    }
}

fun tryType(p *Parser) *ast.Expr {
    return tryIdentOrType(p)
}

fun parseType(p *Parser) *ast.Expr {
    var t *ast.Expr = tryType(p)
    if t == NULL {
        errorExpected(p, p.pos, "type")
    }
    return t
}

fun parse_simple_stmt(p *Parser, labelOk bool) *ast.Stmt {
    var x *ast.Expr = parseExpr(p)
    var op token.Token = p.tok
    switch op {
    case token.ADD_ASSIGN, token.ASSIGN, token.DIV_ASSIGN, token.MOD_ASSIGN, token.MUL_ASSIGN, token.SHL_ASSIGN, token.SHR_ASSIGN, token.SUB_ASSIGN, token.XOR_ASSIGN: {
        next(p)
        var y *ast.Expr = parseExpr(p)
        var stmt ast.Stmt = ast.Stmt{
            kind: ast.STMT_ASSIGN,
            assign: ast.AssignStmt{
                x: x,
                op: op,
                y: y,
            },
        }
        return esc(stmt)
    }
    case token.INC, token.DEC: {
        next(p)
        var stmt ast.Stmt = ast.Stmt{
            kind: ast.STMT_POSTFIX,
            postfix: ast.PostfixStmt{
                x: x,
                op: op,
            },
        }
        return esc(stmt)
    }
    default: break
    }
    if labelOk && x.kind == ast.EXPR_IDENT {
        if accept(p, token.COLON) {
            var stmt ast.Stmt = ast.Stmt{
                kind: ast.STMT_LABEL,
                label: ast.LabelStmt{
                    label: x,
                    stmt: parse_stmt(p),
                },
            }
            return esc(stmt)
        }
    }
    var stmt ast.Stmt = ast.Stmt{
        kind: ast.STMT_EXPR,
        expr: ast.ExprStmt{
            x: x,
        },
    }
    return esc(stmt)
}

fun parse_for_stmt(p *Parser) *ast.Stmt {
    var pos token.Pos = expect(p, token.FOR)
    var prevLev int = p.exprLev
    p.exprLev = -1
    var init *ast.Stmt = NULL
    if !accept(p, token.SEMICOLON) {
        init = parse_stmt(p)
    }
    var cond *ast.Expr = NULL
    if p.tok != token.SEMICOLON {
        cond = parseExpr(p)
    }
    expect(p, token.SEMICOLON)
    var post *ast.Stmt = NULL
    if p.tok != token.LBRACE {
        post = parse_simple_stmt(p, false)
    }
    p.exprLev = prevLev
    var body *ast.Stmt = parse_block_stmt(p)
    var stmt ast.Stmt = ast.Stmt{
        kind: ast.STMT_ITER,
        iter: ast.IterStmt{
            pos: pos,
            kind: token.FOR,
            init: init,
            cond: cond,
            post: post,
            body: body,
        },
    }
    return esc(stmt)
}

fun parse_if_stmt(p *Parser) *ast.Stmt {
    var pos token.Pos = expect(p, token.IF)
    var outer int = p.exprLev
    p.exprLev = -1
    var cond *ast.Expr = parseExpr(p)
    p.exprLev = outer
    if p.tok != token.LBRACE {
        error(p, p.pos, "`if` must be followed by a compound_statement")
    }
    var body *ast.Stmt = parse_block_stmt(p)
    var else_ *ast.Stmt = NULL
    if accept(p, token.ELSE) {
        if p.tok == token.IF {
            else_ = parse_stmt(p)
        } else if p.tok == token.LBRACE {
            else_ = parse_block_stmt(p)
        } else {
            error(p, p.pos, "`else` must be followed by an if_statement or compound_statement")
        }
    }
    var stmt ast.Stmt = ast.Stmt{
        kind: ast.STMT_IF,
        if_: ast.IfStmt{
            pos: pos,
            cond: cond,
            body: body,
            else_: else_,
        },
    }
    return esc(stmt)
}

fun parse_return_stmt(p *Parser) *ast.Stmt {
    var pos token.Pos = expect(p, token.RETURN)
    var x *ast.Expr = NULL
    if p.tok != token.SEMICOLON {
        x = parseExpr(p)
    }
    expect(p, token.SEMICOLON)
    var stmt ast.Stmt = ast.Stmt{
        kind: ast.STMT_RETURN,
        return_: ast.ReturnStmt{
            pos: pos,
            x: x,
        },
    }
    return esc(stmt)
}

fun parse_switch_stmt(p *Parser) *ast.Stmt {
    var pos token.Pos = expect(p, token.SWITCH)
    var prevLev int = p.exprLev
    p.exprLev = -1
    var tag *ast.Expr = parseExpr(p)
    p.exprLev = prevLev
    expect(p, token.LBRACE)
    var clauses utils.Slice = utils.Slice{
        size: sizeof(*ast.Stmt),
    }
    while p.tok == token.CASE || p.tok == token.DEFAULT {
        var exprs utils.Slice = utils.Slice{
            size: sizeof(*ast.Expr),
        }
        var pos token.Pos = p.pos
        if accept(p, token.CASE) {
            for ;; {
                var expr *ast.Expr = parseExpr(p)
                utils.Slice_append(&exprs, &expr)
                if !accept(p, token.COMMA) {
                    break
                }
            }
        } else {
            expect(p, token.DEFAULT)
        }
        expect(p, token.COLON)
        var stmts utils.Slice = utils.Slice{
            size: sizeof(*ast.Stmt),
        }
        var loop bool = true
        while loop {
            switch p.tok {
            case token.CASE, token.DEFAULT, token.RBRACE:
                loop = false
                break
            default: break
            }
            if loop {
                var stmt *ast.Stmt = parse_stmt(p)
                utils.Slice_append(&stmts, &stmt)
            }
        }
        var stmt ast.Stmt = ast.Stmt{
            kind: ast.STMT_CASE,
            case_: ast.CaseStmt{
                pos: pos,
                exprs: utils.Slice_to_nil_array(exprs),
                stmts: utils.Slice_to_nil_array(stmts),
            },
        }
        var clause *ast.Stmt = esc(stmt)
        utils.Slice_append(&clauses, &clause)
    }
    expect(p, token.RBRACE)
    accept(p, token.SEMICOLON)
    var stmt ast.Stmt = ast.Stmt{
        kind: ast.STMT_SWITCH,
        switch_: ast.SwitchStmt{
            pos: pos,
            tag: tag,
            stmts: utils.Slice_to_nil_array(clauses),
        },
    }
    return esc(stmt)
}

fun parse_while_stmt(p *Parser) *ast.Stmt {
    var pos token.Pos = expect(p, token.WHILE)
    var prevLev int = p.exprLev
    p.exprLev = -1
    var cond *ast.Expr = parseExpr(p)
    p.exprLev = prevLev
    var body *ast.Stmt = parse_block_stmt(p)
    var stmt ast.Stmt = ast.Stmt{
        kind: ast.STMT_ITER,
        iter: ast.IterStmt{
            pos: pos,
            kind: token.WHILE,
            cond: cond,
            body: body,
        },
    }
    return esc(stmt)
}

fun parse_jump_stmt(p *Parser, keyword token.Token) *ast.Stmt {
    var pos token.Pos = expect(p, keyword)
    var label *ast.Expr = NULL
    if keyword == token.GOTO {
        label = parseIdent(p)
    }
    expect(p, token.SEMICOLON)
    var stmt ast.Stmt = ast.Stmt{
        kind: ast.STMT_JUMP,
        jump: ast.JumpStmt{
            pos: pos,
            keyword: keyword,
            label: label,
        },
    }
    return esc(stmt)
}

fun parse_decl_stmt(p *Parser) *ast.Stmt {
    var stmt ast.Stmt = ast.Stmt{
        kind: ast.STMT_DECL,
        decl: ast.DeclStmt{
            decl: parseDecl(p),
        },
    }
    return esc(stmt)
}

fun parse_stmt(p *Parser) *ast.Stmt {
    switch p.tok {
    case token.VAR: return parse_decl_stmt(p)
    case token.FOR: return parse_for_stmt(p)
    case token.IF: return parse_if_stmt(p)
    case token.RETURN: return parse_return_stmt(p)
    case token.SWITCH: return parse_switch_stmt(p)
    case token.WHILE: return parse_while_stmt(p)
    case token.BREAK, token.CONTINUE, token.GOTO: return parse_jump_stmt(p, p.tok)
    case token.LBRACE: return parse_block_stmt(p)
    default: break
    }
    var pos token.Pos = p.pos
    if accept(p, token.SEMICOLON) {
        var stmt ast.Stmt = ast.Stmt{
            kind: ast.STMT_EMPTY,
            empty: ast.EmptyStmt{
                pos: pos,
            },
        }
        return esc(stmt)
    }
    var stmt *ast.Stmt = parse_simple_stmt(p, true)
    if stmt.kind != ast.STMT_LABEL {
        expect(p, token.SEMICOLON)
    }
    return stmt
}

fun parse_block_stmt(p *Parser) *ast.Stmt {
    var stmts utils.Slice = utils.Slice{
        size: sizeof(*ast.Stmt),
    }
    var pos token.Pos = expect(p, token.LBRACE)
    while p.tok != token.RBRACE {
        var stmt *ast.Stmt = parse_stmt(p)
        utils.Slice_append(&stmts, &stmt)
    }
    expect(p, token.RBRACE)
    accept(p, token.SEMICOLON)
    var stmt ast.Stmt = ast.Stmt{
        kind: ast.STMT_BLOCK,
        block: ast.BlockStmt{
            pos: pos,
            stmts: utils.Slice_to_nil_array(stmts),
        },
    }
    return esc(stmt)
}

fun parsePragma(p *Parser) *ast.Decl {
    var pos token.Pos = p.pos
    var lit *char = p.lit
    p.lit = NULL
    expect(p, token.HASH)
    var decl ast.Decl = ast.Decl{
        kind: ast.DECL_PRAGMA,
        pos: pos,
        pragma: ast.PragmaDecl{
            lit: lit,
        },
    }
    return esc(decl)
}

fun parseDecl(p *Parser) *ast.Decl {
    switch p.tok {
    case token.HASH: return parsePragma(p)
    case token.TYPEDEF: {
        var keyword token.Token = p.tok
        var pos token.Pos = expect(p, keyword)
        var ident *ast.Expr = parseIdent(p)
        var type *ast.Expr = parseType(p)
        expect(p, token.SEMICOLON)
        var decl ast.Decl = ast.Decl{
            kind: ast.DECL_TYPEDEF,
            pos: pos,
            typedef_: ast.TypeDecl{
                name: ident,
                type: type,
            },
        }
        return esc(decl)
    }
    case token.CONST, token.VAR: {
        var keyword token.Token = p.tok
        var pos token.Pos = expect(p, keyword)
        var ident *ast.Expr = parseIdent(p)
        var type *ast.Expr = NULL
        if p.tok != token.ASSIGN {
            type = parseType(p)
        }
        var value *ast.Expr = NULL
        if accept(p, token.ASSIGN) {
            value = parseValue(p)
        }
        expect(p, token.SEMICOLON)
        var decl ast.Decl = ast.Decl{
            kind: ast.DECL_VALUE,
            pos: pos,
            value: ast.ValueDecl{
                name: ident,
                type: type,
                value: value,
                kind: keyword,
            },
        }
        return esc(decl)
    }
    case token.FUNC: {
        var pos token.Pos = expect(p, token.FUNC)
        var decl ast.Decl = ast.Decl{
            kind: ast.DECL_FUNC,
            pos: pos,
            func: ast.FuncDecl{
                name: parseIdent(p),
            },
        }
        var type ast.Expr = ast.Expr{
            kind: ast.TYPE_FUNC,
            func: ast.FuncExpr{
                pos: pos,
                params: parseParameters(p, false),
            },
        }
        if p.tok != token.LBRACE && p.tok != token.SEMICOLON {
            type.func.result = parseType(p)
        }
        decl.func.type = esc(type)
        if p.tok == token.LBRACE {
            decl.func.body = parse_block_stmt(p)
        } else {
            expect(p, token.SEMICOLON)
        }
        return esc(decl)
    }
    default:
        error(p, p.pos, sys.sprintf("cant handle it: %s", token.string(p.tok)))
        return NULL
    }
}

fun isBlingFile(name *const char) bool {
    return bytes.hasSuffix(name, ".bling")
}

fun isTestFile(name *const char) bool {
    return paths.match("*_test.bling", name)
}

fun parseDir(fset *token.FileSet, path *const char, first **utils.Error) **ast.File {
    var err *utils.Error = NULL
    var infos **os.FileInfo = ioutil.readDir(path, &err)
    if err {
        utils.Error_move(err, first)
        return NULL
    }
    var files utils.Slice = utils.Slice_init(sizeof(uintptr_t))
    while *infos != NULL {
        var name *char = os.FileInfo_name(**infos)
        if isBlingFile(name) && !isTestFile(name) {
            var file *ast.File = parseFile(fset, name)
            utils.Slice_append(&files, &file)
        }
        infos++
    }
    return utils.Slice_to_nil_array(files)
}

fun _parse_file(p *Parser) *ast.File {
    var name *ast.Expr = NULL
    var imports utils.Slice = utils.Slice_init(sizeof(uintptr_t))
    var decls utils.Slice = utils.Slice_init(sizeof(*ast.Decl))
    while p.tok == token.HASH {
        var lit *ast.Decl = parsePragma(p)
        utils.Slice_append(&decls, &lit)
    }
    if accept(p, token.PACKAGE) {
        name = parseIdent(p)
        expect(p, token.SEMICOLON)
    }
    while p.tok == token.IMPORT {
        var pos token.Pos = expect(p, token.IMPORT)
        var path *ast.Expr = parseBasicLit(p, token.STRING)
        expect(p, token.SEMICOLON)
        var decl ast.Decl = ast.Decl{
            kind: ast.DECL_IMPORT,
            pos: pos,
            imp: ast.ImportDecl{
                path: path,
            },
        }
        var declp *ast.Decl = esc(decl)
        utils.Slice_append(&imports, &declp)
    }
    while p.tok != token.EOF {
        var decl *ast.Decl = parseDecl(p)
        utils.Slice_append(&decls, &decl)
    }
    var file ast.File = ast.File{
        filename: p.file.name,
        name: name,
        imports: utils.Slice_to_nil_array(imports),
        decls: utils.Slice_to_nil_array(decls),
    }
    return esc(file)
}

fun parseFile(fset *token.FileSet, filename *const char) *ast.File {
    var err *utils.Error = NULL
    var src *char = ioutil.readFile(filename, &err)
    if err {
        panic("%s: %s", filename, err.error)
    }
    var p Parser = Parser{}
    init(&p, fset, filename, src)
    var file *ast.File = _parse_file(&p)
    free(src)
    return file
}
