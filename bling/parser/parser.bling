package parser

import "C"
import "bling/ast"
import "bling/scanner"
import "bling/token"
import "bytes"
import "io/ioutil"
import "os"
import "paths"
import "runtime"

typ Parser struct {
    file *token.File
    scanner scanner.Scanner
    pos token.Pos
    tok token.Token
    lit runtime.charptr
    c_mode bool
    exprLev int
    numIdents int
    typeNames map *ast.Expr
}

fun isTypeName(x *ast.Expr) bool {
    switch x.kind {
    case ast.EXPR_IDENT:
        return true
    case ast.EXPR_SELECTOR:
        return x.selector.x.kind == ast.EXPR_IDENT
    default:
        return false
    }
}

fun isLiteralType(x *ast.Expr) bool {
    switch x.kind {
    case ast.EXPR_IDENT, ast.TYPE_ARRAY, ast.TYPE_STRUCT:
        return true
    case ast.EXPR_SELECTOR:
        return x.selector.x.kind == ast.EXPR_IDENT
    default:
        return false
    }
}

fun unparen(x *ast.Expr) *ast.Expr {
    while x.kind == ast.EXPR_PAREN {
        x = x.paren.x
    }
    return x
}

fun next(p *Parser) {
    p.tok = scanner.scan(&p.scanner, &p.pos, &p.lit)
}

fun init(p *Parser, fset *token.FileSet, filename runtime.charstr, src runtime.charptr) {
    assert(fset)
    p.file = fset.addFile(filename, -1, runtime.strlen(src))
    p.lit = nil
    scanner.init(&p.scanner, p.file, src)
    p.scanner.dontInsertSemis = !bytes.hasSuffix(filename, ".bling")
    p.exprLev = 0
    p.typeNames = makemap(*ast.Expr)
    next(p)
}

fun error(p *Parser, pos token.Pos, msg runtime.charptr) {
    var position = p.file.position(pos)
    panic(C.sprintf("%s: %s\n%s", position.string(), msg, p.file.lineString(position.line)))
}

fun errorExpected(p *Parser, pos token.Pos, msg runtime.charptr) {
    var buf = bytes.Buffer{}
    buf.write("expected ", -1, nil)
    buf.write(msg, -1, nil)
    if pos == p.pos {
        if p.lit {
            buf.write(", found ", -1, nil)
            buf.write(p.lit, -1, nil)
        } else {
            buf.write(", found '", -1, nil)
            buf.write(p.tok.string(), -1, nil)
            buf.writeByte('\'', nil)
        }
    }
    msg = buf.toString()
    error(p, pos, msg)
    runtime.free(msg)
}

fun accept(p *Parser, tok0 token.Token) bool {
    if p.tok == tok0 {
        next(p)
        return true
    }
    return false
}

fun expect(p *Parser, tok token.Token) token.Pos {
    var pos = p.pos
    if p.tok != tok {
        var lit = p.lit
        if lit == nil {
            lit = p.tok.string()
        }
        errorExpected(p, pos, tok.string())
    }
    next(p)
    return pos
}

fun checkExpr(p *Parser, x *ast.Expr) *ast.Expr {
    switch unparen(x).kind {
    case ast.EXPR_IDENT, ast.EXPR_BASIC_LIT, ast.EXPR_BINARY, ast.EXPR_CALL, ast.EXPR_CAST, ast.EXPR_COMPOSITE_LIT, ast.EXPR_INDEX, ast.EXPR_SELECTOR, ast.EXPR_SIZEOF, ast.EXPR_STAR, ast.EXPR_TERNARY, ast.EXPR_UNARY:
        break
    case ast.EXPR_PAREN:
        panic("unreachable")
        break
    default:
        errorExpected(p, x.pos(), "expression")
        break
    }
    return x
}

fun checkExprOrType(p *Parser, x *ast.Expr) *ast.Expr {
    return x
}

fun parseRhs(p *Parser) *ast.Expr {
    return checkExpr(p, parseExpr(p))
}

fun parseRhsOrType(p *Parser) *ast.Expr {
    return checkExprOrType(p, parseExpr(p))
}

fun parseBasicLit(p *Parser, kind token.Token) *ast.Expr {
    var value = p.lit
    p.lit = nil
    var pos = expect(p, kind)
    var x = ast.Expr{
        kind: ast.EXPR_BASIC_LIT,
        basic: {
            pos: pos,
            kind: kind,
            value: value,
        },
    }
    return &&x
}

fun parseIdent(p *Parser) *ast.Expr {
    var x = ast.Expr{
        kind: ast.EXPR_IDENT,
        ident: {
            pos: p.pos,
        },
    }
    if p.tok == token.IDENT {
        x.ident.name = p.lit
        p.lit = nil
    }
    expect(p, token.IDENT)
    p.numIdents++
    return &&x
}

fun parseOperand(p *Parser) *ast.Expr {
    switch p.tok {
    case token.IDENT:
        return parseIdent(p)
    case token.CHAR, token.FLOAT, token.INT, token.STRING:
        return parseBasicLit(p, p.tok)
    case token.LPAREN:
        if p.c_mode {
            error(p, p.pos, "unreachable")
        } else {
            var pos = p.pos
            expect(p, token.LPAREN)
            p.exprLev++
            var x = ast.Expr{
                kind: ast.EXPR_PAREN,
                paren: {
                    pos: pos,
                    x: parseRhsOrType(p),
                },
            }
            p.exprLev--
            expect(p, token.RPAREN)
            return &&x
        }
    default:
        break
    }
    if !p.c_mode {
        if var t = tryType(p); t != nil {
            return t
        }
    }
    errorExpected(p, p.pos, "operand")
    return nil
}

fun parseValue(p *Parser) *ast.Expr {
    if p.tok == token.LBRACE {
        return parseLiteralValue(p, nil)
    }
    return checkExpr(p, parseExpr(p))
}

fun parseElement(p *Parser) *ast.Expr {
    var value = parseValue(p)
    if value.kind == ast.EXPR_IDENT && accept(p, token.COLON) {
        var key = value
        var x = ast.Expr{
            kind: ast.EXPR_KEY_VALUE,
            key_value: {
                key: key,
                value: parseValue(p),
            },
        }
        value = &&x
    }
    return value
}

fun parseElementList(p *Parser) []*ast.Expr {
    var list = makearray(*ast.Expr)
    while p.tok != token.RBRACE && p.tok != token.EOF {
        var value = parseElement(p)
        append(list, value)
        if !accept(p, token.COMMA) {
            break
        }
    }
    return list
}

fun parseLiteralValue(p *Parser, type *ast.Expr) *ast.Expr {
    var pos = expect(p, token.LBRACE)
    if type {
        pos = type.pos()
    }
    p.exprLev++
    var list = parseElementList(p)
    p.exprLev--
    expect(p, token.RBRACE)
    var expr = ast.Expr{
        kind: ast.EXPR_COMPOSITE_LIT,
        composite: {
            pos: pos,
            type: type,
            list: list,
        },
    }
    return &&expr
}

fun parseIndexExpr(p *Parser, x *ast.Expr) *ast.Expr {
    expect(p, token.LBRACK)
    p.exprLev++
    var y = ast.Expr{
        kind: ast.EXPR_INDEX,
        index: {
            x: x,
            index: parseRhs(p),
        },
    }
    p.exprLev--
    expect(p, token.RBRACK)
    return &&y
}

fun parseCallExpr(p *Parser, x *ast.Expr) *ast.Expr {
    var args = makearray(*ast.Expr)
    expect(p, token.LPAREN)
    p.exprLev++
    while p.tok != token.RPAREN {
        var x = parseRhsOrType(p)
        append(args, x)
        if !accept(p, token.COMMA) {
            break
        }
    }
    p.exprLev--
    expect(p, token.RPAREN)
    var call = ast.Expr{
        kind: ast.EXPR_CALL,
        call: {
            func: x,
            args: args,
        },
    }
    return &&call
}

fun parseSelector(p *Parser, x *ast.Expr) *ast.Expr {
    var y = ast.Expr{
        kind: ast.EXPR_SELECTOR,
        selector: {
            x: x,
            tok: token.PERIOD,
            sel: parseIdent(p),
        },
    }
    return &&y
}

fun parsePrimaryExpr(p *Parser) *ast.Expr {
    for var x = parseOperand(p);; {
        switch p.tok {
        case token.PERIOD:
            next(p)
            x = parseSelector(p, checkExprOrType(p, x))
            break
        case token.LBRACK:
            x = parseIndexExpr(p, checkExpr(p, x))
            break
        case token.LPAREN:
            x = parseCallExpr(p, checkExprOrType(p, x))
            break
        case token.LBRACE:
            if isLiteralType(x) && (p.exprLev >= 0 || !isTypeName(x)) {
                x = parseLiteralValue(p, x)
                break
            } else {
                return x
            }
        default:
            return x
        }
    }
}

fun parseUnaryExpr(p *Parser) *ast.Expr {
    switch p.tok {
    case token.ADD, token.AND, token.BITWISE_NOT, token.LAND, token.NOT, token.SUB:
        {
            var pos = p.pos
            var op = p.tok
            next(p)
            var x = ast.Expr{
                kind: ast.EXPR_UNARY,
                unary: {
                    pos: pos,
                    op: op,
                    x: checkExpr(p, parseUnaryExpr(p)),
                },
            }
            return &&x
        }
    case token.MUL:
        {
            var pos = p.pos
            next(p)
            var x = ast.Expr{
                kind: ast.EXPR_STAR,
                star: {
                    pos: pos,
                    x: checkExprOrType(p, parseUnaryExpr(p)),
                },
            }
            return &&x
        }
    case token.SIZEOF:
        {
            var pos = p.pos
            next(p)
            expect(p, token.LPAREN)
            var x = ast.Expr{
                kind: ast.EXPR_SIZEOF,
                sizeof_: {
                    pos: pos,
                    x: parseType(p),
                },
            }
            expect(p, token.RPAREN)
            return &&x
        }
    case token.TYPE:
        {
            var pos = p.pos
            expect(p, token.TYPE)
            var type = parseType(p)
            if p.tok == token.LBRACE {
                return parseLiteralValue(p, type)
            }
            var y = ast.Expr{
                kind: ast.EXPR_CAST,
                cast: {
                    pos: pos,
                    type: type,
                    expr: parseUnaryExpr(p),
                },
            }
            return &&y
        }
    default:
        return parsePrimaryExpr(p)
    }
}

fun parseBinaryExpr(p *Parser, prec1 int) *ast.Expr {
    var x = parseUnaryExpr(p)
    for ;; {
        var op = p.tok
        var oprec = op.precedence()
        if oprec < prec1 {
            return x
        }
        expect(p, op)
        var y = parseBinaryExpr(p, oprec + 1)
        var z = ast.Expr{
            kind: ast.EXPR_BINARY,
            binary: {
                x: checkExpr(p, x),
                op: op,
                y: checkExpr(p, y),
            },
        }
        x = &&z
    }
}

fun parseTernaryExpr(p *Parser) *ast.Expr {
    var x = parseBinaryExpr(p, token.lowest_prec + 1)
    if accept(p, token.QUESTION_MARK) {
        var consequence *ast.Expr = nil
        if p.tok != token.COLON {
            consequence = parseExpr(p)
        }
        expect(p, token.COLON)
        var alternative = parseTernaryExpr(p)
        var y = ast.Expr{
            kind: ast.EXPR_TERNARY,
            ternary: {
                cond: x,
                x: consequence,
                y: alternative,
            },
        }
        x = &&y
    }
    return x
}

fun parseExpr(p *Parser) *ast.Expr {
    return parseTernaryExpr(p)
}

fun parseTypeName(p *Parser) *ast.Expr {
    var x = parseIdent(p)
    if accept(p, token.PERIOD) {
        var y = ast.Expr{
            kind: ast.EXPR_SELECTOR,
            selector: {
                x: x,
                tok: token.DOLLAR,
                sel: parseIdent(p),
            },
        }
        x = &&y
    }
    return x
}

fun parseArrayType(p *Parser) *ast.Expr {
    var pos = p.pos
    expect(p, token.LBRACK)
    var len *ast.Expr = nil
    var dynamic = false
    if p.tok != token.RBRACK {
        if !accept(p, token.QUESTION_MARK) {
            p.exprLev++
            len = parseRhs(p)
            p.exprLev--
        }
    } else {
        dynamic = true
    }
    expect(p, token.RBRACK)
    var type = ast.Expr{
        kind: ast.TYPE_ARRAY,
        array_: {
            pos: pos,
            elt: parseType(p),
            len: len,
            dynamic: dynamic,
        },
    }
    return &&type
    return nil
}

fun parseFieldDecl(p *Parser) *ast.Decl {
    var decl = ast.Decl{
        kind: ast.DECL_FIELD,
        pos: p.pos,
    }
    if p.tok == token.UNION {
        decl.field.type = parseType(p)
    } else {
        decl.field.name = parseIdent(p)
        if p.tok == token.SEMICOLON {
            decl.field.type = decl.field.name
            decl.field.name = nil
        } else {
            decl.field.type = parseType(p)
        }
    }
    var d = &&decl
    expect(p, token.SEMICOLON)
    return d
}

fun parseStructOrUnionType(p *Parser, keyword token.Token) *ast.Expr {
    var pos = p.pos
    expect(p, keyword)
    var fields = makearray(*ast.Decl)
    if accept(p, token.LBRACE) {
        for ;; {
            var field = parseFieldDecl(p)
            append(fields, field)
            if p.tok == token.RBRACE {
                break
            }
        }
        expect(p, token.RBRACE)
    }
    var x = ast.Expr{
        kind: ast.TYPE_STRUCT,
        struct_: {
            pos: pos,
            tok: keyword,
            fields: fields,
        },
    }
    return &&x
}

fun parsePointerType(p *Parser) *ast.Expr {
    var pos = p.pos
    expect(p, token.MUL)
    var x = ast.Expr{
        kind: ast.EXPR_STAR,
        star: {
            pos: pos,
            x: parseType(p),
        },
    }
    return &&x
}

fun parseParam(p *Parser, anon bool) *ast.Decl {
    var decl = ast.Decl{
        kind: ast.DECL_FIELD,
        pos: p.pos,
    }
    if p.tok == token.IDENT {
        decl.field.name = parseIdent(p)
    }
    if decl.field.name != nil && (p.tok == token.COMMA || p.tok == token.RPAREN) {
        decl.field.type = decl.field.name
        decl.field.name = nil
    } else {
        decl.field.type = parseType(p)
    }
    var d = &&decl
    return d
}

fun parseParameterList(p *Parser, anon bool) []*ast.Decl {
    var params = makearray(*ast.Decl)
    for ;; {
        var param = parseParam(p, false)
        append(params, param)
        if !accept(p, token.COMMA) {
            break
        }
        if p.tok == token.ELLIPSIS {
            var pos = expect(p, token.ELLIPSIS)
            var type = ast.Expr{
                kind: ast.TYPE_ELLIPSIS,
                ellipsis: {
                    pos: pos,
                },
            }
            var decl = ast.Decl{
                kind: ast.DECL_FIELD,
                pos: pos,
                field: {
                    type: &&type,
                },
            }
            var param = &&decl
            append(params, param)
            break
        }
    }
    return params
}

fun parseParameters(p *Parser, anon bool) []*ast.Decl {
    var params = makearray(*ast.Decl)
    expect(p, token.LPAREN)
    if p.tok != token.RPAREN {
        params = parseParameterList(p, anon)
    }
    expect(p, token.RPAREN)
    return params
}

fun parseFuncType(p *Parser) *ast.Expr {
    var pos = expect(p, token.FUNC)
    var params = parseParameters(p, false)
    var result *ast.Expr = nil
    if p.tok != token.SEMICOLON {
        result = parseType(p)
    }
    var type = ast.Expr{
        kind: ast.TYPE_FUNC,
        func: {
            pos: pos,
            params: params,
            result: result,
        },
    }
    var ptr = ast.Expr{
        kind: ast.EXPR_STAR,
        star: {
            pos: pos,
            x: &&type,
        },
    }
    return &&ptr
}

fun parseMapType(p *Parser) *ast.Expr {
    var pos = p.pos
    expect(p, token.MAP)
    var tmp = ast.Expr{
        kind: ast.TYPE_MAP,
        map_: {
            pos: pos,
            val: parseType(p),
        },
    }
    return &&tmp
}

fun parseEnumType(p *Parser) *ast.Expr {
    var pos = p.pos
    expect(p, token.ENUM)
    var enums = makearray(*ast.Decl)
    if accept(p, token.LBRACE) {
        while p.tok != token.RBRACE {
            var decl = ast.Decl{
                kind: ast.DECL_VALUE,
                pos: p.pos,
                value: {
                    name: parseIdent(p),
                },
            }
            if accept(p, token.ASSIGN) {
                decl.value.value = parseRhs(p)
            }
            var enumerator = &&decl
            append(enums, enumerator)
            expect(p, token.SEMICOLON)
        }
        expect(p, token.RBRACE)
    }
    var x = ast.Expr{
        kind: ast.TYPE_ENUM,
        enum_: {
            pos: pos,
            enums: enums,
        },
    }
    return &&x
}

fun parseQualifiedType(p *Parser, tok token.Token) *ast.Expr {
    expect(p, tok)
    var type *ast.Expr = parseType(p) // XXX
    type.is_const = true
    return type
}

fun tryType(p *Parser) *ast.Expr {
    switch p.tok {
    case token.IDENT:
        return parseTypeName(p)
    case token.LBRACK:
        return parseArrayType(p)
    case token.STRUCT, token.UNION:
        return parseStructOrUnionType(p, p.tok)
    case token.MUL:
        return parsePointerType(p)
    case token.FUNC:
        return parseFuncType(p)
    case token.MAP:
        return parseMapType(p)
    case token.ENUM:
        return parseEnumType(p)
    case token.CONST:
        return parseQualifiedType(p, p.tok)
    default:
        return nil
    }
}

fun parseType(p *Parser) *ast.Expr {
    var t = tryType(p)
    if t == nil {
        errorExpected(p, p.pos, "type")
    }
    return t
}

fun parseSimpleStmt(p *Parser, labelOk bool) *ast.Stmt {
    var x = parseExpr(p)
    var op = p.tok
    switch op {
    case token.ADD_ASSIGN, token.ASSIGN, token.DIV_ASSIGN, token.MOD_ASSIGN, token.MUL_ASSIGN, token.SHL_ASSIGN, token.SHR_ASSIGN, token.SUB_ASSIGN, token.XOR_ASSIGN:
        {
            next(p)
            var y = parseRhs(p)
            var stmt = ast.Stmt{
                kind: ast.STMT_ASSIGN,
                assign: {
                    x: x,
                    op: op,
                    y: y,
                },
            }
            return &&stmt
        }
    case token.INC, token.DEC:
        {
            next(p)
            var stmt = ast.Stmt{
                kind: ast.STMT_POSTFIX,
                postfix: {
                    x: x,
                    op: op,
                },
            }
            return &&stmt
        }
    default:
        break
    }
    if labelOk && x.kind == ast.EXPR_IDENT {
        if accept(p, token.COLON) {
            var stmt = ast.Stmt{
                kind: ast.STMT_LABEL,
                label: {
                    label: x,
                    stmt: parseStmt(p),
                },
            }
            return &&stmt
        }
    }
    var stmt = ast.Stmt{
        kind: ast.STMT_EXPR,
        expr: {
            x: x,
        },
    }
    return &&stmt
}

fun parseForStmt(p *Parser) *ast.Stmt {
    var pos = expect(p, token.FOR)
    var prevLev = p.exprLev
    p.exprLev = -1
    var init *ast.Stmt = nil
    if !accept(p, token.SEMICOLON) {
        switch p.tok {
        case token.VAR:
            init = parseStmt(p)
            break
        default:
            init = parseSimpleStmt(p, false)
            break
        }
    }
    var cond *ast.Expr = nil
    if p.tok != token.SEMICOLON {
        cond = parseRhs(p)
    }
    expect(p, token.SEMICOLON)
    var post *ast.Stmt = nil
    if p.tok != token.LBRACE {
        post = parseSimpleStmt(p, false)
    }
    p.exprLev = prevLev
    var body = parseBlockStmt(p)
    var stmt = ast.Stmt{
        kind: ast.STMT_ITER,
        iter: {
            pos: pos,
            kind: token.FOR,
            init: init,
            cond: cond,
            post: post,
            body: body,
        },
    }
    return &&stmt
}

fun tryInitStmt(p *Parser) *ast.Stmt {
    switch p.tok {
    case token.VAR:
        return parseDeclStmt(p)
    default:
        return nil
    }
}

fun parseIfStmt(p *Parser) *ast.Stmt {
    var pos = expect(p, token.IF)
    var outer = p.exprLev
    p.exprLev = -1
    var init = tryInitStmt(p)
    var cond = parseExpr(p)
    p.exprLev = outer
    if p.tok != token.LBRACE {
        error(p, p.pos, "`if` must be followed by a compound_statement")
    }
    var body = parseBlockStmt(p)
    var else_ *ast.Stmt = nil
    if accept(p, token.ELSE) {
        if p.tok == token.IF {
            else_ = parseStmt(p)
        } else if p.tok == token.LBRACE {
            else_ = parseBlockStmt(p)
        } else {
            error(p, p.pos, "`else` must be followed by an if_statement or compound_statement")
        }
    }
    var stmt = ast.Stmt{
        kind: ast.STMT_IF,
        if_: {
            pos: pos,
            init: init,
            cond: cond,
            body: body,
            else_: else_,
        },
    }
    return &&stmt
}

fun parseReturnStmt(p *Parser) *ast.Stmt {
    var pos = expect(p, token.RETURN)
    var x *ast.Expr = nil
    if p.tok != token.SEMICOLON {
        x = parseRhs(p)
    }
    expect(p, token.SEMICOLON)
    var stmt = ast.Stmt{
        kind: ast.STMT_RETURN,
        return_: {
            pos: pos,
            x: x,
        },
    }
    return &&stmt
}

fun parseSwitchStmt(p *Parser) *ast.Stmt {
    var pos = expect(p, token.SWITCH)
    var prevLev = p.exprLev
    p.exprLev = -1
    var tag = parseExpr(p)
    p.exprLev = prevLev
    expect(p, token.LBRACE)
    var clauses = makearray(*ast.Stmt)
    while p.tok == token.CASE || p.tok == token.DEFAULT {
        var exprs = makearray(*ast.Expr)
        var pos = p.pos
        if accept(p, token.CASE) {
            for ;; {
                var expr = parseRhs(p)
                append(exprs, expr)
                if !accept(p, token.COMMA) {
                    break
                }
            }
        } else {
            expect(p, token.DEFAULT)
        }
        expect(p, token.COLON)
        var stmts = makearray(*ast.Stmt)
        var loop = true
        while loop {
            switch p.tok {
            case token.CASE, token.DEFAULT, token.RBRACE:
                loop = false
                break
            default:
                break
            }
            if loop {
                var stmt = parseStmt(p)
                append(stmts, stmt)
            }
        }
        var stmt = ast.Stmt{
            kind: ast.STMT_CASE,
            case_: {
                pos: pos,
                exprs: exprs,
                stmts: stmts,
            },
        }
        var clause = &&stmt
        append(clauses, clause)
    }
    expect(p, token.RBRACE)
    accept(p, token.SEMICOLON)
    var stmt = ast.Stmt{
        kind: ast.STMT_SWITCH,
        switch_: {
            pos: pos,
            tag: tag,
            stmts: clauses,
        },
    }
    return &&stmt
}

fun parseWhileStmt(p *Parser) *ast.Stmt {
    var pos = expect(p, token.WHILE)
    var prevLev = p.exprLev
    p.exprLev = -1
    var cond = parseExpr(p)
    p.exprLev = prevLev
    var body = parseBlockStmt(p)
    var stmt = ast.Stmt{
        kind: ast.STMT_ITER,
        iter: {
            pos: pos,
            kind: token.WHILE,
            cond: cond,
            body: body,
        },
    }
    return &&stmt
}

fun parseJumpStmt(p *Parser, keyword token.Token) *ast.Stmt {
    var pos = expect(p, keyword)
    var label *ast.Expr = nil
    if keyword == token.GOTO {
        label = parseIdent(p)
    }
    expect(p, token.SEMICOLON)
    var stmt = ast.Stmt{
        kind: ast.STMT_JUMP,
        jump: {
            pos: pos,
            keyword: keyword,
            label: label,
        },
    }
    return &&stmt
}

fun parseDeclStmt(p *Parser) *ast.Stmt {
    var stmt = ast.Stmt{
        kind: ast.STMT_DECL,
        decl: {
            decl: parseDecl(p),
        },
    }
    return &&stmt
}

fun parseStmt(p *Parser) *ast.Stmt {
    switch p.tok {
    case token.VAR:
        return parseDeclStmt(p)
    case token.FOR:
        return parseForStmt(p)
    case token.IF:
        return parseIfStmt(p)
    case token.RETURN:
        return parseReturnStmt(p)
    case token.SWITCH:
        return parseSwitchStmt(p)
    case token.WHILE:
        return parseWhileStmt(p)
    case token.BREAK, token.CONTINUE, token.FALLTHROUGH, token.GOTO:
        return parseJumpStmt(p, p.tok)
    case token.LBRACE:
        return parseBlockStmt(p)
    default:
        break
    }
    var pos = p.pos
    if accept(p, token.SEMICOLON) {
        var stmt = ast.Stmt{
            kind: ast.STMT_EMPTY,
            empty: {
                pos: pos,
            },
        }
        return &&stmt
    }
    var stmt = parseSimpleStmt(p, true)
    if stmt.kind != ast.STMT_LABEL {
        expect(p, token.SEMICOLON)
    }
    return stmt
}

fun parseStmtList(p *Parser) []*ast.Stmt {
    var stmts = makearray(*ast.Stmt)
    while p.tok != token.RBRACE {
        append(stmts, parseStmt(p))
    }
    return stmts
}

fun parseBody(p *Parser) *ast.Stmt {
    var pos = expect(p, token.LBRACE)
    var list = parseStmtList(p)
    expect(p, token.RBRACE)
    accept(p, token.SEMICOLON)
    var stmt = ast.Stmt{
        kind: ast.STMT_BLOCK,
        block: {
            pos: pos,
            stmts: list,
        },
    }
    return &&stmt
}

fun parseBlockStmt(p *Parser) *ast.Stmt {
    var pos = expect(p, token.LBRACE)
    var list = parseStmtList(p)
    expect(p, token.RBRACE)
    accept(p, token.SEMICOLON)
    var stmt = ast.Stmt{
        kind: ast.STMT_BLOCK,
        block: {
            pos: pos,
            stmts: list,
        },
    }
    return &&stmt
}

fun parsePragma(p *Parser) *ast.Decl {
    var pos = p.pos
    var lit = p.lit
    p.lit = nil
    expect(p, token.HASH)
    var decl = ast.Decl{
        kind: ast.DECL_PRAGMA,
        pos: pos,
        pragma: {
            lit: lit,
        },
    }
    return &&decl
}

fun parseValueDecl(p *Parser) *ast.Decl {
    var keyword = p.tok
    var pos = expect(p, keyword)
    var ident = parseIdent(p)
    var type *ast.Expr = nil
    if p.tok != token.ASSIGN {
        type = parseType(p)
    }
    var value *ast.Expr = nil
    if accept(p, token.ASSIGN) {
        if p.tok == token.LBRACE {
            value = parseLiteralValue(p, nil)
        } else {
            value = parseRhs(p)
        }
    }
    expect(p, token.SEMICOLON)
    var decl = ast.Decl{
        kind: ast.DECL_VALUE,
        pos: pos,
        value: {
            name: ident,
            type: type,
            value: value,
            kind: keyword,
        },
    }
    return &&decl
}

fun parseTypeDecl(p *Parser) *ast.Decl {
    var keyword = p.tok
    var pos = expect(p, keyword)
    var ident = parseIdent(p)
    var type = parseType(p)
    expect(p, token.SEMICOLON)
    var decl = ast.Decl{
        kind: ast.DECL_TYPE,
        pos: pos,
        type: {
            name: ident,
            type: type,
        },
    }
    return &&decl
}

fun parseFuncDecl(p *Parser) *ast.Decl {
    var pos = expect(p, token.FUNC)
    var recv *ast.Decl = nil
    if accept(p, token.LPAREN) {
        recv = parseParam(p, false)
        expect(p, token.RPAREN)
    }
    var name = parseIdent(p)
    var type = ast.Expr{
        kind: ast.TYPE_FUNC,
        func: {
            pos: pos,
            params: parseParameters(p, false),
        },
    }
    if p.tok != token.LBRACE && p.tok != token.SEMICOLON {
        type.func.result = parseType(p)
    }
    var body *ast.Stmt = nil
    if p.tok == token.LBRACE {
        body = parseBody(p)
    } else {
        expect(p, token.SEMICOLON)
    }
    var decl = ast.Decl{
        kind: ast.DECL_FUNC,
        pos: pos,
        func: {
            name: name,
            recv: recv,
            type: &&type,
            body: body,
        },
    }
    return &&decl
}

fun parseDecl(p *Parser) *ast.Decl {
    switch p.tok {
    case token.HASH:
        return parsePragma(p)
    case token.TYPE:
        return parseTypeDecl(p)
    case token.CONST, token.VAR:
        return parseValueDecl(p)
    case token.FUNC:
        return parseFuncDecl(p)
    default:
        error(p, p.pos, C.sprintf("cant handle it: %s", p.tok.string()))
        return nil
    }
}

fun isBlingFile(name runtime.charstr) bool {
    return bytes.hasSuffix(name, ".bling")
}

fun isTestFile(name runtime.charstr) bool {
    return paths.match("*_test.bling", name)
}

fun parseDir(fset *token.FileSet, path runtime.charstr, first **runtime.Error) []*ast.File {
    var err *runtime.Error = nil
    var infos = ioutil.readDir(path, &err)
    var files = makearray(*ast.File)
    if err {
        runtime.Error_move(err, first)
        return files
    }
    for var i = 0; i < len(infos); i++ {
        var name = infos[i].name()
        if isBlingFile(name) && !isTestFile(name) {
            append(files, parseFile(fset, name))
        }
    }
    runtime.Slice_unmake(&infos)
    return files
}

fun _parseFile(p *Parser) *ast.File {
    var name *ast.Expr = nil
    var imports = makearray(*ast.Decl)
    var decls = makearray(*ast.Decl)
    while p.tok == token.HASH {
        append(decls, parsePragma(p))
    }
    if accept(p, token.PACKAGE) {
        name = parseIdent(p)
        expect(p, token.SEMICOLON)
    }
    while p.tok == token.IMPORT {
        var pos = expect(p, token.IMPORT)
        var path = parseBasicLit(p, token.STRING)
        expect(p, token.SEMICOLON)
        var decl = ast.Decl{
            kind: ast.DECL_IMPORT,
            pos: pos,
            imp: {
                path: path,
            },
        }
        append(imports, &&decl)
    }
    while p.tok != token.EOF {
        append(decls, parseDecl(p))
    }
    var file = ast.File{
        filename: p.file.name,
        name: name,
        imports: imports,
        decls: decls,
    }
    return &&file
}

fun parseFile(fset *token.FileSet, filename runtime.charstr) *ast.File {
    var err *runtime.Error = nil
    var src = ioutil.readFile(filename, &err)
    if err {
        panic(C.sprintf("%s: %s", filename, err.error))
    }
    var p = Parser{}
    init(&p, fset, filename, src)
    runtime.free(src)
    return _parseFile(&p)
}
