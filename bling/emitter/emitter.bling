package emitter

import "C"
import "bling/ast"
import "bling/token"
import "bytes"
import "runtime"

typ Emitter struct {
    buf bytes.Buffer
    indent int
    skipSemi bool
    pkg string
    forwardDecl bool
}

fun (e *Emitter) bytes() []char {
    return e.buf
}

fun Emitter_string(e *Emitter) string {
    return e.buf.toString()
}

fun emitBytes(e *Emitter, s []char) {
    e.buf.write(s, nil)
}

fun emitChars(e *Emitter, s [?]const char, n int) {
    e.buf.writeChars(s, n, nil)
}

fun emitString(e *Emitter, s string) {
    e.buf.writeString(s, nil)
}

fun emitSpace(e *Emitter) {
    emitString(e, " ")
}

fun emitNewline(e *Emitter) {
    emitString(e, "\n")
}

fun emitTabs(e *Emitter) {
    for var i = 0; i < e.indent; i++ {
        emitString(e, "    ")
    }
}

fun emitToken(e *Emitter, tok token.Token) {
    if e.skipSemi && tok == token.SEMICOLON {
        return
    }
    emitString(e, tok.string())
}

fun hasPrefix(s string, prefix string) bool {
    for var i = 0; prefix[i]; i++ {
        if s[i] != prefix[i] {
            return false
        }
    }
    return true
}

fun isSimpleType(t *ast.Expr) bool {
    if t == nil {
        return false
    }
    if t.kind == ast.TYPE_ARRAY && !t.array_.dynamic {
        t = t.array_.elt
    }
    switch t.kind {
    case ast.EXPR_PAREN, ast.EXPR_IDENT, ast.EXPR_SELECTOR:
        return true
    default:
        return false
    }
}

fun emitExpr(e *Emitter, expr *ast.Expr) {
    if !expr {
        panic("emitter$emitExpr: expr is nil")
    }
    switch expr.kind {
    case ast.EXPR_BASIC_LIT:
        emitString(e, expr.basic.value)
        break
    case ast.EXPR_BINARY:
        emitExpr(e, expr.binary.x)
        emitSpace(e)
        emitToken(e, expr.binary.op)
        emitSpace(e)
        emitExpr(e, expr.binary.y)
        break
    case ast.EXPR_CALL:
        emitExpr(e, expr.call.func)
        emitToken(e, token.LPAREN)
        for var i = 0; i < len(expr.call.args); i++ {
            if i > 0 {
                emitToken(e, token.COMMA)
                emitSpace(e)
            }
            emitExpr(e, expr.call.args[i])
        }
        emitToken(e, token.RPAREN)
        break
    case ast.EXPR_CAST:
        emitToken(e, token.TYPE)
        emitSpace(e)
        emitType(e, expr.cast.type)
        emitToken(e, token.LPAREN)
        emitExpr(e, expr.cast.expr)
        emitToken(e, token.RPAREN)
        break
    case ast.EXPR_COMPOSITE_LIT:
        if isSimpleType(expr.composite.type) {
            emitType(e, expr.composite.type)
        }
        emitToken(e, token.LBRACE)
        if len(expr.composite.list) > 0 {
            emitNewline(e)
            e.indent++
            for var i = 0; i < len(expr.composite.list); i++ {
                emitTabs(e)
                emitExpr(e, expr.composite.list[i])
                emitToken(e, token.COMMA)
                emitNewline(e)
            }
            e.indent--
            emitTabs(e)
        }
        emitToken(e, token.RBRACE)
        break
    case ast.EXPR_IDENT:
        emitString(e, expr.ident.name)
        break
    case ast.EXPR_INDEX:
        if isSimpleType(expr.index.x) {
            emitExpr(e, expr.index.x)
        } else {
            emitToken(e, token.LPAREN)
            emitExpr(e, expr.index.x)
            emitToken(e, token.RPAREN)
        }
        emitToken(e, token.LBRACK)
        emitExpr(e, expr.index.index)
        emitToken(e, token.RBRACK)
        break
    case ast.EXPR_KEY_VALUE:
        emitExpr(e, expr.key_value.key)
        emitToken(e, token.COLON)
        emitSpace(e)
        emitExpr(e, expr.key_value.value)
        break
    case ast.EXPR_PAREN:
        emitToken(e, token.LPAREN)
        emitExpr(e, expr.paren.x)
        emitToken(e, token.RPAREN)
        break
    case ast.EXPR_SELECTOR:
        emitExpr(e, expr.selector.x)
        emitToken(e, token.PERIOD)
        emitExpr(e, expr.selector.sel)
        break
    case ast.EXPR_STAR:
        emitToken(e, token.MUL)
        emitExpr(e, expr.star.x)
        break
    case ast.EXPR_TERNARY:
        emitExpr(e, expr.ternary.cond)
        emitSpace(e)
        emitToken(e, token.QUESTION_MARK)
        if expr.ternary.x {
            emitSpace(e)
            emitExpr(e, expr.ternary.x)
            emitSpace(e)
        }
        emitToken(e, token.COLON)
        emitSpace(e)
        emitExpr(e, expr.ternary.y)
        break
    case ast.EXPR_UNARY:
        if expr.unary.op == token.SIZEOF {
            emitToken(e, expr.unary.op)
            emitToken(e, token.LPAREN)
            emitType(e, expr.unary.x)
            emitToken(e, token.RPAREN)
        } else {
            emitToken(e, expr.unary.op)
            emitExpr(e, expr.unary.x)
        }
        break
    default:
        panic("Unknown expr")
        break
    }
}

fun emitStmt(e *Emitter, stmt *ast.Stmt) {
    switch stmt.kind {
    case ast.STMT_ASSIGN:
        emitExpr(e, stmt.assign.x)
        emitSpace(e)
        emitToken(e, stmt.assign.op)
        emitSpace(e)
        emitExpr(e, stmt.assign.y)
        break
    case ast.STMT_BLOCK:
        emitToken(e, token.LBRACE)
        emitNewline(e)
        e.indent++
        for var i = 0; i < len(stmt.block.stmts); i++ {
            switch stmt.block.stmts[i].kind {
            case ast.STMT_LABEL:
                break
            default:
                emitTabs(e)
                break
            }
            emitStmt(e, stmt.block.stmts[i])
            emitNewline(e)
        }
        e.indent--
        emitTabs(e)
        emitToken(e, token.RBRACE)
        break
    case ast.STMT_CASE:
        if len(stmt.case_.exprs) > 0 {
            emitToken(e, token.CASE)
            emitSpace(e)
            for var i = 0; i < len(stmt.case_.exprs); i++ {
                if i > 0 {
                    emitToken(e, token.COMMA)
                    emitSpace(e)
                }
                emitExpr(e, stmt.case_.exprs[i])
            }
        } else {
            emitToken(e, token.DEFAULT)
        }
        emitToken(e, token.COLON)
        if len(stmt.case_.stmts) > 0 {
            var first = stmt.case_.stmts[0]
            var oneline = false
            switch first.kind {
            case ast.STMT_BLOCK, ast.STMT_JUMP, ast.STMT_RETURN:
                break
            default:
                break
            }
            if oneline {
                emitSpace(e)
                emitStmt(e, first)
                emitNewline(e)
            } else {
                emitNewline(e)
                e.indent++
                for var i = 0; i < len(stmt.case_.stmts); i++ {
                    emitTabs(e)
                    emitStmt(e, stmt.case_.stmts[i])
                    emitNewline(e)
                }
                e.indent--
            }
        }
        break
    case ast.STMT_DECL:
        emitDecl(e, stmt.decl.decl)
        break
    case ast.STMT_EMPTY:
        emitToken(e, token.SEMICOLON)
        break
    case ast.STMT_EXPR:
        emitExpr(e, stmt.expr.x)
        break
    case ast.STMT_IF:
        emitToken(e, token.IF)
        emitSpace(e)
        emitExpr(e, stmt.if_.cond)
        emitSpace(e)
        emitStmt(e, stmt.if_.body)
        if stmt.if_.else_ {
            emitSpace(e)
            emitToken(e, token.ELSE)
            emitSpace(e)
            emitStmt(e, stmt.if_.else_)
        }
        break
    case ast.STMT_ITER:
        emitToken(e, stmt.iter.kind)
        if stmt.iter.kind == token.FOR {
            emitSpace(e)
            if stmt.iter.init {
                emitStmt(e, stmt.iter.init)
            }
            emitToken(e, token.SEMICOLON)
        }
        if stmt.iter.cond {
            emitSpace(e)
            emitExpr(e, stmt.iter.cond)
        }
        if stmt.iter.kind == token.FOR {
            emitToken(e, token.SEMICOLON)
            if stmt.iter.post {
                emitSpace(e)
                e.skipSemi = true
                emitStmt(e, stmt.iter.post)
                e.skipSemi = false
            }
        }
        emitSpace(e)
        emitStmt(e, stmt.iter.body)
        break
    case ast.STMT_JUMP:
        emitToken(e, stmt.jump.keyword)
        if stmt.jump.label {
            emitSpace(e)
            emitExpr(e, stmt.jump.label)
        }
        break
    case ast.STMT_LABEL:
        emitExpr(e, stmt.label.label)
        emitToken(e, token.COLON)
        emitNewline(e)
        emitTabs(e)
        emitStmt(e, stmt.label.stmt)
        break
    case ast.STMT_POSTFIX:
        emitExpr(e, stmt.postfix.x)
        emitToken(e, stmt.postfix.op)
        break
    case ast.STMT_RETURN:
        emitToken(e, token.RETURN)
        if stmt.return_.x {
            emitSpace(e)
            emitExpr(e, stmt.return_.x)
        }
        break
    case ast.STMT_SWITCH:
        emitToken(e, token.SWITCH)
        emitSpace(e)
        emitExpr(e, stmt.switch_.tag)
        emitSpace(e)
        emitToken(e, token.LBRACE)
        emitNewline(e)
        for var i = 0; i < len(stmt.switch_.stmts); i++ {
            emitTabs(e)
            emitStmt(e, stmt.switch_.stmts[i])
        }
        emitTabs(e)
        emitToken(e, token.RBRACE)
        break
    default:
        panic("Unknown stmt")
        break
    }
}

fun is_void(type *ast.Expr) bool {
    return type == nil || (type.kind == ast.EXPR_IDENT && runtime.streq(type.ident.name, "void"))
}

fun emitType(e *Emitter, type *ast.Expr) {
    if type.is_const {
        emitToken(e, token.CONST)
        emitSpace(e)
    }
    switch type.kind {
    case ast.EXPR_IDENT, ast.EXPR_SELECTOR:
        emitExpr(e, type)
        break
    case ast.EXPR_STAR:
        type = type.star.x
        if type.kind == ast.TYPE_FUNC {
            emitToken(e, token.FUNC)
            emitToken(e, token.LPAREN)
            for var i = 0; i < len(type.func.params); i++ {
                if i > 0 {
                    emitToken(e, token.COMMA)
                    emitSpace(e)
                }
                emitDecl(e, type.func.params[i])
            }
            emitToken(e, token.RPAREN)
            if !is_void(type.func.result) {
                emitSpace(e)
                emitType(e, type.func.result)
            }
        } else {
            emitToken(e, token.MUL)
            emitType(e, type)
        }
        break
    case ast.TYPE_ARRAY:
        emitToken(e, token.LBRACK)
        if !type.array_.dynamic {
            if type.array_.len {
                emitExpr(e, type.array_.len)
            } else {
                emitToken(e, token.QUESTION_MARK)
            }
        }
        emitToken(e, token.RBRACK)
        emitType(e, type.array_.elt)
        break
    case ast.TYPE_BUILTIN:
        emitString(e, "/* builtin func ")
        emitString(e, type.builtin.name)
        emitString(e, " */")
        break
    case ast.TYPE_ELLIPSIS:
        emitToken(e, token.ELLIPSIS)
        break
    case ast.TYPE_ENUM:
        emitToken(e, token.ENUM)
        if len(type.enum_.enums) > 0 {
            emitSpace(e)
            emitToken(e, token.LBRACE)
            emitNewline(e)
            e.indent++
            for var i = 0; i < len(type.enum_.enums); i++ {
                var decl = type.enum_.enums[i]
                emitTabs(e)
                emitExpr(e, decl.value.name)
                if decl.value.value {
                    emitSpace(e)
                    emitToken(e, token.ASSIGN)
                    emitSpace(e)
                    emitExpr(e, decl.value.value)
                }
                emitNewline(e)
            }
            e.indent--
            emitTabs(e)
            emitToken(e, token.RBRACE)
        }
        break
    case ast.TYPE_FUNC:
        emitToken(e, token.LPAREN)
        for var i = 0; i < len(type.func.params); i++ {
            if i > 0 {
                emitToken(e, token.COMMA)
                emitSpace(e)
            }
            emitDecl(e, type.func.params[i])
        }
        emitToken(e, token.RPAREN)
        if !is_void(type.func.result) {
            emitSpace(e)
            emitType(e, type.func.result)
        }
        break
    case ast.TYPE_MAP:
        emitToken(e, token.MAP)
        emitSpace(e)
        emitType(e, type.map_.val)
        break
    case ast.TYPE_NATIVE:
        emitString(e, type.native.name)
        break
    case ast.TYPE_STRUCT:
        emitToken(e, type.struct_.tok)
        if len(type.struct_.fields) > 0 {
            emitSpace(e)
            emitToken(e, token.LBRACE)
            emitNewline(e)
            e.indent++
            for var i = 0; i < len(type.struct_.fields); i++ {
                emitTabs(e)
                emitDecl(e, type.struct_.fields[i])
                emitNewline(e)
            }
            e.indent--
            emitTabs(e)
            emitToken(e, token.RBRACE)
        }
        break
    default:
        panic(C.sprintf("Unknown type: %d", type.kind))
    }
}

fun emitDecl(e *Emitter, decl *ast.Decl) {
    switch decl.kind {
    case ast.DECL_FIELD:
        if decl.field.name != nil {
            emitExpr(e, decl.field.name)
            emitSpace(e)
        }
        emitType(e, decl.field.type)
        break
    case ast.DECL_FUNC:
        emitToken(e, token.FUNC)
        emitSpace(e)
        emitExpr(e, decl.func.name)
        emitType(e, decl.func.type)
        if decl.func.body {
            emitSpace(e)
            emitStmt(e, decl.func.body)
        }
        break
    case ast.DECL_IMPORT:
        emitToken(e, token.IMPORT)
        emitSpace(e)
        emitExpr(e, decl.imp.path)
        break
    case ast.DECL_TYPE:
        emitToken(e, token.TYPE)
        emitSpace(e)
        emitExpr(e, decl.type.name)
        emitSpace(e)
        emitType(e, decl.type.type)
        break
    case ast.DECL_PRAGMA:
        emitToken(e, token.HASH)
        emitString(e, decl.pragma.lit)
        break
    case ast.DECL_VALUE:
        switch decl.value.kind {
        case token.VAR:
            emitToken(e, token.VAR)
            if decl.value.name {
                emitSpace(e)
                emitExpr(e, decl.value.name)
            }
            var omitType = false
            if decl.value.value {
                switch decl.value.value.kind {
                case ast.EXPR_COMPOSITE_LIT:
                    omitType = isSimpleType(decl.value.value.composite.type)
                    break
                default:
                    break
                }
            }
            if !omitType {
                emitSpace(e)
                emitType(e, decl.value.type)
            }
            if decl.value.value {
                emitSpace(e)
                emitToken(e, token.ASSIGN)
                emitSpace(e)
                emitExpr(e, decl.value.value)
            }
            break
        case token.CONST:
            emitToken(e, token.HASH)
            emitString(e, "define")
            emitSpace(e)
            emitExpr(e, decl.value.value)
            break
        default:
            panic(C.sprintf("bad kind for ast$DECL_VALUE: %s", decl.value.kind.string()))
            break
        }
        break
    default:
        panic("Unknown decl")
        break
    }
}

fun emitFile(e *Emitter, file *ast.File) {
    if file.name {
        e.pkg = file.name.ident.name
    }
    emitString(e, "//")
    emitString(e, file.filename)
    emitNewline(e)
    if file.name != nil {
        emitToken(e, token.PACKAGE)
        emitSpace(e)
        emitExpr(e, file.name)
        emitNewline(e)
        emitNewline(e)
    }
    for var i = 0; i < len(file.imports); i++ {
        emitToken(e, token.IMPORT)
        emitSpace(e)
        emitExpr(e, file.imports[i].imp.path)
        emitNewline(e)
    }
    for var i = 0; i < len(file.decls); i++ {
        emitNewline(e)
        emitDecl(e, file.decls[i])
        emitNewline(e)
    }
}
